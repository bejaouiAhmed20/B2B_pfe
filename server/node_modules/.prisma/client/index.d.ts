
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model airport
 * 
 */
export type airport = $Result.DefaultSelection<Prisma.$airportPayload>
/**
 * Model compte
 * 
 */
export type compte = $Result.DefaultSelection<Prisma.$comptePayload>
/**
 * Model contract
 * 
 */
export type contract = $Result.DefaultSelection<Prisma.$contractPayload>
/**
 * Model contract_coupons
 * 
 */
export type contract_coupons = $Result.DefaultSelection<Prisma.$contract_couponsPayload>
/**
 * Model coupon
 * 
 */
export type coupon = $Result.DefaultSelection<Prisma.$couponPayload>
/**
 * Model flight
 * 
 */
export type flight = $Result.DefaultSelection<Prisma.$flightPayload>
/**
 * Model flight_seat_reservation
 * 
 */
export type flight_seat_reservation = $Result.DefaultSelection<Prisma.$flight_seat_reservationPayload>
/**
 * Model location
 * 
 */
export type location = $Result.DefaultSelection<Prisma.$locationPayload>
/**
 * Model news
 * 
 */
export type news = $Result.DefaultSelection<Prisma.$newsPayload>
/**
 * Model plane
 * 
 */
export type plane = $Result.DefaultSelection<Prisma.$planePayload>
/**
 * Model reclamation
 * 
 */
export type reclamation = $Result.DefaultSelection<Prisma.$reclamationPayload>
/**
 * Model request_solde
 * 
 */
export type request_solde = $Result.DefaultSelection<Prisma.$request_soldePayload>
/**
 * Model reservation
 * 
 */
export type reservation = $Result.DefaultSelection<Prisma.$reservationPayload>
/**
 * Model seat
 * 
 */
export type seat = $Result.DefaultSelection<Prisma.$seatPayload>
/**
 * Model seat_reservation
 * 
 */
export type seat_reservation = $Result.DefaultSelection<Prisma.$seat_reservationPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const seat_classType: {
  economy: 'economy',
  business: 'business',
  first: 'first'
};

export type seat_classType = (typeof seat_classType)[keyof typeof seat_classType]


export const coupon_reduction_type: {
  percentage: 'percentage',
  fixed: 'fixed'
};

export type coupon_reduction_type = (typeof coupon_reduction_type)[keyof typeof coupon_reduction_type]


export const request_solde_status: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type request_solde_status = (typeof request_solde_status)[keyof typeof request_solde_status]

}

export type seat_classType = $Enums.seat_classType

export const seat_classType: typeof $Enums.seat_classType

export type coupon_reduction_type = $Enums.coupon_reduction_type

export const coupon_reduction_type: typeof $Enums.coupon_reduction_type

export type request_solde_status = $Enums.request_solde_status

export const request_solde_status: typeof $Enums.request_solde_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Airports
 * const airports = await prisma.airport.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Airports
   * const airports = await prisma.airport.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.airport`: Exposes CRUD operations for the **airport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airports
    * const airports = await prisma.airport.findMany()
    * ```
    */
  get airport(): Prisma.airportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compte`: Exposes CRUD operations for the **compte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comptes
    * const comptes = await prisma.compte.findMany()
    * ```
    */
  get compte(): Prisma.compteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.contractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract_coupons`: Exposes CRUD operations for the **contract_coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contract_coupons
    * const contract_coupons = await prisma.contract_coupons.findMany()
    * ```
    */
  get contract_coupons(): Prisma.contract_couponsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.couponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flight`: Exposes CRUD operations for the **flight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flights
    * const flights = await prisma.flight.findMany()
    * ```
    */
  get flight(): Prisma.flightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flight_seat_reservation`: Exposes CRUD operations for the **flight_seat_reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flight_seat_reservations
    * const flight_seat_reservations = await prisma.flight_seat_reservation.findMany()
    * ```
    */
  get flight_seat_reservation(): Prisma.flight_seat_reservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **news** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.newsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plane`: Exposes CRUD operations for the **plane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planes
    * const planes = await prisma.plane.findMany()
    * ```
    */
  get plane(): Prisma.planeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reclamation`: Exposes CRUD operations for the **reclamation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reclamations
    * const reclamations = await prisma.reclamation.findMany()
    * ```
    */
  get reclamation(): Prisma.reclamationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.request_solde`: Exposes CRUD operations for the **request_solde** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Request_soldes
    * const request_soldes = await prisma.request_solde.findMany()
    * ```
    */
  get request_solde(): Prisma.request_soldeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.reservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seat`: Exposes CRUD operations for the **seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seats
    * const seats = await prisma.seat.findMany()
    * ```
    */
  get seat(): Prisma.seatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seat_reservation`: Exposes CRUD operations for the **seat_reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seat_reservations
    * const seat_reservations = await prisma.seat_reservation.findMany()
    * ```
    */
  get seat_reservation(): Prisma.seat_reservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    airport: 'airport',
    compte: 'compte',
    contract: 'contract',
    contract_coupons: 'contract_coupons',
    coupon: 'coupon',
    flight: 'flight',
    flight_seat_reservation: 'flight_seat_reservation',
    location: 'location',
    news: 'news',
    plane: 'plane',
    reclamation: 'reclamation',
    request_solde: 'request_solde',
    reservation: 'reservation',
    seat: 'seat',
    seat_reservation: 'seat_reservation',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "airport" | "compte" | "contract" | "contract_coupons" | "coupon" | "flight" | "flight_seat_reservation" | "location" | "news" | "plane" | "reclamation" | "request_solde" | "reservation" | "seat" | "seat_reservation" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      airport: {
        payload: Prisma.$airportPayload<ExtArgs>
        fields: Prisma.airportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.airportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.airportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          findFirst: {
            args: Prisma.airportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.airportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          findMany: {
            args: Prisma.airportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>[]
          }
          create: {
            args: Prisma.airportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          createMany: {
            args: Prisma.airportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.airportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          update: {
            args: Prisma.airportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          deleteMany: {
            args: Prisma.airportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.airportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.airportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          aggregate: {
            args: Prisma.AirportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirport>
          }
          groupBy: {
            args: Prisma.airportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirportGroupByOutputType>[]
          }
          count: {
            args: Prisma.airportCountArgs<ExtArgs>
            result: $Utils.Optional<AirportCountAggregateOutputType> | number
          }
        }
      }
      compte: {
        payload: Prisma.$comptePayload<ExtArgs>
        fields: Prisma.compteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.compteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.compteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>
          }
          findFirst: {
            args: Prisma.compteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.compteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>
          }
          findMany: {
            args: Prisma.compteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>[]
          }
          create: {
            args: Prisma.compteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>
          }
          createMany: {
            args: Prisma.compteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.compteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>
          }
          update: {
            args: Prisma.compteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>
          }
          deleteMany: {
            args: Prisma.compteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.compteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.compteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptePayload>
          }
          aggregate: {
            args: Prisma.CompteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompte>
          }
          groupBy: {
            args: Prisma.compteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompteGroupByOutputType>[]
          }
          count: {
            args: Prisma.compteCountArgs<ExtArgs>
            result: $Utils.Optional<CompteCountAggregateOutputType> | number
          }
        }
      }
      contract: {
        payload: Prisma.$contractPayload<ExtArgs>
        fields: Prisma.contractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>
          }
          findFirst: {
            args: Prisma.contractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>
          }
          findMany: {
            args: Prisma.contractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>[]
          }
          create: {
            args: Prisma.contractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>
          }
          createMany: {
            args: Prisma.contractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>
          }
          update: {
            args: Prisma.contractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>
          }
          deleteMany: {
            args: Prisma.contractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.contractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.contractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      contract_coupons: {
        payload: Prisma.$contract_couponsPayload<ExtArgs>
        fields: Prisma.contract_couponsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contract_couponsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contract_couponsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>
          }
          findFirst: {
            args: Prisma.contract_couponsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contract_couponsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>
          }
          findMany: {
            args: Prisma.contract_couponsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>[]
          }
          create: {
            args: Prisma.contract_couponsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>
          }
          createMany: {
            args: Prisma.contract_couponsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contract_couponsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>
          }
          update: {
            args: Prisma.contract_couponsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>
          }
          deleteMany: {
            args: Prisma.contract_couponsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contract_couponsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contract_couponsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contract_couponsPayload>
          }
          aggregate: {
            args: Prisma.Contract_couponsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract_coupons>
          }
          groupBy: {
            args: Prisma.contract_couponsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contract_couponsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contract_couponsCountArgs<ExtArgs>
            result: $Utils.Optional<Contract_couponsCountAggregateOutputType> | number
          }
        }
      }
      coupon: {
        payload: Prisma.$couponPayload<ExtArgs>
        fields: Prisma.couponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.couponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.couponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          findFirst: {
            args: Prisma.couponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.couponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          findMany: {
            args: Prisma.couponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>[]
          }
          create: {
            args: Prisma.couponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          createMany: {
            args: Prisma.couponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.couponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          update: {
            args: Prisma.couponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          deleteMany: {
            args: Prisma.couponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.couponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.couponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.couponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.couponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      flight: {
        payload: Prisma.$flightPayload<ExtArgs>
        fields: Prisma.flightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          findFirst: {
            args: Prisma.flightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          findMany: {
            args: Prisma.flightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>[]
          }
          create: {
            args: Prisma.flightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          createMany: {
            args: Prisma.flightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.flightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          update: {
            args: Prisma.flightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          deleteMany: {
            args: Prisma.flightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.flightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          aggregate: {
            args: Prisma.FlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlight>
          }
          groupBy: {
            args: Prisma.flightGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.flightCountArgs<ExtArgs>
            result: $Utils.Optional<FlightCountAggregateOutputType> | number
          }
        }
      }
      flight_seat_reservation: {
        payload: Prisma.$flight_seat_reservationPayload<ExtArgs>
        fields: Prisma.flight_seat_reservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flight_seat_reservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flight_seat_reservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>
          }
          findFirst: {
            args: Prisma.flight_seat_reservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flight_seat_reservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>
          }
          findMany: {
            args: Prisma.flight_seat_reservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>[]
          }
          create: {
            args: Prisma.flight_seat_reservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>
          }
          createMany: {
            args: Prisma.flight_seat_reservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.flight_seat_reservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>
          }
          update: {
            args: Prisma.flight_seat_reservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>
          }
          deleteMany: {
            args: Prisma.flight_seat_reservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flight_seat_reservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.flight_seat_reservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flight_seat_reservationPayload>
          }
          aggregate: {
            args: Prisma.Flight_seat_reservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlight_seat_reservation>
          }
          groupBy: {
            args: Prisma.flight_seat_reservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Flight_seat_reservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.flight_seat_reservationCountArgs<ExtArgs>
            result: $Utils.Optional<Flight_seat_reservationCountAggregateOutputType> | number
          }
        }
      }
      location: {
        payload: Prisma.$locationPayload<ExtArgs>
        fields: Prisma.locationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findFirst: {
            args: Prisma.locationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findMany: {
            args: Prisma.locationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          create: {
            args: Prisma.locationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          createMany: {
            args: Prisma.locationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.locationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          update: {
            args: Prisma.locationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          deleteMany: {
            args: Prisma.locationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.locationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.locationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      news: {
        payload: Prisma.$newsPayload<ExtArgs>
        fields: Prisma.newsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>
          }
          findFirst: {
            args: Prisma.newsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>
          }
          findMany: {
            args: Prisma.newsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>[]
          }
          create: {
            args: Prisma.newsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>
          }
          createMany: {
            args: Prisma.newsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.newsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>
          }
          update: {
            args: Prisma.newsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>
          }
          deleteMany: {
            args: Prisma.newsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.newsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      plane: {
        payload: Prisma.$planePayload<ExtArgs>
        fields: Prisma.planeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>
          }
          findFirst: {
            args: Prisma.planeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>
          }
          findMany: {
            args: Prisma.planeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>[]
          }
          create: {
            args: Prisma.planeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>
          }
          createMany: {
            args: Prisma.planeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.planeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>
          }
          update: {
            args: Prisma.planeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>
          }
          deleteMany: {
            args: Prisma.planeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.planeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.planeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planePayload>
          }
          aggregate: {
            args: Prisma.PlaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlane>
          }
          groupBy: {
            args: Prisma.planeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.planeCountArgs<ExtArgs>
            result: $Utils.Optional<PlaneCountAggregateOutputType> | number
          }
        }
      }
      reclamation: {
        payload: Prisma.$reclamationPayload<ExtArgs>
        fields: Prisma.reclamationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reclamationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reclamationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>
          }
          findFirst: {
            args: Prisma.reclamationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reclamationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>
          }
          findMany: {
            args: Prisma.reclamationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>[]
          }
          create: {
            args: Prisma.reclamationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>
          }
          createMany: {
            args: Prisma.reclamationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reclamationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>
          }
          update: {
            args: Prisma.reclamationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>
          }
          deleteMany: {
            args: Prisma.reclamationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reclamationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reclamationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reclamationPayload>
          }
          aggregate: {
            args: Prisma.ReclamationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReclamation>
          }
          groupBy: {
            args: Prisma.reclamationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReclamationGroupByOutputType>[]
          }
          count: {
            args: Prisma.reclamationCountArgs<ExtArgs>
            result: $Utils.Optional<ReclamationCountAggregateOutputType> | number
          }
        }
      }
      request_solde: {
        payload: Prisma.$request_soldePayload<ExtArgs>
        fields: Prisma.request_soldeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.request_soldeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.request_soldeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>
          }
          findFirst: {
            args: Prisma.request_soldeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.request_soldeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>
          }
          findMany: {
            args: Prisma.request_soldeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>[]
          }
          create: {
            args: Prisma.request_soldeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>
          }
          createMany: {
            args: Prisma.request_soldeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.request_soldeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>
          }
          update: {
            args: Prisma.request_soldeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>
          }
          deleteMany: {
            args: Prisma.request_soldeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.request_soldeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.request_soldeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_soldePayload>
          }
          aggregate: {
            args: Prisma.Request_soldeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequest_solde>
          }
          groupBy: {
            args: Prisma.request_soldeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Request_soldeGroupByOutputType>[]
          }
          count: {
            args: Prisma.request_soldeCountArgs<ExtArgs>
            result: $Utils.Optional<Request_soldeCountAggregateOutputType> | number
          }
        }
      }
      reservation: {
        payload: Prisma.$reservationPayload<ExtArgs>
        fields: Prisma.reservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>
          }
          findFirst: {
            args: Prisma.reservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>
          }
          findMany: {
            args: Prisma.reservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>[]
          }
          create: {
            args: Prisma.reservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>
          }
          createMany: {
            args: Prisma.reservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>
          }
          update: {
            args: Prisma.reservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>
          }
          deleteMany: {
            args: Prisma.reservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.reservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.reservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      seat: {
        payload: Prisma.$seatPayload<ExtArgs>
        fields: Prisma.seatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          findFirst: {
            args: Prisma.seatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          findMany: {
            args: Prisma.seatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>[]
          }
          create: {
            args: Prisma.seatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          createMany: {
            args: Prisma.seatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.seatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          update: {
            args: Prisma.seatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          deleteMany: {
            args: Prisma.seatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          aggregate: {
            args: Prisma.SeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat>
          }
          groupBy: {
            args: Prisma.seatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.seatCountArgs<ExtArgs>
            result: $Utils.Optional<SeatCountAggregateOutputType> | number
          }
        }
      }
      seat_reservation: {
        payload: Prisma.$seat_reservationPayload<ExtArgs>
        fields: Prisma.seat_reservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seat_reservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seat_reservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>
          }
          findFirst: {
            args: Prisma.seat_reservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seat_reservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>
          }
          findMany: {
            args: Prisma.seat_reservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>[]
          }
          create: {
            args: Prisma.seat_reservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>
          }
          createMany: {
            args: Prisma.seat_reservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.seat_reservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>
          }
          update: {
            args: Prisma.seat_reservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>
          }
          deleteMany: {
            args: Prisma.seat_reservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seat_reservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seat_reservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seat_reservationPayload>
          }
          aggregate: {
            args: Prisma.Seat_reservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat_reservation>
          }
          groupBy: {
            args: Prisma.seat_reservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Seat_reservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.seat_reservationCountArgs<ExtArgs>
            result: $Utils.Optional<Seat_reservationCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    airport?: airportOmit
    compte?: compteOmit
    contract?: contractOmit
    contract_coupons?: contract_couponsOmit
    coupon?: couponOmit
    flight?: flightOmit
    flight_seat_reservation?: flight_seat_reservationOmit
    location?: locationOmit
    news?: newsOmit
    plane?: planeOmit
    reclamation?: reclamationOmit
    request_solde?: request_soldeOmit
    reservation?: reservationOmit
    seat?: seatOmit
    seat_reservation?: seat_reservationOmit
    user?: userOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AirportCountOutputType
   */

  export type AirportCountOutputType = {
    flight_flight_airport_depart_idToairport: number
    flight_flight_airport_arrivee_idToairport: number
  }

  export type AirportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight_flight_airport_depart_idToairport?: boolean | AirportCountOutputTypeCountFlight_flight_airport_depart_idToairportArgs
    flight_flight_airport_arrivee_idToairport?: boolean | AirportCountOutputTypeCountFlight_flight_airport_arrivee_idToairportArgs
  }

  // Custom InputTypes
  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirportCountOutputType
     */
    select?: AirportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountFlight_flight_airport_depart_idToairportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountFlight_flight_airport_arrivee_idToairportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    contract_coupons: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract_coupons?: boolean | ContractCountOutputTypeCountContract_couponsArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountContract_couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contract_couponsWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    contract: number
    contract_coupons: number
    reservation: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | CouponCountOutputTypeCountContractArgs
    contract_coupons?: boolean | CouponCountOutputTypeCountContract_couponsArgs
    reservation?: boolean | CouponCountOutputTypeCountReservationArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contractWhereInput
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountContract_couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contract_couponsWhereInput
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservationWhereInput
  }


  /**
   * Count Type FlightCountOutputType
   */

  export type FlightCountOutputType = {
    flight_seat_reservation: number
    reservation: number
    seat_reservation: number
  }

  export type FlightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight_seat_reservation?: boolean | FlightCountOutputTypeCountFlight_seat_reservationArgs
    reservation?: boolean | FlightCountOutputTypeCountReservationArgs
    seat_reservation?: boolean | FlightCountOutputTypeCountSeat_reservationArgs
  }

  // Custom InputTypes
  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightCountOutputType
     */
    select?: FlightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountFlight_seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flight_seat_reservationWhereInput
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservationWhereInput
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountSeat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seat_reservationWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    airport: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airport?: boolean | LocationCountOutputTypeCountAirportArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAirportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: airportWhereInput
  }


  /**
   * Count Type PlaneCountOutputType
   */

  export type PlaneCountOutputType = {
    flight: number
    seat: number
  }

  export type PlaneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight?: boolean | PlaneCountOutputTypeCountFlightArgs
    seat?: boolean | PlaneCountOutputTypeCountSeatArgs
  }

  // Custom InputTypes
  /**
   * PlaneCountOutputType without action
   */
  export type PlaneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaneCountOutputType
     */
    select?: PlaneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaneCountOutputType without action
   */
  export type PlaneCountOutputTypeCountFlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
  }

  /**
   * PlaneCountOutputType without action
   */
  export type PlaneCountOutputTypeCountSeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seatWhereInput
  }


  /**
   * Count Type ReservationCountOutputType
   */

  export type ReservationCountOutputType = {
    flight_seat_reservation: number
    seat_reservation: number
  }

  export type ReservationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight_seat_reservation?: boolean | ReservationCountOutputTypeCountFlight_seat_reservationArgs
    seat_reservation?: boolean | ReservationCountOutputTypeCountSeat_reservationArgs
  }

  // Custom InputTypes
  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountFlight_seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flight_seat_reservationWhereInput
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountSeat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seat_reservationWhereInput
  }


  /**
   * Count Type SeatCountOutputType
   */

  export type SeatCountOutputType = {
    flight_seat_reservation: number
    seat_reservation: number
  }

  export type SeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight_seat_reservation?: boolean | SeatCountOutputTypeCountFlight_seat_reservationArgs
    seat_reservation?: boolean | SeatCountOutputTypeCountSeat_reservationArgs
  }

  // Custom InputTypes
  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatCountOutputType
     */
    select?: SeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountFlight_seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flight_seat_reservationWhereInput
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountSeat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seat_reservationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    contract: number
    reclamation: number
    request_solde: number
    reservation: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | UserCountOutputTypeCountContractArgs
    reclamation?: boolean | UserCountOutputTypeCountReclamationArgs
    request_solde?: boolean | UserCountOutputTypeCountRequest_soldeArgs
    reservation?: boolean | UserCountOutputTypeCountReservationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReclamationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reclamationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequest_soldeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: request_soldeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model airport
   */

  export type AggregateAirport = {
    _count: AirportCountAggregateOutputType | null
    _avg: AirportAvgAggregateOutputType | null
    _sum: AirportSumAggregateOutputType | null
    _min: AirportMinAggregateOutputType | null
    _max: AirportMaxAggregateOutputType | null
  }

  export type AirportAvgAggregateOutputType = {
    est_actif: number | null
  }

  export type AirportSumAggregateOutputType = {
    est_actif: number | null
  }

  export type AirportMinAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    pays: string | null
    description: string | null
    est_actif: number | null
    location_id: string | null
  }

  export type AirportMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    pays: string | null
    description: string | null
    est_actif: number | null
    location_id: string | null
  }

  export type AirportCountAggregateOutputType = {
    id: number
    nom: number
    code: number
    pays: number
    description: number
    est_actif: number
    location_id: number
    _all: number
  }


  export type AirportAvgAggregateInputType = {
    est_actif?: true
  }

  export type AirportSumAggregateInputType = {
    est_actif?: true
  }

  export type AirportMinAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    pays?: true
    description?: true
    est_actif?: true
    location_id?: true
  }

  export type AirportMaxAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    pays?: true
    description?: true
    est_actif?: true
    location_id?: true
  }

  export type AirportCountAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    pays?: true
    description?: true
    est_actif?: true
    location_id?: true
    _all?: true
  }

  export type AirportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which airport to aggregate.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airports
    **/
    _count?: true | AirportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirportMaxAggregateInputType
  }

  export type GetAirportAggregateType<T extends AirportAggregateArgs> = {
        [P in keyof T & keyof AggregateAirport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirport[P]>
      : GetScalarType<T[P], AggregateAirport[P]>
  }




  export type airportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: airportWhereInput
    orderBy?: airportOrderByWithAggregationInput | airportOrderByWithAggregationInput[]
    by: AirportScalarFieldEnum[] | AirportScalarFieldEnum
    having?: airportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirportCountAggregateInputType | true
    _avg?: AirportAvgAggregateInputType
    _sum?: AirportSumAggregateInputType
    _min?: AirportMinAggregateInputType
    _max?: AirportMaxAggregateInputType
  }

  export type AirportGroupByOutputType = {
    id: string
    nom: string
    code: string
    pays: string
    description: string | null
    est_actif: number
    location_id: string | null
    _count: AirportCountAggregateOutputType | null
    _avg: AirportAvgAggregateOutputType | null
    _sum: AirportSumAggregateOutputType | null
    _min: AirportMinAggregateOutputType | null
    _max: AirportMaxAggregateOutputType | null
  }

  type GetAirportGroupByPayload<T extends airportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirportGroupByOutputType[P]>
            : GetScalarType<T[P], AirportGroupByOutputType[P]>
        }
      >
    >


  export type airportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    pays?: boolean
    description?: boolean
    est_actif?: boolean
    location_id?: boolean
    location?: boolean | airport$locationArgs<ExtArgs>
    flight_flight_airport_depart_idToairport?: boolean | airport$flight_flight_airport_depart_idToairportArgs<ExtArgs>
    flight_flight_airport_arrivee_idToairport?: boolean | airport$flight_flight_airport_arrivee_idToairportArgs<ExtArgs>
    _count?: boolean | AirportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airport"]>



  export type airportSelectScalar = {
    id?: boolean
    nom?: boolean
    code?: boolean
    pays?: boolean
    description?: boolean
    est_actif?: boolean
    location_id?: boolean
  }

  export type airportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "code" | "pays" | "description" | "est_actif" | "location_id", ExtArgs["result"]["airport"]>
  export type airportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | airport$locationArgs<ExtArgs>
    flight_flight_airport_depart_idToairport?: boolean | airport$flight_flight_airport_depart_idToairportArgs<ExtArgs>
    flight_flight_airport_arrivee_idToairport?: boolean | airport$flight_flight_airport_arrivee_idToairportArgs<ExtArgs>
    _count?: boolean | AirportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $airportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "airport"
    objects: {
      location: Prisma.$locationPayload<ExtArgs> | null
      flight_flight_airport_depart_idToairport: Prisma.$flightPayload<ExtArgs>[]
      flight_flight_airport_arrivee_idToairport: Prisma.$flightPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      code: string
      pays: string
      description: string | null
      est_actif: number
      location_id: string | null
    }, ExtArgs["result"]["airport"]>
    composites: {}
  }

  type airportGetPayload<S extends boolean | null | undefined | airportDefaultArgs> = $Result.GetResult<Prisma.$airportPayload, S>

  type airportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<airportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirportCountAggregateInputType | true
    }

  export interface airportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['airport'], meta: { name: 'airport' } }
    /**
     * Find zero or one Airport that matches the filter.
     * @param {airportFindUniqueArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends airportFindUniqueArgs>(args: SelectSubset<T, airportFindUniqueArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Airport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {airportFindUniqueOrThrowArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends airportFindUniqueOrThrowArgs>(args: SelectSubset<T, airportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportFindFirstArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends airportFindFirstArgs>(args?: SelectSubset<T, airportFindFirstArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportFindFirstOrThrowArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends airportFindFirstOrThrowArgs>(args?: SelectSubset<T, airportFindFirstOrThrowArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airports
     * const airports = await prisma.airport.findMany()
     * 
     * // Get first 10 Airports
     * const airports = await prisma.airport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airportWithIdOnly = await prisma.airport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends airportFindManyArgs>(args?: SelectSubset<T, airportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Airport.
     * @param {airportCreateArgs} args - Arguments to create a Airport.
     * @example
     * // Create one Airport
     * const Airport = await prisma.airport.create({
     *   data: {
     *     // ... data to create a Airport
     *   }
     * })
     * 
     */
    create<T extends airportCreateArgs>(args: SelectSubset<T, airportCreateArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Airports.
     * @param {airportCreateManyArgs} args - Arguments to create many Airports.
     * @example
     * // Create many Airports
     * const airport = await prisma.airport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends airportCreateManyArgs>(args?: SelectSubset<T, airportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Airport.
     * @param {airportDeleteArgs} args - Arguments to delete one Airport.
     * @example
     * // Delete one Airport
     * const Airport = await prisma.airport.delete({
     *   where: {
     *     // ... filter to delete one Airport
     *   }
     * })
     * 
     */
    delete<T extends airportDeleteArgs>(args: SelectSubset<T, airportDeleteArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Airport.
     * @param {airportUpdateArgs} args - Arguments to update one Airport.
     * @example
     * // Update one Airport
     * const airport = await prisma.airport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends airportUpdateArgs>(args: SelectSubset<T, airportUpdateArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Airports.
     * @param {airportDeleteManyArgs} args - Arguments to filter Airports to delete.
     * @example
     * // Delete a few Airports
     * const { count } = await prisma.airport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends airportDeleteManyArgs>(args?: SelectSubset<T, airportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airports
     * const airport = await prisma.airport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends airportUpdateManyArgs>(args: SelectSubset<T, airportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Airport.
     * @param {airportUpsertArgs} args - Arguments to update or create a Airport.
     * @example
     * // Update or create a Airport
     * const airport = await prisma.airport.upsert({
     *   create: {
     *     // ... data to create a Airport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airport we want to update
     *   }
     * })
     */
    upsert<T extends airportUpsertArgs>(args: SelectSubset<T, airportUpsertArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportCountArgs} args - Arguments to filter Airports to count.
     * @example
     * // Count the number of Airports
     * const count = await prisma.airport.count({
     *   where: {
     *     // ... the filter for the Airports we want to count
     *   }
     * })
    **/
    count<T extends airportCountArgs>(
      args?: Subset<T, airportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirportAggregateArgs>(args: Subset<T, AirportAggregateArgs>): Prisma.PrismaPromise<GetAirportAggregateType<T>>

    /**
     * Group by Airport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends airportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: airportGroupByArgs['orderBy'] }
        : { orderBy?: airportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, airportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the airport model
   */
  readonly fields: airportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for airport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__airportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends airport$locationArgs<ExtArgs> = {}>(args?: Subset<T, airport$locationArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    flight_flight_airport_depart_idToairport<T extends airport$flight_flight_airport_depart_idToairportArgs<ExtArgs> = {}>(args?: Subset<T, airport$flight_flight_airport_depart_idToairportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flight_flight_airport_arrivee_idToairport<T extends airport$flight_flight_airport_arrivee_idToairportArgs<ExtArgs> = {}>(args?: Subset<T, airport$flight_flight_airport_arrivee_idToairportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the airport model
   */
  interface airportFieldRefs {
    readonly id: FieldRef<"airport", 'String'>
    readonly nom: FieldRef<"airport", 'String'>
    readonly code: FieldRef<"airport", 'String'>
    readonly pays: FieldRef<"airport", 'String'>
    readonly description: FieldRef<"airport", 'String'>
    readonly est_actif: FieldRef<"airport", 'Int'>
    readonly location_id: FieldRef<"airport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * airport findUnique
   */
  export type airportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport findUniqueOrThrow
   */
  export type airportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport findFirst
   */
  export type airportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     */
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * airport findFirstOrThrow
   */
  export type airportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     */
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * airport findMany
   */
  export type airportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airports to fetch.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airports.
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * airport create
   */
  export type airportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * The data needed to create a airport.
     */
    data: XOR<airportCreateInput, airportUncheckedCreateInput>
  }

  /**
   * airport createMany
   */
  export type airportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many airports.
     */
    data: airportCreateManyInput | airportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * airport update
   */
  export type airportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * The data needed to update a airport.
     */
    data: XOR<airportUpdateInput, airportUncheckedUpdateInput>
    /**
     * Choose, which airport to update.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport updateMany
   */
  export type airportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update airports.
     */
    data: XOR<airportUpdateManyMutationInput, airportUncheckedUpdateManyInput>
    /**
     * Filter which airports to update
     */
    where?: airportWhereInput
    /**
     * Limit how many airports to update.
     */
    limit?: number
  }

  /**
   * airport upsert
   */
  export type airportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * The filter to search for the airport to update in case it exists.
     */
    where: airportWhereUniqueInput
    /**
     * In case the airport found by the `where` argument doesn't exist, create a new airport with this data.
     */
    create: XOR<airportCreateInput, airportUncheckedCreateInput>
    /**
     * In case the airport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<airportUpdateInput, airportUncheckedUpdateInput>
  }

  /**
   * airport delete
   */
  export type airportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter which airport to delete.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport deleteMany
   */
  export type airportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which airports to delete
     */
    where?: airportWhereInput
    /**
     * Limit how many airports to delete.
     */
    limit?: number
  }

  /**
   * airport.location
   */
  export type airport$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    where?: locationWhereInput
  }

  /**
   * airport.flight_flight_airport_depart_idToairport
   */
  export type airport$flight_flight_airport_depart_idToairportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    cursor?: flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * airport.flight_flight_airport_arrivee_idToairport
   */
  export type airport$flight_flight_airport_arrivee_idToairportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    cursor?: flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * airport without action
   */
  export type airportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
  }


  /**
   * Model compte
   */

  export type AggregateCompte = {
    _count: CompteCountAggregateOutputType | null
    _avg: CompteAvgAggregateOutputType | null
    _sum: CompteSumAggregateOutputType | null
    _min: CompteMinAggregateOutputType | null
    _max: CompteMaxAggregateOutputType | null
  }

  export type CompteAvgAggregateOutputType = {
    solde: Decimal | null
  }

  export type CompteSumAggregateOutputType = {
    solde: Decimal | null
  }

  export type CompteMinAggregateOutputType = {
    id: string | null
    solde: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
  }

  export type CompteMaxAggregateOutputType = {
    id: string | null
    solde: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
  }

  export type CompteCountAggregateOutputType = {
    id: number
    solde: number
    created_at: number
    updated_at: number
    user_id: number
    _all: number
  }


  export type CompteAvgAggregateInputType = {
    solde?: true
  }

  export type CompteSumAggregateInputType = {
    solde?: true
  }

  export type CompteMinAggregateInputType = {
    id?: true
    solde?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type CompteMaxAggregateInputType = {
    id?: true
    solde?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type CompteCountAggregateInputType = {
    id?: true
    solde?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    _all?: true
  }

  export type CompteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compte to aggregate.
     */
    where?: compteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: compteOrderByWithRelationInput | compteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: compteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comptes
    **/
    _count?: true | CompteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompteMaxAggregateInputType
  }

  export type GetCompteAggregateType<T extends CompteAggregateArgs> = {
        [P in keyof T & keyof AggregateCompte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompte[P]>
      : GetScalarType<T[P], AggregateCompte[P]>
  }




  export type compteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: compteWhereInput
    orderBy?: compteOrderByWithAggregationInput | compteOrderByWithAggregationInput[]
    by: CompteScalarFieldEnum[] | CompteScalarFieldEnum
    having?: compteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompteCountAggregateInputType | true
    _avg?: CompteAvgAggregateInputType
    _sum?: CompteSumAggregateInputType
    _min?: CompteMinAggregateInputType
    _max?: CompteMaxAggregateInputType
  }

  export type CompteGroupByOutputType = {
    id: string
    solde: Decimal
    created_at: Date
    updated_at: Date
    user_id: string | null
    _count: CompteCountAggregateOutputType | null
    _avg: CompteAvgAggregateOutputType | null
    _sum: CompteSumAggregateOutputType | null
    _min: CompteMinAggregateOutputType | null
    _max: CompteMaxAggregateOutputType | null
  }

  type GetCompteGroupByPayload<T extends compteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompteGroupByOutputType[P]>
            : GetScalarType<T[P], CompteGroupByOutputType[P]>
        }
      >
    >


  export type compteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solde?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | compte$userArgs<ExtArgs>
  }, ExtArgs["result"]["compte"]>



  export type compteSelectScalar = {
    id?: boolean
    solde?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
  }

  export type compteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "solde" | "created_at" | "updated_at" | "user_id", ExtArgs["result"]["compte"]>
  export type compteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | compte$userArgs<ExtArgs>
  }

  export type $comptePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compte"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      solde: Prisma.Decimal
      created_at: Date
      updated_at: Date
      user_id: string | null
    }, ExtArgs["result"]["compte"]>
    composites: {}
  }

  type compteGetPayload<S extends boolean | null | undefined | compteDefaultArgs> = $Result.GetResult<Prisma.$comptePayload, S>

  type compteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<compteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompteCountAggregateInputType | true
    }

  export interface compteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compte'], meta: { name: 'compte' } }
    /**
     * Find zero or one Compte that matches the filter.
     * @param {compteFindUniqueArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends compteFindUniqueArgs>(args: SelectSubset<T, compteFindUniqueArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compte that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {compteFindUniqueOrThrowArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends compteFindUniqueOrThrowArgs>(args: SelectSubset<T, compteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compteFindFirstArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends compteFindFirstArgs>(args?: SelectSubset<T, compteFindFirstArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compteFindFirstOrThrowArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends compteFindFirstOrThrowArgs>(args?: SelectSubset<T, compteFindFirstOrThrowArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comptes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comptes
     * const comptes = await prisma.compte.findMany()
     * 
     * // Get first 10 Comptes
     * const comptes = await prisma.compte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const compteWithIdOnly = await prisma.compte.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends compteFindManyArgs>(args?: SelectSubset<T, compteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compte.
     * @param {compteCreateArgs} args - Arguments to create a Compte.
     * @example
     * // Create one Compte
     * const Compte = await prisma.compte.create({
     *   data: {
     *     // ... data to create a Compte
     *   }
     * })
     * 
     */
    create<T extends compteCreateArgs>(args: SelectSubset<T, compteCreateArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comptes.
     * @param {compteCreateManyArgs} args - Arguments to create many Comptes.
     * @example
     * // Create many Comptes
     * const compte = await prisma.compte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends compteCreateManyArgs>(args?: SelectSubset<T, compteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compte.
     * @param {compteDeleteArgs} args - Arguments to delete one Compte.
     * @example
     * // Delete one Compte
     * const Compte = await prisma.compte.delete({
     *   where: {
     *     // ... filter to delete one Compte
     *   }
     * })
     * 
     */
    delete<T extends compteDeleteArgs>(args: SelectSubset<T, compteDeleteArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compte.
     * @param {compteUpdateArgs} args - Arguments to update one Compte.
     * @example
     * // Update one Compte
     * const compte = await prisma.compte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends compteUpdateArgs>(args: SelectSubset<T, compteUpdateArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comptes.
     * @param {compteDeleteManyArgs} args - Arguments to filter Comptes to delete.
     * @example
     * // Delete a few Comptes
     * const { count } = await prisma.compte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends compteDeleteManyArgs>(args?: SelectSubset<T, compteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comptes
     * const compte = await prisma.compte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends compteUpdateManyArgs>(args: SelectSubset<T, compteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compte.
     * @param {compteUpsertArgs} args - Arguments to update or create a Compte.
     * @example
     * // Update or create a Compte
     * const compte = await prisma.compte.upsert({
     *   create: {
     *     // ... data to create a Compte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compte we want to update
     *   }
     * })
     */
    upsert<T extends compteUpsertArgs>(args: SelectSubset<T, compteUpsertArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compteCountArgs} args - Arguments to filter Comptes to count.
     * @example
     * // Count the number of Comptes
     * const count = await prisma.compte.count({
     *   where: {
     *     // ... the filter for the Comptes we want to count
     *   }
     * })
    **/
    count<T extends compteCountArgs>(
      args?: Subset<T, compteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompteAggregateArgs>(args: Subset<T, CompteAggregateArgs>): Prisma.PrismaPromise<GetCompteAggregateType<T>>

    /**
     * Group by Compte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends compteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: compteGroupByArgs['orderBy'] }
        : { orderBy?: compteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, compteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compte model
   */
  readonly fields: compteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__compteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends compte$userArgs<ExtArgs> = {}>(args?: Subset<T, compte$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the compte model
   */
  interface compteFieldRefs {
    readonly id: FieldRef<"compte", 'String'>
    readonly solde: FieldRef<"compte", 'Decimal'>
    readonly created_at: FieldRef<"compte", 'DateTime'>
    readonly updated_at: FieldRef<"compte", 'DateTime'>
    readonly user_id: FieldRef<"compte", 'String'>
  }
    

  // Custom InputTypes
  /**
   * compte findUnique
   */
  export type compteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * Filter, which compte to fetch.
     */
    where: compteWhereUniqueInput
  }

  /**
   * compte findUniqueOrThrow
   */
  export type compteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * Filter, which compte to fetch.
     */
    where: compteWhereUniqueInput
  }

  /**
   * compte findFirst
   */
  export type compteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * Filter, which compte to fetch.
     */
    where?: compteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: compteOrderByWithRelationInput | compteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comptes.
     */
    cursor?: compteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comptes.
     */
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * compte findFirstOrThrow
   */
  export type compteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * Filter, which compte to fetch.
     */
    where?: compteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: compteOrderByWithRelationInput | compteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comptes.
     */
    cursor?: compteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comptes.
     */
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * compte findMany
   */
  export type compteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * Filter, which comptes to fetch.
     */
    where?: compteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: compteOrderByWithRelationInput | compteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comptes.
     */
    cursor?: compteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * compte create
   */
  export type compteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * The data needed to create a compte.
     */
    data: XOR<compteCreateInput, compteUncheckedCreateInput>
  }

  /**
   * compte createMany
   */
  export type compteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comptes.
     */
    data: compteCreateManyInput | compteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * compte update
   */
  export type compteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * The data needed to update a compte.
     */
    data: XOR<compteUpdateInput, compteUncheckedUpdateInput>
    /**
     * Choose, which compte to update.
     */
    where: compteWhereUniqueInput
  }

  /**
   * compte updateMany
   */
  export type compteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comptes.
     */
    data: XOR<compteUpdateManyMutationInput, compteUncheckedUpdateManyInput>
    /**
     * Filter which comptes to update
     */
    where?: compteWhereInput
    /**
     * Limit how many comptes to update.
     */
    limit?: number
  }

  /**
   * compte upsert
   */
  export type compteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * The filter to search for the compte to update in case it exists.
     */
    where: compteWhereUniqueInput
    /**
     * In case the compte found by the `where` argument doesn't exist, create a new compte with this data.
     */
    create: XOR<compteCreateInput, compteUncheckedCreateInput>
    /**
     * In case the compte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<compteUpdateInput, compteUncheckedUpdateInput>
  }

  /**
   * compte delete
   */
  export type compteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    /**
     * Filter which compte to delete.
     */
    where: compteWhereUniqueInput
  }

  /**
   * compte deleteMany
   */
  export type compteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comptes to delete
     */
    where?: compteWhereInput
    /**
     * Limit how many comptes to delete.
     */
    limit?: number
  }

  /**
   * compte.user
   */
  export type compte$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * compte without action
   */
  export type compteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
  }


  /**
   * Model contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    guaranteedMinimum: Decimal | null
    isActive: number | null
    modifiedFeeAmount: Decimal | null
    payLater: number | null
    payLaterTimeLimit: number | null
    minTimeBeforeBalanceFlight: number | null
    invoiceStamp: Decimal | null
    finalClientAdditionalFees: Decimal | null
    fixedTicketPrice: Decimal | null
  }

  export type ContractSumAggregateOutputType = {
    guaranteedMinimum: Decimal | null
    isActive: number | null
    modifiedFeeAmount: Decimal | null
    payLater: number | null
    payLaterTimeLimit: number | null
    minTimeBeforeBalanceFlight: number | null
    invoiceStamp: Decimal | null
    finalClientAdditionalFees: Decimal | null
    fixedTicketPrice: Decimal | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    clientType: string | null
    label: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    guaranteedMinimum: Decimal | null
    travelStartDate: Date | null
    travelEndDate: Date | null
    isActive: number | null
    modifiedFeeAmount: Decimal | null
    payLater: number | null
    payLaterTimeLimit: number | null
    minTimeBeforeBalanceFlight: number | null
    invoiceStamp: Decimal | null
    finalClientAdditionalFees: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    client_id: string | null
    fixedTicketPrice: Decimal | null
    coupon_id: string | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    clientType: string | null
    label: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    guaranteedMinimum: Decimal | null
    travelStartDate: Date | null
    travelEndDate: Date | null
    isActive: number | null
    modifiedFeeAmount: Decimal | null
    payLater: number | null
    payLaterTimeLimit: number | null
    minTimeBeforeBalanceFlight: number | null
    invoiceStamp: Decimal | null
    finalClientAdditionalFees: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    client_id: string | null
    fixedTicketPrice: Decimal | null
    coupon_id: string | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    clientType: number
    label: number
    contractStartDate: number
    contractEndDate: number
    guaranteedMinimum: number
    travelStartDate: number
    travelEndDate: number
    isActive: number
    modifiedFeeAmount: number
    payLater: number
    payLaterTimeLimit: number
    minTimeBeforeBalanceFlight: number
    invoiceStamp: number
    finalClientAdditionalFees: number
    createdAt: number
    updatedAt: number
    client_id: number
    fixedTicketPrice: number
    coupon_id: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    guaranteedMinimum?: true
    isActive?: true
    modifiedFeeAmount?: true
    payLater?: true
    payLaterTimeLimit?: true
    minTimeBeforeBalanceFlight?: true
    invoiceStamp?: true
    finalClientAdditionalFees?: true
    fixedTicketPrice?: true
  }

  export type ContractSumAggregateInputType = {
    guaranteedMinimum?: true
    isActive?: true
    modifiedFeeAmount?: true
    payLater?: true
    payLaterTimeLimit?: true
    minTimeBeforeBalanceFlight?: true
    invoiceStamp?: true
    finalClientAdditionalFees?: true
    fixedTicketPrice?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    clientType?: true
    label?: true
    contractStartDate?: true
    contractEndDate?: true
    guaranteedMinimum?: true
    travelStartDate?: true
    travelEndDate?: true
    isActive?: true
    modifiedFeeAmount?: true
    payLater?: true
    payLaterTimeLimit?: true
    minTimeBeforeBalanceFlight?: true
    invoiceStamp?: true
    finalClientAdditionalFees?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
    fixedTicketPrice?: true
    coupon_id?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    clientType?: true
    label?: true
    contractStartDate?: true
    contractEndDate?: true
    guaranteedMinimum?: true
    travelStartDate?: true
    travelEndDate?: true
    isActive?: true
    modifiedFeeAmount?: true
    payLater?: true
    payLaterTimeLimit?: true
    minTimeBeforeBalanceFlight?: true
    invoiceStamp?: true
    finalClientAdditionalFees?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
    fixedTicketPrice?: true
    coupon_id?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    clientType?: true
    label?: true
    contractStartDate?: true
    contractEndDate?: true
    guaranteedMinimum?: true
    travelStartDate?: true
    travelEndDate?: true
    isActive?: true
    modifiedFeeAmount?: true
    payLater?: true
    payLaterTimeLimit?: true
    minTimeBeforeBalanceFlight?: true
    invoiceStamp?: true
    finalClientAdditionalFees?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
    fixedTicketPrice?: true
    coupon_id?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contract to aggregate.
     */
    where?: contractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contracts to fetch.
     */
    orderBy?: contractOrderByWithRelationInput | contractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type contractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contractWhereInput
    orderBy?: contractOrderByWithAggregationInput | contractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: contractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date
    contractEndDate: Date
    guaranteedMinimum: Decimal
    travelStartDate: Date
    travelEndDate: Date
    isActive: number
    modifiedFeeAmount: Decimal | null
    payLater: number
    payLaterTimeLimit: number | null
    minTimeBeforeBalanceFlight: number | null
    invoiceStamp: Decimal | null
    finalClientAdditionalFees: Decimal | null
    createdAt: Date
    updatedAt: Date
    client_id: string | null
    fixedTicketPrice: Decimal | null
    coupon_id: string | null
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends contractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type contractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientType?: boolean
    label?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    guaranteedMinimum?: boolean
    travelStartDate?: boolean
    travelEndDate?: boolean
    isActive?: boolean
    modifiedFeeAmount?: boolean
    payLater?: boolean
    payLaterTimeLimit?: boolean
    minTimeBeforeBalanceFlight?: boolean
    invoiceStamp?: boolean
    finalClientAdditionalFees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
    fixedTicketPrice?: boolean
    coupon_id?: boolean
    user?: boolean | contract$userArgs<ExtArgs>
    coupon?: boolean | contract$couponArgs<ExtArgs>
    contract_coupons?: boolean | contract$contract_couponsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>



  export type contractSelectScalar = {
    id?: boolean
    clientType?: boolean
    label?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    guaranteedMinimum?: boolean
    travelStartDate?: boolean
    travelEndDate?: boolean
    isActive?: boolean
    modifiedFeeAmount?: boolean
    payLater?: boolean
    payLaterTimeLimit?: boolean
    minTimeBeforeBalanceFlight?: boolean
    invoiceStamp?: boolean
    finalClientAdditionalFees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
    fixedTicketPrice?: boolean
    coupon_id?: boolean
  }

  export type contractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientType" | "label" | "contractStartDate" | "contractEndDate" | "guaranteedMinimum" | "travelStartDate" | "travelEndDate" | "isActive" | "modifiedFeeAmount" | "payLater" | "payLaterTimeLimit" | "minTimeBeforeBalanceFlight" | "invoiceStamp" | "finalClientAdditionalFees" | "createdAt" | "updatedAt" | "client_id" | "fixedTicketPrice" | "coupon_id", ExtArgs["result"]["contract"]>
  export type contractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | contract$userArgs<ExtArgs>
    coupon?: boolean | contract$couponArgs<ExtArgs>
    contract_coupons?: boolean | contract$contract_couponsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $contractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contract"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      coupon: Prisma.$couponPayload<ExtArgs> | null
      contract_coupons: Prisma.$contract_couponsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientType: string
      label: string
      contractStartDate: Date
      contractEndDate: Date
      guaranteedMinimum: Prisma.Decimal
      travelStartDate: Date
      travelEndDate: Date
      isActive: number
      modifiedFeeAmount: Prisma.Decimal | null
      payLater: number
      payLaterTimeLimit: number | null
      minTimeBeforeBalanceFlight: number | null
      invoiceStamp: Prisma.Decimal | null
      finalClientAdditionalFees: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
      client_id: string | null
      fixedTicketPrice: Prisma.Decimal | null
      coupon_id: string | null
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type contractGetPayload<S extends boolean | null | undefined | contractDefaultArgs> = $Result.GetResult<Prisma.$contractPayload, S>

  type contractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface contractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contract'], meta: { name: 'contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {contractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contractFindUniqueArgs>(args: SelectSubset<T, contractFindUniqueArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contractFindUniqueOrThrowArgs>(args: SelectSubset<T, contractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contractFindFirstArgs>(args?: SelectSubset<T, contractFindFirstArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contractFindFirstOrThrowArgs>(args?: SelectSubset<T, contractFindFirstOrThrowArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contractFindManyArgs>(args?: SelectSubset<T, contractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {contractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends contractCreateArgs>(args: SelectSubset<T, contractCreateArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {contractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contractCreateManyArgs>(args?: SelectSubset<T, contractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contract.
     * @param {contractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends contractDeleteArgs>(args: SelectSubset<T, contractDeleteArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {contractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contractUpdateArgs>(args: SelectSubset<T, contractUpdateArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {contractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contractDeleteManyArgs>(args?: SelectSubset<T, contractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contractUpdateManyArgs>(args: SelectSubset<T, contractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {contractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends contractUpsertArgs>(args: SelectSubset<T, contractUpsertArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends contractCountArgs>(
      args?: Subset<T, contractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contractGroupByArgs['orderBy'] }
        : { orderBy?: contractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contract model
   */
  readonly fields: contractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends contract$userArgs<ExtArgs> = {}>(args?: Subset<T, contract$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coupon<T extends contract$couponArgs<ExtArgs> = {}>(args?: Subset<T, contract$couponArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contract_coupons<T extends contract$contract_couponsArgs<ExtArgs> = {}>(args?: Subset<T, contract$contract_couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contract model
   */
  interface contractFieldRefs {
    readonly id: FieldRef<"contract", 'String'>
    readonly clientType: FieldRef<"contract", 'String'>
    readonly label: FieldRef<"contract", 'String'>
    readonly contractStartDate: FieldRef<"contract", 'DateTime'>
    readonly contractEndDate: FieldRef<"contract", 'DateTime'>
    readonly guaranteedMinimum: FieldRef<"contract", 'Decimal'>
    readonly travelStartDate: FieldRef<"contract", 'DateTime'>
    readonly travelEndDate: FieldRef<"contract", 'DateTime'>
    readonly isActive: FieldRef<"contract", 'Int'>
    readonly modifiedFeeAmount: FieldRef<"contract", 'Decimal'>
    readonly payLater: FieldRef<"contract", 'Int'>
    readonly payLaterTimeLimit: FieldRef<"contract", 'Int'>
    readonly minTimeBeforeBalanceFlight: FieldRef<"contract", 'Int'>
    readonly invoiceStamp: FieldRef<"contract", 'Decimal'>
    readonly finalClientAdditionalFees: FieldRef<"contract", 'Decimal'>
    readonly createdAt: FieldRef<"contract", 'DateTime'>
    readonly updatedAt: FieldRef<"contract", 'DateTime'>
    readonly client_id: FieldRef<"contract", 'String'>
    readonly fixedTicketPrice: FieldRef<"contract", 'Decimal'>
    readonly coupon_id: FieldRef<"contract", 'String'>
  }
    

  // Custom InputTypes
  /**
   * contract findUnique
   */
  export type contractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * Filter, which contract to fetch.
     */
    where: contractWhereUniqueInput
  }

  /**
   * contract findUniqueOrThrow
   */
  export type contractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * Filter, which contract to fetch.
     */
    where: contractWhereUniqueInput
  }

  /**
   * contract findFirst
   */
  export type contractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * Filter, which contract to fetch.
     */
    where?: contractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contracts to fetch.
     */
    orderBy?: contractOrderByWithRelationInput | contractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contracts.
     */
    cursor?: contractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * contract findFirstOrThrow
   */
  export type contractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * Filter, which contract to fetch.
     */
    where?: contractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contracts to fetch.
     */
    orderBy?: contractOrderByWithRelationInput | contractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contracts.
     */
    cursor?: contractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * contract findMany
   */
  export type contractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * Filter, which contracts to fetch.
     */
    where?: contractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contracts to fetch.
     */
    orderBy?: contractOrderByWithRelationInput | contractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contracts.
     */
    cursor?: contractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * contract create
   */
  export type contractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * The data needed to create a contract.
     */
    data: XOR<contractCreateInput, contractUncheckedCreateInput>
  }

  /**
   * contract createMany
   */
  export type contractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contracts.
     */
    data: contractCreateManyInput | contractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contract update
   */
  export type contractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * The data needed to update a contract.
     */
    data: XOR<contractUpdateInput, contractUncheckedUpdateInput>
    /**
     * Choose, which contract to update.
     */
    where: contractWhereUniqueInput
  }

  /**
   * contract updateMany
   */
  export type contractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contracts.
     */
    data: XOR<contractUpdateManyMutationInput, contractUncheckedUpdateManyInput>
    /**
     * Filter which contracts to update
     */
    where?: contractWhereInput
    /**
     * Limit how many contracts to update.
     */
    limit?: number
  }

  /**
   * contract upsert
   */
  export type contractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * The filter to search for the contract to update in case it exists.
     */
    where: contractWhereUniqueInput
    /**
     * In case the contract found by the `where` argument doesn't exist, create a new contract with this data.
     */
    create: XOR<contractCreateInput, contractUncheckedCreateInput>
    /**
     * In case the contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contractUpdateInput, contractUncheckedUpdateInput>
  }

  /**
   * contract delete
   */
  export type contractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    /**
     * Filter which contract to delete.
     */
    where: contractWhereUniqueInput
  }

  /**
   * contract deleteMany
   */
  export type contractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contracts to delete
     */
    where?: contractWhereInput
    /**
     * Limit how many contracts to delete.
     */
    limit?: number
  }

  /**
   * contract.user
   */
  export type contract$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * contract.coupon
   */
  export type contract$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    where?: couponWhereInput
  }

  /**
   * contract.contract_coupons
   */
  export type contract$contract_couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    where?: contract_couponsWhereInput
    orderBy?: contract_couponsOrderByWithRelationInput | contract_couponsOrderByWithRelationInput[]
    cursor?: contract_couponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Contract_couponsScalarFieldEnum | Contract_couponsScalarFieldEnum[]
  }

  /**
   * contract without action
   */
  export type contractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
  }


  /**
   * Model contract_coupons
   */

  export type AggregateContract_coupons = {
    _count: Contract_couponsCountAggregateOutputType | null
    _min: Contract_couponsMinAggregateOutputType | null
    _max: Contract_couponsMaxAggregateOutputType | null
  }

  export type Contract_couponsMinAggregateOutputType = {
    contract_id: string | null
    coupon_id: string | null
  }

  export type Contract_couponsMaxAggregateOutputType = {
    contract_id: string | null
    coupon_id: string | null
  }

  export type Contract_couponsCountAggregateOutputType = {
    contract_id: number
    coupon_id: number
    _all: number
  }


  export type Contract_couponsMinAggregateInputType = {
    contract_id?: true
    coupon_id?: true
  }

  export type Contract_couponsMaxAggregateInputType = {
    contract_id?: true
    coupon_id?: true
  }

  export type Contract_couponsCountAggregateInputType = {
    contract_id?: true
    coupon_id?: true
    _all?: true
  }

  export type Contract_couponsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contract_coupons to aggregate.
     */
    where?: contract_couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contract_coupons to fetch.
     */
    orderBy?: contract_couponsOrderByWithRelationInput | contract_couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contract_couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contract_coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contract_coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contract_coupons
    **/
    _count?: true | Contract_couponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contract_couponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contract_couponsMaxAggregateInputType
  }

  export type GetContract_couponsAggregateType<T extends Contract_couponsAggregateArgs> = {
        [P in keyof T & keyof AggregateContract_coupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract_coupons[P]>
      : GetScalarType<T[P], AggregateContract_coupons[P]>
  }




  export type contract_couponsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contract_couponsWhereInput
    orderBy?: contract_couponsOrderByWithAggregationInput | contract_couponsOrderByWithAggregationInput[]
    by: Contract_couponsScalarFieldEnum[] | Contract_couponsScalarFieldEnum
    having?: contract_couponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contract_couponsCountAggregateInputType | true
    _min?: Contract_couponsMinAggregateInputType
    _max?: Contract_couponsMaxAggregateInputType
  }

  export type Contract_couponsGroupByOutputType = {
    contract_id: string
    coupon_id: string
    _count: Contract_couponsCountAggregateOutputType | null
    _min: Contract_couponsMinAggregateOutputType | null
    _max: Contract_couponsMaxAggregateOutputType | null
  }

  type GetContract_couponsGroupByPayload<T extends contract_couponsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contract_couponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contract_couponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contract_couponsGroupByOutputType[P]>
            : GetScalarType<T[P], Contract_couponsGroupByOutputType[P]>
        }
      >
    >


  export type contract_couponsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contract_id?: boolean
    coupon_id?: boolean
    contract?: boolean | contractDefaultArgs<ExtArgs>
    coupon?: boolean | couponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract_coupons"]>



  export type contract_couponsSelectScalar = {
    contract_id?: boolean
    coupon_id?: boolean
  }

  export type contract_couponsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contract_id" | "coupon_id", ExtArgs["result"]["contract_coupons"]>
  export type contract_couponsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | contractDefaultArgs<ExtArgs>
    coupon?: boolean | couponDefaultArgs<ExtArgs>
  }

  export type $contract_couponsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contract_coupons"
    objects: {
      contract: Prisma.$contractPayload<ExtArgs>
      coupon: Prisma.$couponPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contract_id: string
      coupon_id: string
    }, ExtArgs["result"]["contract_coupons"]>
    composites: {}
  }

  type contract_couponsGetPayload<S extends boolean | null | undefined | contract_couponsDefaultArgs> = $Result.GetResult<Prisma.$contract_couponsPayload, S>

  type contract_couponsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contract_couponsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contract_couponsCountAggregateInputType | true
    }

  export interface contract_couponsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contract_coupons'], meta: { name: 'contract_coupons' } }
    /**
     * Find zero or one Contract_coupons that matches the filter.
     * @param {contract_couponsFindUniqueArgs} args - Arguments to find a Contract_coupons
     * @example
     * // Get one Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contract_couponsFindUniqueArgs>(args: SelectSubset<T, contract_couponsFindUniqueArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract_coupons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contract_couponsFindUniqueOrThrowArgs} args - Arguments to find a Contract_coupons
     * @example
     * // Get one Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contract_couponsFindUniqueOrThrowArgs>(args: SelectSubset<T, contract_couponsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract_coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contract_couponsFindFirstArgs} args - Arguments to find a Contract_coupons
     * @example
     * // Get one Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contract_couponsFindFirstArgs>(args?: SelectSubset<T, contract_couponsFindFirstArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract_coupons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contract_couponsFindFirstOrThrowArgs} args - Arguments to find a Contract_coupons
     * @example
     * // Get one Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contract_couponsFindFirstOrThrowArgs>(args?: SelectSubset<T, contract_couponsFindFirstOrThrowArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contract_coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contract_couponsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.findMany()
     * 
     * // Get first 10 Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.findMany({ take: 10 })
     * 
     * // Only select the `contract_id`
     * const contract_couponsWithContract_idOnly = await prisma.contract_coupons.findMany({ select: { contract_id: true } })
     * 
     */
    findMany<T extends contract_couponsFindManyArgs>(args?: SelectSubset<T, contract_couponsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract_coupons.
     * @param {contract_couponsCreateArgs} args - Arguments to create a Contract_coupons.
     * @example
     * // Create one Contract_coupons
     * const Contract_coupons = await prisma.contract_coupons.create({
     *   data: {
     *     // ... data to create a Contract_coupons
     *   }
     * })
     * 
     */
    create<T extends contract_couponsCreateArgs>(args: SelectSubset<T, contract_couponsCreateArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contract_coupons.
     * @param {contract_couponsCreateManyArgs} args - Arguments to create many Contract_coupons.
     * @example
     * // Create many Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contract_couponsCreateManyArgs>(args?: SelectSubset<T, contract_couponsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contract_coupons.
     * @param {contract_couponsDeleteArgs} args - Arguments to delete one Contract_coupons.
     * @example
     * // Delete one Contract_coupons
     * const Contract_coupons = await prisma.contract_coupons.delete({
     *   where: {
     *     // ... filter to delete one Contract_coupons
     *   }
     * })
     * 
     */
    delete<T extends contract_couponsDeleteArgs>(args: SelectSubset<T, contract_couponsDeleteArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract_coupons.
     * @param {contract_couponsUpdateArgs} args - Arguments to update one Contract_coupons.
     * @example
     * // Update one Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contract_couponsUpdateArgs>(args: SelectSubset<T, contract_couponsUpdateArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contract_coupons.
     * @param {contract_couponsDeleteManyArgs} args - Arguments to filter Contract_coupons to delete.
     * @example
     * // Delete a few Contract_coupons
     * const { count } = await prisma.contract_coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contract_couponsDeleteManyArgs>(args?: SelectSubset<T, contract_couponsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contract_coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contract_couponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contract_couponsUpdateManyArgs>(args: SelectSubset<T, contract_couponsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract_coupons.
     * @param {contract_couponsUpsertArgs} args - Arguments to update or create a Contract_coupons.
     * @example
     * // Update or create a Contract_coupons
     * const contract_coupons = await prisma.contract_coupons.upsert({
     *   create: {
     *     // ... data to create a Contract_coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract_coupons we want to update
     *   }
     * })
     */
    upsert<T extends contract_couponsUpsertArgs>(args: SelectSubset<T, contract_couponsUpsertArgs<ExtArgs>>): Prisma__contract_couponsClient<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contract_coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contract_couponsCountArgs} args - Arguments to filter Contract_coupons to count.
     * @example
     * // Count the number of Contract_coupons
     * const count = await prisma.contract_coupons.count({
     *   where: {
     *     // ... the filter for the Contract_coupons we want to count
     *   }
     * })
    **/
    count<T extends contract_couponsCountArgs>(
      args?: Subset<T, contract_couponsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contract_couponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract_coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contract_couponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contract_couponsAggregateArgs>(args: Subset<T, Contract_couponsAggregateArgs>): Prisma.PrismaPromise<GetContract_couponsAggregateType<T>>

    /**
     * Group by Contract_coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contract_couponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contract_couponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contract_couponsGroupByArgs['orderBy'] }
        : { orderBy?: contract_couponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contract_couponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContract_couponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contract_coupons model
   */
  readonly fields: contract_couponsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contract_coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contract_couponsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends contractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contractDefaultArgs<ExtArgs>>): Prisma__contractClient<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coupon<T extends couponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, couponDefaultArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contract_coupons model
   */
  interface contract_couponsFieldRefs {
    readonly contract_id: FieldRef<"contract_coupons", 'String'>
    readonly coupon_id: FieldRef<"contract_coupons", 'String'>
  }
    

  // Custom InputTypes
  /**
   * contract_coupons findUnique
   */
  export type contract_couponsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * Filter, which contract_coupons to fetch.
     */
    where: contract_couponsWhereUniqueInput
  }

  /**
   * contract_coupons findUniqueOrThrow
   */
  export type contract_couponsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * Filter, which contract_coupons to fetch.
     */
    where: contract_couponsWhereUniqueInput
  }

  /**
   * contract_coupons findFirst
   */
  export type contract_couponsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * Filter, which contract_coupons to fetch.
     */
    where?: contract_couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contract_coupons to fetch.
     */
    orderBy?: contract_couponsOrderByWithRelationInput | contract_couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contract_coupons.
     */
    cursor?: contract_couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contract_coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contract_coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contract_coupons.
     */
    distinct?: Contract_couponsScalarFieldEnum | Contract_couponsScalarFieldEnum[]
  }

  /**
   * contract_coupons findFirstOrThrow
   */
  export type contract_couponsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * Filter, which contract_coupons to fetch.
     */
    where?: contract_couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contract_coupons to fetch.
     */
    orderBy?: contract_couponsOrderByWithRelationInput | contract_couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contract_coupons.
     */
    cursor?: contract_couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contract_coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contract_coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contract_coupons.
     */
    distinct?: Contract_couponsScalarFieldEnum | Contract_couponsScalarFieldEnum[]
  }

  /**
   * contract_coupons findMany
   */
  export type contract_couponsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * Filter, which contract_coupons to fetch.
     */
    where?: contract_couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contract_coupons to fetch.
     */
    orderBy?: contract_couponsOrderByWithRelationInput | contract_couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contract_coupons.
     */
    cursor?: contract_couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contract_coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contract_coupons.
     */
    skip?: number
    distinct?: Contract_couponsScalarFieldEnum | Contract_couponsScalarFieldEnum[]
  }

  /**
   * contract_coupons create
   */
  export type contract_couponsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * The data needed to create a contract_coupons.
     */
    data: XOR<contract_couponsCreateInput, contract_couponsUncheckedCreateInput>
  }

  /**
   * contract_coupons createMany
   */
  export type contract_couponsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contract_coupons.
     */
    data: contract_couponsCreateManyInput | contract_couponsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contract_coupons update
   */
  export type contract_couponsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * The data needed to update a contract_coupons.
     */
    data: XOR<contract_couponsUpdateInput, contract_couponsUncheckedUpdateInput>
    /**
     * Choose, which contract_coupons to update.
     */
    where: contract_couponsWhereUniqueInput
  }

  /**
   * contract_coupons updateMany
   */
  export type contract_couponsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contract_coupons.
     */
    data: XOR<contract_couponsUpdateManyMutationInput, contract_couponsUncheckedUpdateManyInput>
    /**
     * Filter which contract_coupons to update
     */
    where?: contract_couponsWhereInput
    /**
     * Limit how many contract_coupons to update.
     */
    limit?: number
  }

  /**
   * contract_coupons upsert
   */
  export type contract_couponsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * The filter to search for the contract_coupons to update in case it exists.
     */
    where: contract_couponsWhereUniqueInput
    /**
     * In case the contract_coupons found by the `where` argument doesn't exist, create a new contract_coupons with this data.
     */
    create: XOR<contract_couponsCreateInput, contract_couponsUncheckedCreateInput>
    /**
     * In case the contract_coupons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contract_couponsUpdateInput, contract_couponsUncheckedUpdateInput>
  }

  /**
   * contract_coupons delete
   */
  export type contract_couponsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    /**
     * Filter which contract_coupons to delete.
     */
    where: contract_couponsWhereUniqueInput
  }

  /**
   * contract_coupons deleteMany
   */
  export type contract_couponsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contract_coupons to delete
     */
    where?: contract_couponsWhereInput
    /**
     * Limit how many contract_coupons to delete.
     */
    limit?: number
  }

  /**
   * contract_coupons without action
   */
  export type contract_couponsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
  }


  /**
   * Model coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    reduction: Decimal | null
  }

  export type CouponSumAggregateOutputType = {
    reduction: Decimal | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    reduction: Decimal | null
    reduction_type: $Enums.coupon_reduction_type | null
    date_fin: Date | null
    date_creation: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    reduction: Decimal | null
    reduction_type: $Enums.coupon_reduction_type | null
    date_fin: Date | null
    date_creation: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    reduction: number
    reduction_type: number
    date_fin: number
    date_creation: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    reduction?: true
  }

  export type CouponSumAggregateInputType = {
    reduction?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    reduction?: true
    reduction_type?: true
    date_fin?: true
    date_creation?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    reduction?: true
    reduction_type?: true
    date_fin?: true
    date_creation?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    reduction?: true
    reduction_type?: true
    date_fin?: true
    date_creation?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupon to aggregate.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type couponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponWhereInput
    orderBy?: couponOrderByWithAggregationInput | couponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: couponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    reduction: Decimal
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date
    date_creation: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends couponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type couponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    reduction?: boolean
    reduction_type?: boolean
    date_fin?: boolean
    date_creation?: boolean
    contract?: boolean | coupon$contractArgs<ExtArgs>
    contract_coupons?: boolean | coupon$contract_couponsArgs<ExtArgs>
    reservation?: boolean | coupon$reservationArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>



  export type couponSelectScalar = {
    id?: boolean
    code?: boolean
    reduction?: boolean
    reduction_type?: boolean
    date_fin?: boolean
    date_creation?: boolean
  }

  export type couponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "reduction" | "reduction_type" | "date_fin" | "date_creation", ExtArgs["result"]["coupon"]>
  export type couponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | coupon$contractArgs<ExtArgs>
    contract_coupons?: boolean | coupon$contract_couponsArgs<ExtArgs>
    reservation?: boolean | coupon$reservationArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $couponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coupon"
    objects: {
      contract: Prisma.$contractPayload<ExtArgs>[]
      contract_coupons: Prisma.$contract_couponsPayload<ExtArgs>[]
      reservation: Prisma.$reservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      reduction: Prisma.Decimal
      reduction_type: $Enums.coupon_reduction_type
      date_fin: Date
      date_creation: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type couponGetPayload<S extends boolean | null | undefined | couponDefaultArgs> = $Result.GetResult<Prisma.$couponPayload, S>

  type couponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<couponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface couponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coupon'], meta: { name: 'coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {couponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends couponFindUniqueArgs>(args: SelectSubset<T, couponFindUniqueArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {couponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends couponFindUniqueOrThrowArgs>(args: SelectSubset<T, couponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends couponFindFirstArgs>(args?: SelectSubset<T, couponFindFirstArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends couponFindFirstOrThrowArgs>(args?: SelectSubset<T, couponFindFirstOrThrowArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends couponFindManyArgs>(args?: SelectSubset<T, couponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {couponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends couponCreateArgs>(args: SelectSubset<T, couponCreateArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {couponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends couponCreateManyArgs>(args?: SelectSubset<T, couponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coupon.
     * @param {couponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends couponDeleteArgs>(args: SelectSubset<T, couponDeleteArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {couponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends couponUpdateArgs>(args: SelectSubset<T, couponUpdateArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {couponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends couponDeleteManyArgs>(args?: SelectSubset<T, couponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends couponUpdateManyArgs>(args: SelectSubset<T, couponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {couponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends couponUpsertArgs>(args: SelectSubset<T, couponUpsertArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends couponCountArgs>(
      args?: Subset<T, couponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends couponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: couponGroupByArgs['orderBy'] }
        : { orderBy?: couponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, couponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coupon model
   */
  readonly fields: couponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__couponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends coupon$contractArgs<ExtArgs> = {}>(args?: Subset<T, coupon$contractArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contract_coupons<T extends coupon$contract_couponsArgs<ExtArgs> = {}>(args?: Subset<T, coupon$contract_couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contract_couponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservation<T extends coupon$reservationArgs<ExtArgs> = {}>(args?: Subset<T, coupon$reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coupon model
   */
  interface couponFieldRefs {
    readonly id: FieldRef<"coupon", 'String'>
    readonly code: FieldRef<"coupon", 'String'>
    readonly reduction: FieldRef<"coupon", 'Decimal'>
    readonly reduction_type: FieldRef<"coupon", 'coupon_reduction_type'>
    readonly date_fin: FieldRef<"coupon", 'DateTime'>
    readonly date_creation: FieldRef<"coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * coupon findUnique
   */
  export type couponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon findUniqueOrThrow
   */
  export type couponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon findFirst
   */
  export type couponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * coupon findFirstOrThrow
   */
  export type couponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * coupon findMany
   */
  export type couponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupons.
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * coupon create
   */
  export type couponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * The data needed to create a coupon.
     */
    data: XOR<couponCreateInput, couponUncheckedCreateInput>
  }

  /**
   * coupon createMany
   */
  export type couponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coupons.
     */
    data: couponCreateManyInput | couponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coupon update
   */
  export type couponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * The data needed to update a coupon.
     */
    data: XOR<couponUpdateInput, couponUncheckedUpdateInput>
    /**
     * Choose, which coupon to update.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon updateMany
   */
  export type couponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coupons.
     */
    data: XOR<couponUpdateManyMutationInput, couponUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
  }

  /**
   * coupon upsert
   */
  export type couponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * The filter to search for the coupon to update in case it exists.
     */
    where: couponWhereUniqueInput
    /**
     * In case the coupon found by the `where` argument doesn't exist, create a new coupon with this data.
     */
    create: XOR<couponCreateInput, couponUncheckedCreateInput>
    /**
     * In case the coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couponUpdateInput, couponUncheckedUpdateInput>
  }

  /**
   * coupon delete
   */
  export type couponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter which coupon to delete.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon deleteMany
   */
  export type couponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupons to delete
     */
    where?: couponWhereInput
    /**
     * Limit how many coupons to delete.
     */
    limit?: number
  }

  /**
   * coupon.contract
   */
  export type coupon$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    where?: contractWhereInput
    orderBy?: contractOrderByWithRelationInput | contractOrderByWithRelationInput[]
    cursor?: contractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * coupon.contract_coupons
   */
  export type coupon$contract_couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract_coupons
     */
    select?: contract_couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract_coupons
     */
    omit?: contract_couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contract_couponsInclude<ExtArgs> | null
    where?: contract_couponsWhereInput
    orderBy?: contract_couponsOrderByWithRelationInput | contract_couponsOrderByWithRelationInput[]
    cursor?: contract_couponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Contract_couponsScalarFieldEnum | Contract_couponsScalarFieldEnum[]
  }

  /**
   * coupon.reservation
   */
  export type coupon$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    where?: reservationWhereInput
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    cursor?: reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * coupon without action
   */
  export type couponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
  }


  /**
   * Model flight
   */

  export type AggregateFlight = {
    _count: FlightCountAggregateOutputType | null
    _avg: FlightAvgAggregateOutputType | null
    _sum: FlightSumAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  export type FlightAvgAggregateOutputType = {
    prix: Decimal | null
    plane_id: number | null
  }

  export type FlightSumAggregateOutputType = {
    prix: Decimal | null
    plane_id: number | null
  }

  export type FlightMinAggregateOutputType = {
    id: string | null
    titre: string | null
    prix: Decimal | null
    date_depart: Date | null
    date_retour: Date | null
    duree: string | null
    status: string | null
    airport_depart_id: string | null
    airport_arrivee_id: string | null
    plane_id: number | null
  }

  export type FlightMaxAggregateOutputType = {
    id: string | null
    titre: string | null
    prix: Decimal | null
    date_depart: Date | null
    date_retour: Date | null
    duree: string | null
    status: string | null
    airport_depart_id: string | null
    airport_arrivee_id: string | null
    plane_id: number | null
  }

  export type FlightCountAggregateOutputType = {
    id: number
    titre: number
    prix: number
    date_depart: number
    date_retour: number
    duree: number
    status: number
    airport_depart_id: number
    airport_arrivee_id: number
    plane_id: number
    _all: number
  }


  export type FlightAvgAggregateInputType = {
    prix?: true
    plane_id?: true
  }

  export type FlightSumAggregateInputType = {
    prix?: true
    plane_id?: true
  }

  export type FlightMinAggregateInputType = {
    id?: true
    titre?: true
    prix?: true
    date_depart?: true
    date_retour?: true
    duree?: true
    status?: true
    airport_depart_id?: true
    airport_arrivee_id?: true
    plane_id?: true
  }

  export type FlightMaxAggregateInputType = {
    id?: true
    titre?: true
    prix?: true
    date_depart?: true
    date_retour?: true
    duree?: true
    status?: true
    airport_depart_id?: true
    airport_arrivee_id?: true
    plane_id?: true
  }

  export type FlightCountAggregateInputType = {
    id?: true
    titre?: true
    prix?: true
    date_depart?: true
    date_retour?: true
    duree?: true
    status?: true
    airport_depart_id?: true
    airport_arrivee_id?: true
    plane_id?: true
    _all?: true
  }

  export type FlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flight to aggregate.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flights
    **/
    _count?: true | FlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightMaxAggregateInputType
  }

  export type GetFlightAggregateType<T extends FlightAggregateArgs> = {
        [P in keyof T & keyof AggregateFlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlight[P]>
      : GetScalarType<T[P], AggregateFlight[P]>
  }




  export type flightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
    orderBy?: flightOrderByWithAggregationInput | flightOrderByWithAggregationInput[]
    by: FlightScalarFieldEnum[] | FlightScalarFieldEnum
    having?: flightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightCountAggregateInputType | true
    _avg?: FlightAvgAggregateInputType
    _sum?: FlightSumAggregateInputType
    _min?: FlightMinAggregateInputType
    _max?: FlightMaxAggregateInputType
  }

  export type FlightGroupByOutputType = {
    id: string
    titre: string
    prix: Decimal
    date_depart: Date
    date_retour: Date
    duree: string | null
    status: string
    airport_depart_id: string | null
    airport_arrivee_id: string | null
    plane_id: number | null
    _count: FlightCountAggregateOutputType | null
    _avg: FlightAvgAggregateOutputType | null
    _sum: FlightSumAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  type GetFlightGroupByPayload<T extends flightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightGroupByOutputType[P]>
            : GetScalarType<T[P], FlightGroupByOutputType[P]>
        }
      >
    >


  export type flightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    prix?: boolean
    date_depart?: boolean
    date_retour?: boolean
    duree?: boolean
    status?: boolean
    airport_depart_id?: boolean
    airport_arrivee_id?: boolean
    plane_id?: boolean
    plane?: boolean | flight$planeArgs<ExtArgs>
    airport_flight_airport_depart_idToairport?: boolean | flight$airport_flight_airport_depart_idToairportArgs<ExtArgs>
    airport_flight_airport_arrivee_idToairport?: boolean | flight$airport_flight_airport_arrivee_idToairportArgs<ExtArgs>
    flight_seat_reservation?: boolean | flight$flight_seat_reservationArgs<ExtArgs>
    reservation?: boolean | flight$reservationArgs<ExtArgs>
    seat_reservation?: boolean | flight$seat_reservationArgs<ExtArgs>
    _count?: boolean | FlightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flight"]>



  export type flightSelectScalar = {
    id?: boolean
    titre?: boolean
    prix?: boolean
    date_depart?: boolean
    date_retour?: boolean
    duree?: boolean
    status?: boolean
    airport_depart_id?: boolean
    airport_arrivee_id?: boolean
    plane_id?: boolean
  }

  export type flightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titre" | "prix" | "date_depart" | "date_retour" | "duree" | "status" | "airport_depart_id" | "airport_arrivee_id" | "plane_id", ExtArgs["result"]["flight"]>
  export type flightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plane?: boolean | flight$planeArgs<ExtArgs>
    airport_flight_airport_depart_idToairport?: boolean | flight$airport_flight_airport_depart_idToairportArgs<ExtArgs>
    airport_flight_airport_arrivee_idToairport?: boolean | flight$airport_flight_airport_arrivee_idToairportArgs<ExtArgs>
    flight_seat_reservation?: boolean | flight$flight_seat_reservationArgs<ExtArgs>
    reservation?: boolean | flight$reservationArgs<ExtArgs>
    seat_reservation?: boolean | flight$seat_reservationArgs<ExtArgs>
    _count?: boolean | FlightCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $flightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flight"
    objects: {
      plane: Prisma.$planePayload<ExtArgs> | null
      airport_flight_airport_depart_idToairport: Prisma.$airportPayload<ExtArgs> | null
      airport_flight_airport_arrivee_idToairport: Prisma.$airportPayload<ExtArgs> | null
      flight_seat_reservation: Prisma.$flight_seat_reservationPayload<ExtArgs>[]
      reservation: Prisma.$reservationPayload<ExtArgs>[]
      seat_reservation: Prisma.$seat_reservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titre: string
      prix: Prisma.Decimal
      date_depart: Date
      date_retour: Date
      duree: string | null
      status: string
      airport_depart_id: string | null
      airport_arrivee_id: string | null
      plane_id: number | null
    }, ExtArgs["result"]["flight"]>
    composites: {}
  }

  type flightGetPayload<S extends boolean | null | undefined | flightDefaultArgs> = $Result.GetResult<Prisma.$flightPayload, S>

  type flightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<flightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlightCountAggregateInputType | true
    }

  export interface flightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flight'], meta: { name: 'flight' } }
    /**
     * Find zero or one Flight that matches the filter.
     * @param {flightFindUniqueArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flightFindUniqueArgs>(args: SelectSubset<T, flightFindUniqueArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {flightFindUniqueOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flightFindUniqueOrThrowArgs>(args: SelectSubset<T, flightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightFindFirstArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flightFindFirstArgs>(args?: SelectSubset<T, flightFindFirstArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightFindFirstOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flightFindFirstOrThrowArgs>(args?: SelectSubset<T, flightFindFirstOrThrowArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flights
     * const flights = await prisma.flight.findMany()
     * 
     * // Get first 10 Flights
     * const flights = await prisma.flight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightWithIdOnly = await prisma.flight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends flightFindManyArgs>(args?: SelectSubset<T, flightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flight.
     * @param {flightCreateArgs} args - Arguments to create a Flight.
     * @example
     * // Create one Flight
     * const Flight = await prisma.flight.create({
     *   data: {
     *     // ... data to create a Flight
     *   }
     * })
     * 
     */
    create<T extends flightCreateArgs>(args: SelectSubset<T, flightCreateArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flights.
     * @param {flightCreateManyArgs} args - Arguments to create many Flights.
     * @example
     * // Create many Flights
     * const flight = await prisma.flight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flightCreateManyArgs>(args?: SelectSubset<T, flightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flight.
     * @param {flightDeleteArgs} args - Arguments to delete one Flight.
     * @example
     * // Delete one Flight
     * const Flight = await prisma.flight.delete({
     *   where: {
     *     // ... filter to delete one Flight
     *   }
     * })
     * 
     */
    delete<T extends flightDeleteArgs>(args: SelectSubset<T, flightDeleteArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flight.
     * @param {flightUpdateArgs} args - Arguments to update one Flight.
     * @example
     * // Update one Flight
     * const flight = await prisma.flight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flightUpdateArgs>(args: SelectSubset<T, flightUpdateArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flights.
     * @param {flightDeleteManyArgs} args - Arguments to filter Flights to delete.
     * @example
     * // Delete a few Flights
     * const { count } = await prisma.flight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flightDeleteManyArgs>(args?: SelectSubset<T, flightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flights
     * const flight = await prisma.flight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flightUpdateManyArgs>(args: SelectSubset<T, flightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flight.
     * @param {flightUpsertArgs} args - Arguments to update or create a Flight.
     * @example
     * // Update or create a Flight
     * const flight = await prisma.flight.upsert({
     *   create: {
     *     // ... data to create a Flight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flight we want to update
     *   }
     * })
     */
    upsert<T extends flightUpsertArgs>(args: SelectSubset<T, flightUpsertArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightCountArgs} args - Arguments to filter Flights to count.
     * @example
     * // Count the number of Flights
     * const count = await prisma.flight.count({
     *   where: {
     *     // ... the filter for the Flights we want to count
     *   }
     * })
    **/
    count<T extends flightCountArgs>(
      args?: Subset<T, flightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightAggregateArgs>(args: Subset<T, FlightAggregateArgs>): Prisma.PrismaPromise<GetFlightAggregateType<T>>

    /**
     * Group by Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flightGroupByArgs['orderBy'] }
        : { orderBy?: flightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flight model
   */
  readonly fields: flightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plane<T extends flight$planeArgs<ExtArgs> = {}>(args?: Subset<T, flight$planeArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    airport_flight_airport_depart_idToairport<T extends flight$airport_flight_airport_depart_idToairportArgs<ExtArgs> = {}>(args?: Subset<T, flight$airport_flight_airport_depart_idToairportArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    airport_flight_airport_arrivee_idToairport<T extends flight$airport_flight_airport_arrivee_idToairportArgs<ExtArgs> = {}>(args?: Subset<T, flight$airport_flight_airport_arrivee_idToairportArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    flight_seat_reservation<T extends flight$flight_seat_reservationArgs<ExtArgs> = {}>(args?: Subset<T, flight$flight_seat_reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservation<T extends flight$reservationArgs<ExtArgs> = {}>(args?: Subset<T, flight$reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seat_reservation<T extends flight$seat_reservationArgs<ExtArgs> = {}>(args?: Subset<T, flight$seat_reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flight model
   */
  interface flightFieldRefs {
    readonly id: FieldRef<"flight", 'String'>
    readonly titre: FieldRef<"flight", 'String'>
    readonly prix: FieldRef<"flight", 'Decimal'>
    readonly date_depart: FieldRef<"flight", 'DateTime'>
    readonly date_retour: FieldRef<"flight", 'DateTime'>
    readonly duree: FieldRef<"flight", 'String'>
    readonly status: FieldRef<"flight", 'String'>
    readonly airport_depart_id: FieldRef<"flight", 'String'>
    readonly airport_arrivee_id: FieldRef<"flight", 'String'>
    readonly plane_id: FieldRef<"flight", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * flight findUnique
   */
  export type flightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight findUniqueOrThrow
   */
  export type flightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight findFirst
   */
  export type flightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flights.
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * flight findFirstOrThrow
   */
  export type flightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flights.
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * flight findMany
   */
  export type flightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flights to fetch.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flights.
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * flight create
   */
  export type flightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * The data needed to create a flight.
     */
    data: XOR<flightCreateInput, flightUncheckedCreateInput>
  }

  /**
   * flight createMany
   */
  export type flightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flights.
     */
    data: flightCreateManyInput | flightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flight update
   */
  export type flightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * The data needed to update a flight.
     */
    data: XOR<flightUpdateInput, flightUncheckedUpdateInput>
    /**
     * Choose, which flight to update.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight updateMany
   */
  export type flightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flights.
     */
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyInput>
    /**
     * Filter which flights to update
     */
    where?: flightWhereInput
    /**
     * Limit how many flights to update.
     */
    limit?: number
  }

  /**
   * flight upsert
   */
  export type flightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * The filter to search for the flight to update in case it exists.
     */
    where: flightWhereUniqueInput
    /**
     * In case the flight found by the `where` argument doesn't exist, create a new flight with this data.
     */
    create: XOR<flightCreateInput, flightUncheckedCreateInput>
    /**
     * In case the flight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flightUpdateInput, flightUncheckedUpdateInput>
  }

  /**
   * flight delete
   */
  export type flightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter which flight to delete.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight deleteMany
   */
  export type flightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flights to delete
     */
    where?: flightWhereInput
    /**
     * Limit how many flights to delete.
     */
    limit?: number
  }

  /**
   * flight.plane
   */
  export type flight$planeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    where?: planeWhereInput
  }

  /**
   * flight.airport_flight_airport_depart_idToairport
   */
  export type flight$airport_flight_airport_depart_idToairportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    where?: airportWhereInput
  }

  /**
   * flight.airport_flight_airport_arrivee_idToairport
   */
  export type flight$airport_flight_airport_arrivee_idToairportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    where?: airportWhereInput
  }

  /**
   * flight.flight_seat_reservation
   */
  export type flight$flight_seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    where?: flight_seat_reservationWhereInput
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    cursor?: flight_seat_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Flight_seat_reservationScalarFieldEnum | Flight_seat_reservationScalarFieldEnum[]
  }

  /**
   * flight.reservation
   */
  export type flight$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    where?: reservationWhereInput
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    cursor?: reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * flight.seat_reservation
   */
  export type flight$seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    where?: seat_reservationWhereInput
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    cursor?: seat_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Seat_reservationScalarFieldEnum | Seat_reservationScalarFieldEnum[]
  }

  /**
   * flight without action
   */
  export type flightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
  }


  /**
   * Model flight_seat_reservation
   */

  export type AggregateFlight_seat_reservation = {
    _count: Flight_seat_reservationCountAggregateOutputType | null
    _avg: Flight_seat_reservationAvgAggregateOutputType | null
    _sum: Flight_seat_reservationSumAggregateOutputType | null
    _min: Flight_seat_reservationMinAggregateOutputType | null
    _max: Flight_seat_reservationMaxAggregateOutputType | null
  }

  export type Flight_seat_reservationAvgAggregateOutputType = {
    isReserved: number | null
    seat_id: number | null
  }

  export type Flight_seat_reservationSumAggregateOutputType = {
    isReserved: number | null
    seat_id: number | null
  }

  export type Flight_seat_reservationMinAggregateOutputType = {
    id: string | null
    isReserved: number | null
    flight_id: string | null
    seat_id: number | null
    reservation_id: string | null
  }

  export type Flight_seat_reservationMaxAggregateOutputType = {
    id: string | null
    isReserved: number | null
    flight_id: string | null
    seat_id: number | null
    reservation_id: string | null
  }

  export type Flight_seat_reservationCountAggregateOutputType = {
    id: number
    isReserved: number
    flight_id: number
    seat_id: number
    reservation_id: number
    _all: number
  }


  export type Flight_seat_reservationAvgAggregateInputType = {
    isReserved?: true
    seat_id?: true
  }

  export type Flight_seat_reservationSumAggregateInputType = {
    isReserved?: true
    seat_id?: true
  }

  export type Flight_seat_reservationMinAggregateInputType = {
    id?: true
    isReserved?: true
    flight_id?: true
    seat_id?: true
    reservation_id?: true
  }

  export type Flight_seat_reservationMaxAggregateInputType = {
    id?: true
    isReserved?: true
    flight_id?: true
    seat_id?: true
    reservation_id?: true
  }

  export type Flight_seat_reservationCountAggregateInputType = {
    id?: true
    isReserved?: true
    flight_id?: true
    seat_id?: true
    reservation_id?: true
    _all?: true
  }

  export type Flight_seat_reservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flight_seat_reservation to aggregate.
     */
    where?: flight_seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flight_seat_reservations to fetch.
     */
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flight_seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flight_seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flight_seat_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flight_seat_reservations
    **/
    _count?: true | Flight_seat_reservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Flight_seat_reservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Flight_seat_reservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Flight_seat_reservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Flight_seat_reservationMaxAggregateInputType
  }

  export type GetFlight_seat_reservationAggregateType<T extends Flight_seat_reservationAggregateArgs> = {
        [P in keyof T & keyof AggregateFlight_seat_reservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlight_seat_reservation[P]>
      : GetScalarType<T[P], AggregateFlight_seat_reservation[P]>
  }




  export type flight_seat_reservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flight_seat_reservationWhereInput
    orderBy?: flight_seat_reservationOrderByWithAggregationInput | flight_seat_reservationOrderByWithAggregationInput[]
    by: Flight_seat_reservationScalarFieldEnum[] | Flight_seat_reservationScalarFieldEnum
    having?: flight_seat_reservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Flight_seat_reservationCountAggregateInputType | true
    _avg?: Flight_seat_reservationAvgAggregateInputType
    _sum?: Flight_seat_reservationSumAggregateInputType
    _min?: Flight_seat_reservationMinAggregateInputType
    _max?: Flight_seat_reservationMaxAggregateInputType
  }

  export type Flight_seat_reservationGroupByOutputType = {
    id: string
    isReserved: number
    flight_id: string | null
    seat_id: number | null
    reservation_id: string | null
    _count: Flight_seat_reservationCountAggregateOutputType | null
    _avg: Flight_seat_reservationAvgAggregateOutputType | null
    _sum: Flight_seat_reservationSumAggregateOutputType | null
    _min: Flight_seat_reservationMinAggregateOutputType | null
    _max: Flight_seat_reservationMaxAggregateOutputType | null
  }

  type GetFlight_seat_reservationGroupByPayload<T extends flight_seat_reservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Flight_seat_reservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Flight_seat_reservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Flight_seat_reservationGroupByOutputType[P]>
            : GetScalarType<T[P], Flight_seat_reservationGroupByOutputType[P]>
        }
      >
    >


  export type flight_seat_reservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isReserved?: boolean
    flight_id?: boolean
    seat_id?: boolean
    reservation_id?: boolean
    seat?: boolean | flight_seat_reservation$seatArgs<ExtArgs>
    flight?: boolean | flight_seat_reservation$flightArgs<ExtArgs>
    reservation?: boolean | flight_seat_reservation$reservationArgs<ExtArgs>
  }, ExtArgs["result"]["flight_seat_reservation"]>



  export type flight_seat_reservationSelectScalar = {
    id?: boolean
    isReserved?: boolean
    flight_id?: boolean
    seat_id?: boolean
    reservation_id?: boolean
  }

  export type flight_seat_reservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isReserved" | "flight_id" | "seat_id" | "reservation_id", ExtArgs["result"]["flight_seat_reservation"]>
  export type flight_seat_reservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | flight_seat_reservation$seatArgs<ExtArgs>
    flight?: boolean | flight_seat_reservation$flightArgs<ExtArgs>
    reservation?: boolean | flight_seat_reservation$reservationArgs<ExtArgs>
  }

  export type $flight_seat_reservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flight_seat_reservation"
    objects: {
      seat: Prisma.$seatPayload<ExtArgs> | null
      flight: Prisma.$flightPayload<ExtArgs> | null
      reservation: Prisma.$reservationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isReserved: number
      flight_id: string | null
      seat_id: number | null
      reservation_id: string | null
    }, ExtArgs["result"]["flight_seat_reservation"]>
    composites: {}
  }

  type flight_seat_reservationGetPayload<S extends boolean | null | undefined | flight_seat_reservationDefaultArgs> = $Result.GetResult<Prisma.$flight_seat_reservationPayload, S>

  type flight_seat_reservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<flight_seat_reservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Flight_seat_reservationCountAggregateInputType | true
    }

  export interface flight_seat_reservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flight_seat_reservation'], meta: { name: 'flight_seat_reservation' } }
    /**
     * Find zero or one Flight_seat_reservation that matches the filter.
     * @param {flight_seat_reservationFindUniqueArgs} args - Arguments to find a Flight_seat_reservation
     * @example
     * // Get one Flight_seat_reservation
     * const flight_seat_reservation = await prisma.flight_seat_reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flight_seat_reservationFindUniqueArgs>(args: SelectSubset<T, flight_seat_reservationFindUniqueArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flight_seat_reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {flight_seat_reservationFindUniqueOrThrowArgs} args - Arguments to find a Flight_seat_reservation
     * @example
     * // Get one Flight_seat_reservation
     * const flight_seat_reservation = await prisma.flight_seat_reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flight_seat_reservationFindUniqueOrThrowArgs>(args: SelectSubset<T, flight_seat_reservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight_seat_reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flight_seat_reservationFindFirstArgs} args - Arguments to find a Flight_seat_reservation
     * @example
     * // Get one Flight_seat_reservation
     * const flight_seat_reservation = await prisma.flight_seat_reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flight_seat_reservationFindFirstArgs>(args?: SelectSubset<T, flight_seat_reservationFindFirstArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight_seat_reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flight_seat_reservationFindFirstOrThrowArgs} args - Arguments to find a Flight_seat_reservation
     * @example
     * // Get one Flight_seat_reservation
     * const flight_seat_reservation = await prisma.flight_seat_reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flight_seat_reservationFindFirstOrThrowArgs>(args?: SelectSubset<T, flight_seat_reservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flight_seat_reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flight_seat_reservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flight_seat_reservations
     * const flight_seat_reservations = await prisma.flight_seat_reservation.findMany()
     * 
     * // Get first 10 Flight_seat_reservations
     * const flight_seat_reservations = await prisma.flight_seat_reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flight_seat_reservationWithIdOnly = await prisma.flight_seat_reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends flight_seat_reservationFindManyArgs>(args?: SelectSubset<T, flight_seat_reservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flight_seat_reservation.
     * @param {flight_seat_reservationCreateArgs} args - Arguments to create a Flight_seat_reservation.
     * @example
     * // Create one Flight_seat_reservation
     * const Flight_seat_reservation = await prisma.flight_seat_reservation.create({
     *   data: {
     *     // ... data to create a Flight_seat_reservation
     *   }
     * })
     * 
     */
    create<T extends flight_seat_reservationCreateArgs>(args: SelectSubset<T, flight_seat_reservationCreateArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flight_seat_reservations.
     * @param {flight_seat_reservationCreateManyArgs} args - Arguments to create many Flight_seat_reservations.
     * @example
     * // Create many Flight_seat_reservations
     * const flight_seat_reservation = await prisma.flight_seat_reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flight_seat_reservationCreateManyArgs>(args?: SelectSubset<T, flight_seat_reservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flight_seat_reservation.
     * @param {flight_seat_reservationDeleteArgs} args - Arguments to delete one Flight_seat_reservation.
     * @example
     * // Delete one Flight_seat_reservation
     * const Flight_seat_reservation = await prisma.flight_seat_reservation.delete({
     *   where: {
     *     // ... filter to delete one Flight_seat_reservation
     *   }
     * })
     * 
     */
    delete<T extends flight_seat_reservationDeleteArgs>(args: SelectSubset<T, flight_seat_reservationDeleteArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flight_seat_reservation.
     * @param {flight_seat_reservationUpdateArgs} args - Arguments to update one Flight_seat_reservation.
     * @example
     * // Update one Flight_seat_reservation
     * const flight_seat_reservation = await prisma.flight_seat_reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flight_seat_reservationUpdateArgs>(args: SelectSubset<T, flight_seat_reservationUpdateArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flight_seat_reservations.
     * @param {flight_seat_reservationDeleteManyArgs} args - Arguments to filter Flight_seat_reservations to delete.
     * @example
     * // Delete a few Flight_seat_reservations
     * const { count } = await prisma.flight_seat_reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flight_seat_reservationDeleteManyArgs>(args?: SelectSubset<T, flight_seat_reservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flight_seat_reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flight_seat_reservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flight_seat_reservations
     * const flight_seat_reservation = await prisma.flight_seat_reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flight_seat_reservationUpdateManyArgs>(args: SelectSubset<T, flight_seat_reservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flight_seat_reservation.
     * @param {flight_seat_reservationUpsertArgs} args - Arguments to update or create a Flight_seat_reservation.
     * @example
     * // Update or create a Flight_seat_reservation
     * const flight_seat_reservation = await prisma.flight_seat_reservation.upsert({
     *   create: {
     *     // ... data to create a Flight_seat_reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flight_seat_reservation we want to update
     *   }
     * })
     */
    upsert<T extends flight_seat_reservationUpsertArgs>(args: SelectSubset<T, flight_seat_reservationUpsertArgs<ExtArgs>>): Prisma__flight_seat_reservationClient<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flight_seat_reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flight_seat_reservationCountArgs} args - Arguments to filter Flight_seat_reservations to count.
     * @example
     * // Count the number of Flight_seat_reservations
     * const count = await prisma.flight_seat_reservation.count({
     *   where: {
     *     // ... the filter for the Flight_seat_reservations we want to count
     *   }
     * })
    **/
    count<T extends flight_seat_reservationCountArgs>(
      args?: Subset<T, flight_seat_reservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Flight_seat_reservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flight_seat_reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Flight_seat_reservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Flight_seat_reservationAggregateArgs>(args: Subset<T, Flight_seat_reservationAggregateArgs>): Prisma.PrismaPromise<GetFlight_seat_reservationAggregateType<T>>

    /**
     * Group by Flight_seat_reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flight_seat_reservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flight_seat_reservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flight_seat_reservationGroupByArgs['orderBy'] }
        : { orderBy?: flight_seat_reservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flight_seat_reservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlight_seat_reservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flight_seat_reservation model
   */
  readonly fields: flight_seat_reservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flight_seat_reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flight_seat_reservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seat<T extends flight_seat_reservation$seatArgs<ExtArgs> = {}>(args?: Subset<T, flight_seat_reservation$seatArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    flight<T extends flight_seat_reservation$flightArgs<ExtArgs> = {}>(args?: Subset<T, flight_seat_reservation$flightArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservation<T extends flight_seat_reservation$reservationArgs<ExtArgs> = {}>(args?: Subset<T, flight_seat_reservation$reservationArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flight_seat_reservation model
   */
  interface flight_seat_reservationFieldRefs {
    readonly id: FieldRef<"flight_seat_reservation", 'String'>
    readonly isReserved: FieldRef<"flight_seat_reservation", 'Int'>
    readonly flight_id: FieldRef<"flight_seat_reservation", 'String'>
    readonly seat_id: FieldRef<"flight_seat_reservation", 'Int'>
    readonly reservation_id: FieldRef<"flight_seat_reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * flight_seat_reservation findUnique
   */
  export type flight_seat_reservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which flight_seat_reservation to fetch.
     */
    where: flight_seat_reservationWhereUniqueInput
  }

  /**
   * flight_seat_reservation findUniqueOrThrow
   */
  export type flight_seat_reservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which flight_seat_reservation to fetch.
     */
    where: flight_seat_reservationWhereUniqueInput
  }

  /**
   * flight_seat_reservation findFirst
   */
  export type flight_seat_reservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which flight_seat_reservation to fetch.
     */
    where?: flight_seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flight_seat_reservations to fetch.
     */
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flight_seat_reservations.
     */
    cursor?: flight_seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flight_seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flight_seat_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flight_seat_reservations.
     */
    distinct?: Flight_seat_reservationScalarFieldEnum | Flight_seat_reservationScalarFieldEnum[]
  }

  /**
   * flight_seat_reservation findFirstOrThrow
   */
  export type flight_seat_reservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which flight_seat_reservation to fetch.
     */
    where?: flight_seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flight_seat_reservations to fetch.
     */
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flight_seat_reservations.
     */
    cursor?: flight_seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flight_seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flight_seat_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flight_seat_reservations.
     */
    distinct?: Flight_seat_reservationScalarFieldEnum | Flight_seat_reservationScalarFieldEnum[]
  }

  /**
   * flight_seat_reservation findMany
   */
  export type flight_seat_reservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which flight_seat_reservations to fetch.
     */
    where?: flight_seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flight_seat_reservations to fetch.
     */
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flight_seat_reservations.
     */
    cursor?: flight_seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flight_seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flight_seat_reservations.
     */
    skip?: number
    distinct?: Flight_seat_reservationScalarFieldEnum | Flight_seat_reservationScalarFieldEnum[]
  }

  /**
   * flight_seat_reservation create
   */
  export type flight_seat_reservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * The data needed to create a flight_seat_reservation.
     */
    data: XOR<flight_seat_reservationCreateInput, flight_seat_reservationUncheckedCreateInput>
  }

  /**
   * flight_seat_reservation createMany
   */
  export type flight_seat_reservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flight_seat_reservations.
     */
    data: flight_seat_reservationCreateManyInput | flight_seat_reservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flight_seat_reservation update
   */
  export type flight_seat_reservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * The data needed to update a flight_seat_reservation.
     */
    data: XOR<flight_seat_reservationUpdateInput, flight_seat_reservationUncheckedUpdateInput>
    /**
     * Choose, which flight_seat_reservation to update.
     */
    where: flight_seat_reservationWhereUniqueInput
  }

  /**
   * flight_seat_reservation updateMany
   */
  export type flight_seat_reservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flight_seat_reservations.
     */
    data: XOR<flight_seat_reservationUpdateManyMutationInput, flight_seat_reservationUncheckedUpdateManyInput>
    /**
     * Filter which flight_seat_reservations to update
     */
    where?: flight_seat_reservationWhereInput
    /**
     * Limit how many flight_seat_reservations to update.
     */
    limit?: number
  }

  /**
   * flight_seat_reservation upsert
   */
  export type flight_seat_reservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * The filter to search for the flight_seat_reservation to update in case it exists.
     */
    where: flight_seat_reservationWhereUniqueInput
    /**
     * In case the flight_seat_reservation found by the `where` argument doesn't exist, create a new flight_seat_reservation with this data.
     */
    create: XOR<flight_seat_reservationCreateInput, flight_seat_reservationUncheckedCreateInput>
    /**
     * In case the flight_seat_reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flight_seat_reservationUpdateInput, flight_seat_reservationUncheckedUpdateInput>
  }

  /**
   * flight_seat_reservation delete
   */
  export type flight_seat_reservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    /**
     * Filter which flight_seat_reservation to delete.
     */
    where: flight_seat_reservationWhereUniqueInput
  }

  /**
   * flight_seat_reservation deleteMany
   */
  export type flight_seat_reservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flight_seat_reservations to delete
     */
    where?: flight_seat_reservationWhereInput
    /**
     * Limit how many flight_seat_reservations to delete.
     */
    limit?: number
  }

  /**
   * flight_seat_reservation.seat
   */
  export type flight_seat_reservation$seatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    where?: seatWhereInput
  }

  /**
   * flight_seat_reservation.flight
   */
  export type flight_seat_reservation$flightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
  }

  /**
   * flight_seat_reservation.reservation
   */
  export type flight_seat_reservation$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    where?: reservationWhereInput
  }

  /**
   * flight_seat_reservation without action
   */
  export type flight_seat_reservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
  }


  /**
   * Model location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    nom: string | null
    pays: string | null
    ville: string | null
    description: string | null
    url_image: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    pays: string | null
    ville: string | null
    description: string | null
    url_image: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    nom: number
    pays: number
    ville: number
    description: number
    url_image: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    nom?: true
    pays?: true
    ville?: true
    description?: true
    url_image?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    nom?: true
    pays?: true
    ville?: true
    description?: true
    url_image?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    nom?: true
    pays?: true
    ville?: true
    description?: true
    url_image?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location to aggregate.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type locationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationWhereInput
    orderBy?: locationOrderByWithAggregationInput | locationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    nom: string
    pays: string
    ville: string
    description: string | null
    url_image: string | null
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends locationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    pays?: boolean
    ville?: boolean
    description?: boolean
    url_image?: boolean
    airport?: boolean | location$airportArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>



  export type locationSelectScalar = {
    id?: boolean
    nom?: boolean
    pays?: boolean
    ville?: boolean
    description?: boolean
    url_image?: boolean
  }

  export type locationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "pays" | "ville" | "description" | "url_image", ExtArgs["result"]["location"]>
  export type locationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airport?: boolean | location$airportArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $locationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "location"
    objects: {
      airport: Prisma.$airportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      pays: string
      ville: string
      description: string | null
      url_image: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type locationGetPayload<S extends boolean | null | undefined | locationDefaultArgs> = $Result.GetResult<Prisma.$locationPayload, S>

  type locationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface locationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['location'], meta: { name: 'location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationFindUniqueArgs>(args: SelectSubset<T, locationFindUniqueArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationFindUniqueOrThrowArgs>(args: SelectSubset<T, locationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationFindFirstArgs>(args?: SelectSubset<T, locationFindFirstArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationFindFirstOrThrowArgs>(args?: SelectSubset<T, locationFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationFindManyArgs>(args?: SelectSubset<T, locationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends locationCreateArgs>(args: SelectSubset<T, locationCreateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {locationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationCreateManyArgs>(args?: SelectSubset<T, locationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends locationDeleteArgs>(args: SelectSubset<T, locationDeleteArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationUpdateArgs>(args: SelectSubset<T, locationUpdateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationDeleteManyArgs>(args?: SelectSubset<T, locationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationUpdateManyArgs>(args: SelectSubset<T, locationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends locationUpsertArgs>(args: SelectSubset<T, locationUpsertArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationGroupByArgs['orderBy'] }
        : { orderBy?: locationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the location model
   */
  readonly fields: locationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airport<T extends location$airportArgs<ExtArgs> = {}>(args?: Subset<T, location$airportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the location model
   */
  interface locationFieldRefs {
    readonly id: FieldRef<"location", 'String'>
    readonly nom: FieldRef<"location", 'String'>
    readonly pays: FieldRef<"location", 'String'>
    readonly ville: FieldRef<"location", 'String'>
    readonly description: FieldRef<"location", 'String'>
    readonly url_image: FieldRef<"location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * location findUnique
   */
  export type locationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findUniqueOrThrow
   */
  export type locationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findFirst
   */
  export type locationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findFirstOrThrow
   */
  export type locationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findMany
   */
  export type locationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location create
   */
  export type locationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to create a location.
     */
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }

  /**
   * location createMany
   */
  export type locationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationCreateManyInput | locationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location update
   */
  export type locationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to update a location.
     */
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location updateMany
   */
  export type locationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * location upsert
   */
  export type locationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The filter to search for the location to update in case it exists.
     */
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     */
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }

  /**
   * location delete
   */
  export type locationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter which location to delete.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * location.airport
   */
  export type location$airportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    where?: airportWhereInput
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    cursor?: airportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * location without action
   */
  export type locationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
  }


  /**
   * Model news
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsMinAggregateOutputType = {
    id: string | null
    titre: string | null
    contenu: string | null
    image_url: string | null
    date_creation: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: string | null
    titre: string | null
    contenu: string | null
    image_url: string | null
    date_creation: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    titre: number
    contenu: number
    image_url: number
    date_creation: number
    _all: number
  }


  export type NewsMinAggregateInputType = {
    id?: true
    titre?: true
    contenu?: true
    image_url?: true
    date_creation?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    titre?: true
    contenu?: true
    image_url?: true
    date_creation?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    titre?: true
    contenu?: true
    image_url?: true
    date_creation?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which news to aggregate.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned news
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type newsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsWhereInput
    orderBy?: newsOrderByWithAggregationInput | newsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: newsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: string
    titre: string
    contenu: string
    image_url: string | null
    date_creation: Date
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends newsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type newsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    contenu?: boolean
    image_url?: boolean
    date_creation?: boolean
  }, ExtArgs["result"]["news"]>



  export type newsSelectScalar = {
    id?: boolean
    titre?: boolean
    contenu?: boolean
    image_url?: boolean
    date_creation?: boolean
  }

  export type newsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titre" | "contenu" | "image_url" | "date_creation", ExtArgs["result"]["news"]>

  export type $newsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "news"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titre: string
      contenu: string
      image_url: string | null
      date_creation: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type newsGetPayload<S extends boolean | null | undefined | newsDefaultArgs> = $Result.GetResult<Prisma.$newsPayload, S>

  type newsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<newsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface newsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['news'], meta: { name: 'news' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {newsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsFindUniqueArgs>(args: SelectSubset<T, newsFindUniqueArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {newsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsFindUniqueOrThrowArgs>(args: SelectSubset<T, newsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsFindFirstArgs>(args?: SelectSubset<T, newsFindFirstArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsFindFirstOrThrowArgs>(args?: SelectSubset<T, newsFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends newsFindManyArgs>(args?: SelectSubset<T, newsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News.
     * @param {newsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends newsCreateArgs>(args: SelectSubset<T, newsCreateArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News.
     * @param {newsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsCreateManyArgs>(args?: SelectSubset<T, newsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News.
     * @param {newsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends newsDeleteArgs>(args: SelectSubset<T, newsDeleteArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News.
     * @param {newsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsUpdateArgs>(args: SelectSubset<T, newsUpdateArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News.
     * @param {newsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsDeleteManyArgs>(args?: SelectSubset<T, newsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsUpdateManyArgs>(args: SelectSubset<T, newsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {newsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends newsUpsertArgs>(args: SelectSubset<T, newsUpsertArgs<ExtArgs>>): Prisma__newsClient<$Result.GetResult<Prisma.$newsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends newsCountArgs>(
      args?: Subset<T, newsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsGroupByArgs['orderBy'] }
        : { orderBy?: newsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the news model
   */
  readonly fields: newsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the news model
   */
  interface newsFieldRefs {
    readonly id: FieldRef<"news", 'String'>
    readonly titre: FieldRef<"news", 'String'>
    readonly contenu: FieldRef<"news", 'String'>
    readonly image_url: FieldRef<"news", 'String'>
    readonly date_creation: FieldRef<"news", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * news findUnique
   */
  export type newsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where: newsWhereUniqueInput
  }

  /**
   * news findUniqueOrThrow
   */
  export type newsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where: newsWhereUniqueInput
  }

  /**
   * news findFirst
   */
  export type newsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news.
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * news findFirstOrThrow
   */
  export type newsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news.
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * news findMany
   */
  export type newsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing news.
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * news create
   */
  export type newsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * The data needed to create a news.
     */
    data: XOR<newsCreateInput, newsUncheckedCreateInput>
  }

  /**
   * news createMany
   */
  export type newsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many news.
     */
    data: newsCreateManyInput | newsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * news update
   */
  export type newsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * The data needed to update a news.
     */
    data: XOR<newsUpdateInput, newsUncheckedUpdateInput>
    /**
     * Choose, which news to update.
     */
    where: newsWhereUniqueInput
  }

  /**
   * news updateMany
   */
  export type newsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update news.
     */
    data: XOR<newsUpdateManyMutationInput, newsUncheckedUpdateManyInput>
    /**
     * Filter which news to update
     */
    where?: newsWhereInput
    /**
     * Limit how many news to update.
     */
    limit?: number
  }

  /**
   * news upsert
   */
  export type newsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * The filter to search for the news to update in case it exists.
     */
    where: newsWhereUniqueInput
    /**
     * In case the news found by the `where` argument doesn't exist, create a new news with this data.
     */
    create: XOR<newsCreateInput, newsUncheckedCreateInput>
    /**
     * In case the news was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsUpdateInput, newsUncheckedUpdateInput>
  }

  /**
   * news delete
   */
  export type newsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
    /**
     * Filter which news to delete.
     */
    where: newsWhereUniqueInput
  }

  /**
   * news deleteMany
   */
  export type newsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which news to delete
     */
    where?: newsWhereInput
    /**
     * Limit how many news to delete.
     */
    limit?: number
  }

  /**
   * news without action
   */
  export type newsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the news
     */
    omit?: newsOmit<ExtArgs> | null
  }


  /**
   * Model plane
   */

  export type AggregatePlane = {
    _count: PlaneCountAggregateOutputType | null
    _avg: PlaneAvgAggregateOutputType | null
    _sum: PlaneSumAggregateOutputType | null
    _min: PlaneMinAggregateOutputType | null
    _max: PlaneMaxAggregateOutputType | null
  }

  export type PlaneAvgAggregateOutputType = {
    idPlane: number | null
    totalSeats: number | null
  }

  export type PlaneSumAggregateOutputType = {
    idPlane: number | null
    totalSeats: number | null
  }

  export type PlaneMinAggregateOutputType = {
    idPlane: number | null
    planeModel: string | null
    totalSeats: number | null
    seatConfiguration: string | null
  }

  export type PlaneMaxAggregateOutputType = {
    idPlane: number | null
    planeModel: string | null
    totalSeats: number | null
    seatConfiguration: string | null
  }

  export type PlaneCountAggregateOutputType = {
    idPlane: number
    planeModel: number
    totalSeats: number
    seatConfiguration: number
    _all: number
  }


  export type PlaneAvgAggregateInputType = {
    idPlane?: true
    totalSeats?: true
  }

  export type PlaneSumAggregateInputType = {
    idPlane?: true
    totalSeats?: true
  }

  export type PlaneMinAggregateInputType = {
    idPlane?: true
    planeModel?: true
    totalSeats?: true
    seatConfiguration?: true
  }

  export type PlaneMaxAggregateInputType = {
    idPlane?: true
    planeModel?: true
    totalSeats?: true
    seatConfiguration?: true
  }

  export type PlaneCountAggregateInputType = {
    idPlane?: true
    planeModel?: true
    totalSeats?: true
    seatConfiguration?: true
    _all?: true
  }

  export type PlaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plane to aggregate.
     */
    where?: planeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planes to fetch.
     */
    orderBy?: planeOrderByWithRelationInput | planeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planes
    **/
    _count?: true | PlaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaneMaxAggregateInputType
  }

  export type GetPlaneAggregateType<T extends PlaneAggregateArgs> = {
        [P in keyof T & keyof AggregatePlane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlane[P]>
      : GetScalarType<T[P], AggregatePlane[P]>
  }




  export type planeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planeWhereInput
    orderBy?: planeOrderByWithAggregationInput | planeOrderByWithAggregationInput[]
    by: PlaneScalarFieldEnum[] | PlaneScalarFieldEnum
    having?: planeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaneCountAggregateInputType | true
    _avg?: PlaneAvgAggregateInputType
    _sum?: PlaneSumAggregateInputType
    _min?: PlaneMinAggregateInputType
    _max?: PlaneMaxAggregateInputType
  }

  export type PlaneGroupByOutputType = {
    idPlane: number
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    _count: PlaneCountAggregateOutputType | null
    _avg: PlaneAvgAggregateOutputType | null
    _sum: PlaneSumAggregateOutputType | null
    _min: PlaneMinAggregateOutputType | null
    _max: PlaneMaxAggregateOutputType | null
  }

  type GetPlaneGroupByPayload<T extends planeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaneGroupByOutputType[P]>
            : GetScalarType<T[P], PlaneGroupByOutputType[P]>
        }
      >
    >


  export type planeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlane?: boolean
    planeModel?: boolean
    totalSeats?: boolean
    seatConfiguration?: boolean
    flight?: boolean | plane$flightArgs<ExtArgs>
    seat?: boolean | plane$seatArgs<ExtArgs>
    _count?: boolean | PlaneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plane"]>



  export type planeSelectScalar = {
    idPlane?: boolean
    planeModel?: boolean
    totalSeats?: boolean
    seatConfiguration?: boolean
  }

  export type planeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlane" | "planeModel" | "totalSeats" | "seatConfiguration", ExtArgs["result"]["plane"]>
  export type planeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight?: boolean | plane$flightArgs<ExtArgs>
    seat?: boolean | plane$seatArgs<ExtArgs>
    _count?: boolean | PlaneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $planePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plane"
    objects: {
      flight: Prisma.$flightPayload<ExtArgs>[]
      seat: Prisma.$seatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlane: number
      planeModel: string
      totalSeats: number
      seatConfiguration: string
    }, ExtArgs["result"]["plane"]>
    composites: {}
  }

  type planeGetPayload<S extends boolean | null | undefined | planeDefaultArgs> = $Result.GetResult<Prisma.$planePayload, S>

  type planeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<planeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaneCountAggregateInputType | true
    }

  export interface planeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plane'], meta: { name: 'plane' } }
    /**
     * Find zero or one Plane that matches the filter.
     * @param {planeFindUniqueArgs} args - Arguments to find a Plane
     * @example
     * // Get one Plane
     * const plane = await prisma.plane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends planeFindUniqueArgs>(args: SelectSubset<T, planeFindUniqueArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {planeFindUniqueOrThrowArgs} args - Arguments to find a Plane
     * @example
     * // Get one Plane
     * const plane = await prisma.plane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends planeFindUniqueOrThrowArgs>(args: SelectSubset<T, planeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planeFindFirstArgs} args - Arguments to find a Plane
     * @example
     * // Get one Plane
     * const plane = await prisma.plane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends planeFindFirstArgs>(args?: SelectSubset<T, planeFindFirstArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planeFindFirstOrThrowArgs} args - Arguments to find a Plane
     * @example
     * // Get one Plane
     * const plane = await prisma.plane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends planeFindFirstOrThrowArgs>(args?: SelectSubset<T, planeFindFirstOrThrowArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Planes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planes
     * const planes = await prisma.plane.findMany()
     * 
     * // Get first 10 Planes
     * const planes = await prisma.plane.findMany({ take: 10 })
     * 
     * // Only select the `idPlane`
     * const planeWithIdPlaneOnly = await prisma.plane.findMany({ select: { idPlane: true } })
     * 
     */
    findMany<T extends planeFindManyArgs>(args?: SelectSubset<T, planeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plane.
     * @param {planeCreateArgs} args - Arguments to create a Plane.
     * @example
     * // Create one Plane
     * const Plane = await prisma.plane.create({
     *   data: {
     *     // ... data to create a Plane
     *   }
     * })
     * 
     */
    create<T extends planeCreateArgs>(args: SelectSubset<T, planeCreateArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Planes.
     * @param {planeCreateManyArgs} args - Arguments to create many Planes.
     * @example
     * // Create many Planes
     * const plane = await prisma.plane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends planeCreateManyArgs>(args?: SelectSubset<T, planeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plane.
     * @param {planeDeleteArgs} args - Arguments to delete one Plane.
     * @example
     * // Delete one Plane
     * const Plane = await prisma.plane.delete({
     *   where: {
     *     // ... filter to delete one Plane
     *   }
     * })
     * 
     */
    delete<T extends planeDeleteArgs>(args: SelectSubset<T, planeDeleteArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plane.
     * @param {planeUpdateArgs} args - Arguments to update one Plane.
     * @example
     * // Update one Plane
     * const plane = await prisma.plane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends planeUpdateArgs>(args: SelectSubset<T, planeUpdateArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Planes.
     * @param {planeDeleteManyArgs} args - Arguments to filter Planes to delete.
     * @example
     * // Delete a few Planes
     * const { count } = await prisma.plane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends planeDeleteManyArgs>(args?: SelectSubset<T, planeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planes
     * const plane = await prisma.plane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends planeUpdateManyArgs>(args: SelectSubset<T, planeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plane.
     * @param {planeUpsertArgs} args - Arguments to update or create a Plane.
     * @example
     * // Update or create a Plane
     * const plane = await prisma.plane.upsert({
     *   create: {
     *     // ... data to create a Plane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plane we want to update
     *   }
     * })
     */
    upsert<T extends planeUpsertArgs>(args: SelectSubset<T, planeUpsertArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Planes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planeCountArgs} args - Arguments to filter Planes to count.
     * @example
     * // Count the number of Planes
     * const count = await prisma.plane.count({
     *   where: {
     *     // ... the filter for the Planes we want to count
     *   }
     * })
    **/
    count<T extends planeCountArgs>(
      args?: Subset<T, planeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaneAggregateArgs>(args: Subset<T, PlaneAggregateArgs>): Prisma.PrismaPromise<GetPlaneAggregateType<T>>

    /**
     * Group by Plane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planeGroupByArgs['orderBy'] }
        : { orderBy?: planeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plane model
   */
  readonly fields: planeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flight<T extends plane$flightArgs<ExtArgs> = {}>(args?: Subset<T, plane$flightArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seat<T extends plane$seatArgs<ExtArgs> = {}>(args?: Subset<T, plane$seatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plane model
   */
  interface planeFieldRefs {
    readonly idPlane: FieldRef<"plane", 'Int'>
    readonly planeModel: FieldRef<"plane", 'String'>
    readonly totalSeats: FieldRef<"plane", 'Int'>
    readonly seatConfiguration: FieldRef<"plane", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plane findUnique
   */
  export type planeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * Filter, which plane to fetch.
     */
    where: planeWhereUniqueInput
  }

  /**
   * plane findUniqueOrThrow
   */
  export type planeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * Filter, which plane to fetch.
     */
    where: planeWhereUniqueInput
  }

  /**
   * plane findFirst
   */
  export type planeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * Filter, which plane to fetch.
     */
    where?: planeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planes to fetch.
     */
    orderBy?: planeOrderByWithRelationInput | planeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planes.
     */
    cursor?: planeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planes.
     */
    distinct?: PlaneScalarFieldEnum | PlaneScalarFieldEnum[]
  }

  /**
   * plane findFirstOrThrow
   */
  export type planeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * Filter, which plane to fetch.
     */
    where?: planeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planes to fetch.
     */
    orderBy?: planeOrderByWithRelationInput | planeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planes.
     */
    cursor?: planeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planes.
     */
    distinct?: PlaneScalarFieldEnum | PlaneScalarFieldEnum[]
  }

  /**
   * plane findMany
   */
  export type planeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * Filter, which planes to fetch.
     */
    where?: planeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planes to fetch.
     */
    orderBy?: planeOrderByWithRelationInput | planeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planes.
     */
    cursor?: planeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planes.
     */
    skip?: number
    distinct?: PlaneScalarFieldEnum | PlaneScalarFieldEnum[]
  }

  /**
   * plane create
   */
  export type planeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * The data needed to create a plane.
     */
    data: XOR<planeCreateInput, planeUncheckedCreateInput>
  }

  /**
   * plane createMany
   */
  export type planeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many planes.
     */
    data: planeCreateManyInput | planeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plane update
   */
  export type planeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * The data needed to update a plane.
     */
    data: XOR<planeUpdateInput, planeUncheckedUpdateInput>
    /**
     * Choose, which plane to update.
     */
    where: planeWhereUniqueInput
  }

  /**
   * plane updateMany
   */
  export type planeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update planes.
     */
    data: XOR<planeUpdateManyMutationInput, planeUncheckedUpdateManyInput>
    /**
     * Filter which planes to update
     */
    where?: planeWhereInput
    /**
     * Limit how many planes to update.
     */
    limit?: number
  }

  /**
   * plane upsert
   */
  export type planeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * The filter to search for the plane to update in case it exists.
     */
    where: planeWhereUniqueInput
    /**
     * In case the plane found by the `where` argument doesn't exist, create a new plane with this data.
     */
    create: XOR<planeCreateInput, planeUncheckedCreateInput>
    /**
     * In case the plane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planeUpdateInput, planeUncheckedUpdateInput>
  }

  /**
   * plane delete
   */
  export type planeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    /**
     * Filter which plane to delete.
     */
    where: planeWhereUniqueInput
  }

  /**
   * plane deleteMany
   */
  export type planeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which planes to delete
     */
    where?: planeWhereInput
    /**
     * Limit how many planes to delete.
     */
    limit?: number
  }

  /**
   * plane.flight
   */
  export type plane$flightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    cursor?: flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * plane.seat
   */
  export type plane$seatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    where?: seatWhereInput
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    cursor?: seatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * plane without action
   */
  export type planeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
  }


  /**
   * Model reclamation
   */

  export type AggregateReclamation = {
    _count: ReclamationCountAggregateOutputType | null
    _min: ReclamationMinAggregateOutputType | null
    _max: ReclamationMaxAggregateOutputType | null
  }

  export type ReclamationMinAggregateOutputType = {
    id: string | null
    sujet: string | null
    description: string | null
    statut: string | null
    date_creation: Date | null
    reponse: string | null
    date_reponse: Date | null
    user_id: string | null
  }

  export type ReclamationMaxAggregateOutputType = {
    id: string | null
    sujet: string | null
    description: string | null
    statut: string | null
    date_creation: Date | null
    reponse: string | null
    date_reponse: Date | null
    user_id: string | null
  }

  export type ReclamationCountAggregateOutputType = {
    id: number
    sujet: number
    description: number
    statut: number
    date_creation: number
    reponse: number
    date_reponse: number
    user_id: number
    _all: number
  }


  export type ReclamationMinAggregateInputType = {
    id?: true
    sujet?: true
    description?: true
    statut?: true
    date_creation?: true
    reponse?: true
    date_reponse?: true
    user_id?: true
  }

  export type ReclamationMaxAggregateInputType = {
    id?: true
    sujet?: true
    description?: true
    statut?: true
    date_creation?: true
    reponse?: true
    date_reponse?: true
    user_id?: true
  }

  export type ReclamationCountAggregateInputType = {
    id?: true
    sujet?: true
    description?: true
    statut?: true
    date_creation?: true
    reponse?: true
    date_reponse?: true
    user_id?: true
    _all?: true
  }

  export type ReclamationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reclamation to aggregate.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: reclamationOrderByWithRelationInput | reclamationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reclamations
    **/
    _count?: true | ReclamationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReclamationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReclamationMaxAggregateInputType
  }

  export type GetReclamationAggregateType<T extends ReclamationAggregateArgs> = {
        [P in keyof T & keyof AggregateReclamation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReclamation[P]>
      : GetScalarType<T[P], AggregateReclamation[P]>
  }




  export type reclamationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reclamationWhereInput
    orderBy?: reclamationOrderByWithAggregationInput | reclamationOrderByWithAggregationInput[]
    by: ReclamationScalarFieldEnum[] | ReclamationScalarFieldEnum
    having?: reclamationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReclamationCountAggregateInputType | true
    _min?: ReclamationMinAggregateInputType
    _max?: ReclamationMaxAggregateInputType
  }

  export type ReclamationGroupByOutputType = {
    id: string
    sujet: string
    description: string
    statut: string
    date_creation: Date
    reponse: string | null
    date_reponse: Date | null
    user_id: string | null
    _count: ReclamationCountAggregateOutputType | null
    _min: ReclamationMinAggregateOutputType | null
    _max: ReclamationMaxAggregateOutputType | null
  }

  type GetReclamationGroupByPayload<T extends reclamationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReclamationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReclamationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReclamationGroupByOutputType[P]>
            : GetScalarType<T[P], ReclamationGroupByOutputType[P]>
        }
      >
    >


  export type reclamationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sujet?: boolean
    description?: boolean
    statut?: boolean
    date_creation?: boolean
    reponse?: boolean
    date_reponse?: boolean
    user_id?: boolean
    user?: boolean | reclamation$userArgs<ExtArgs>
  }, ExtArgs["result"]["reclamation"]>



  export type reclamationSelectScalar = {
    id?: boolean
    sujet?: boolean
    description?: boolean
    statut?: boolean
    date_creation?: boolean
    reponse?: boolean
    date_reponse?: boolean
    user_id?: boolean
  }

  export type reclamationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sujet" | "description" | "statut" | "date_creation" | "reponse" | "date_reponse" | "user_id", ExtArgs["result"]["reclamation"]>
  export type reclamationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | reclamation$userArgs<ExtArgs>
  }

  export type $reclamationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reclamation"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sujet: string
      description: string
      statut: string
      date_creation: Date
      reponse: string | null
      date_reponse: Date | null
      user_id: string | null
    }, ExtArgs["result"]["reclamation"]>
    composites: {}
  }

  type reclamationGetPayload<S extends boolean | null | undefined | reclamationDefaultArgs> = $Result.GetResult<Prisma.$reclamationPayload, S>

  type reclamationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reclamationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReclamationCountAggregateInputType | true
    }

  export interface reclamationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reclamation'], meta: { name: 'reclamation' } }
    /**
     * Find zero or one Reclamation that matches the filter.
     * @param {reclamationFindUniqueArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reclamationFindUniqueArgs>(args: SelectSubset<T, reclamationFindUniqueArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reclamation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reclamationFindUniqueOrThrowArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reclamationFindUniqueOrThrowArgs>(args: SelectSubset<T, reclamationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reclamation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationFindFirstArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reclamationFindFirstArgs>(args?: SelectSubset<T, reclamationFindFirstArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reclamation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationFindFirstOrThrowArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reclamationFindFirstOrThrowArgs>(args?: SelectSubset<T, reclamationFindFirstOrThrowArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reclamations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reclamations
     * const reclamations = await prisma.reclamation.findMany()
     * 
     * // Get first 10 Reclamations
     * const reclamations = await prisma.reclamation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reclamationWithIdOnly = await prisma.reclamation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reclamationFindManyArgs>(args?: SelectSubset<T, reclamationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reclamation.
     * @param {reclamationCreateArgs} args - Arguments to create a Reclamation.
     * @example
     * // Create one Reclamation
     * const Reclamation = await prisma.reclamation.create({
     *   data: {
     *     // ... data to create a Reclamation
     *   }
     * })
     * 
     */
    create<T extends reclamationCreateArgs>(args: SelectSubset<T, reclamationCreateArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reclamations.
     * @param {reclamationCreateManyArgs} args - Arguments to create many Reclamations.
     * @example
     * // Create many Reclamations
     * const reclamation = await prisma.reclamation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reclamationCreateManyArgs>(args?: SelectSubset<T, reclamationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reclamation.
     * @param {reclamationDeleteArgs} args - Arguments to delete one Reclamation.
     * @example
     * // Delete one Reclamation
     * const Reclamation = await prisma.reclamation.delete({
     *   where: {
     *     // ... filter to delete one Reclamation
     *   }
     * })
     * 
     */
    delete<T extends reclamationDeleteArgs>(args: SelectSubset<T, reclamationDeleteArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reclamation.
     * @param {reclamationUpdateArgs} args - Arguments to update one Reclamation.
     * @example
     * // Update one Reclamation
     * const reclamation = await prisma.reclamation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reclamationUpdateArgs>(args: SelectSubset<T, reclamationUpdateArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reclamations.
     * @param {reclamationDeleteManyArgs} args - Arguments to filter Reclamations to delete.
     * @example
     * // Delete a few Reclamations
     * const { count } = await prisma.reclamation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reclamationDeleteManyArgs>(args?: SelectSubset<T, reclamationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reclamations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reclamations
     * const reclamation = await prisma.reclamation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reclamationUpdateManyArgs>(args: SelectSubset<T, reclamationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reclamation.
     * @param {reclamationUpsertArgs} args - Arguments to update or create a Reclamation.
     * @example
     * // Update or create a Reclamation
     * const reclamation = await prisma.reclamation.upsert({
     *   create: {
     *     // ... data to create a Reclamation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reclamation we want to update
     *   }
     * })
     */
    upsert<T extends reclamationUpsertArgs>(args: SelectSubset<T, reclamationUpsertArgs<ExtArgs>>): Prisma__reclamationClient<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reclamations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationCountArgs} args - Arguments to filter Reclamations to count.
     * @example
     * // Count the number of Reclamations
     * const count = await prisma.reclamation.count({
     *   where: {
     *     // ... the filter for the Reclamations we want to count
     *   }
     * })
    **/
    count<T extends reclamationCountArgs>(
      args?: Subset<T, reclamationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReclamationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reclamation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReclamationAggregateArgs>(args: Subset<T, ReclamationAggregateArgs>): Prisma.PrismaPromise<GetReclamationAggregateType<T>>

    /**
     * Group by Reclamation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reclamationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reclamationGroupByArgs['orderBy'] }
        : { orderBy?: reclamationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reclamationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReclamationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reclamation model
   */
  readonly fields: reclamationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reclamation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reclamationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends reclamation$userArgs<ExtArgs> = {}>(args?: Subset<T, reclamation$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reclamation model
   */
  interface reclamationFieldRefs {
    readonly id: FieldRef<"reclamation", 'String'>
    readonly sujet: FieldRef<"reclamation", 'String'>
    readonly description: FieldRef<"reclamation", 'String'>
    readonly statut: FieldRef<"reclamation", 'String'>
    readonly date_creation: FieldRef<"reclamation", 'DateTime'>
    readonly reponse: FieldRef<"reclamation", 'String'>
    readonly date_reponse: FieldRef<"reclamation", 'DateTime'>
    readonly user_id: FieldRef<"reclamation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reclamation findUnique
   */
  export type reclamationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * Filter, which reclamation to fetch.
     */
    where: reclamationWhereUniqueInput
  }

  /**
   * reclamation findUniqueOrThrow
   */
  export type reclamationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * Filter, which reclamation to fetch.
     */
    where: reclamationWhereUniqueInput
  }

  /**
   * reclamation findFirst
   */
  export type reclamationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * Filter, which reclamation to fetch.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: reclamationOrderByWithRelationInput | reclamationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reclamations.
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reclamations.
     */
    distinct?: ReclamationScalarFieldEnum | ReclamationScalarFieldEnum[]
  }

  /**
   * reclamation findFirstOrThrow
   */
  export type reclamationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * Filter, which reclamation to fetch.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: reclamationOrderByWithRelationInput | reclamationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reclamations.
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reclamations.
     */
    distinct?: ReclamationScalarFieldEnum | ReclamationScalarFieldEnum[]
  }

  /**
   * reclamation findMany
   */
  export type reclamationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * Filter, which reclamations to fetch.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: reclamationOrderByWithRelationInput | reclamationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reclamations.
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    distinct?: ReclamationScalarFieldEnum | ReclamationScalarFieldEnum[]
  }

  /**
   * reclamation create
   */
  export type reclamationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * The data needed to create a reclamation.
     */
    data: XOR<reclamationCreateInput, reclamationUncheckedCreateInput>
  }

  /**
   * reclamation createMany
   */
  export type reclamationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reclamations.
     */
    data: reclamationCreateManyInput | reclamationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reclamation update
   */
  export type reclamationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * The data needed to update a reclamation.
     */
    data: XOR<reclamationUpdateInput, reclamationUncheckedUpdateInput>
    /**
     * Choose, which reclamation to update.
     */
    where: reclamationWhereUniqueInput
  }

  /**
   * reclamation updateMany
   */
  export type reclamationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reclamations.
     */
    data: XOR<reclamationUpdateManyMutationInput, reclamationUncheckedUpdateManyInput>
    /**
     * Filter which reclamations to update
     */
    where?: reclamationWhereInput
    /**
     * Limit how many reclamations to update.
     */
    limit?: number
  }

  /**
   * reclamation upsert
   */
  export type reclamationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * The filter to search for the reclamation to update in case it exists.
     */
    where: reclamationWhereUniqueInput
    /**
     * In case the reclamation found by the `where` argument doesn't exist, create a new reclamation with this data.
     */
    create: XOR<reclamationCreateInput, reclamationUncheckedCreateInput>
    /**
     * In case the reclamation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reclamationUpdateInput, reclamationUncheckedUpdateInput>
  }

  /**
   * reclamation delete
   */
  export type reclamationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    /**
     * Filter which reclamation to delete.
     */
    where: reclamationWhereUniqueInput
  }

  /**
   * reclamation deleteMany
   */
  export type reclamationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reclamations to delete
     */
    where?: reclamationWhereInput
    /**
     * Limit how many reclamations to delete.
     */
    limit?: number
  }

  /**
   * reclamation.user
   */
  export type reclamation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * reclamation without action
   */
  export type reclamationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
  }


  /**
   * Model request_solde
   */

  export type AggregateRequest_solde = {
    _count: Request_soldeCountAggregateOutputType | null
    _avg: Request_soldeAvgAggregateOutputType | null
    _sum: Request_soldeSumAggregateOutputType | null
    _min: Request_soldeMinAggregateOutputType | null
    _max: Request_soldeMaxAggregateOutputType | null
  }

  export type Request_soldeAvgAggregateOutputType = {
    montant: Decimal | null
  }

  export type Request_soldeSumAggregateOutputType = {
    montant: Decimal | null
  }

  export type Request_soldeMinAggregateOutputType = {
    id: string | null
    montant: Decimal | null
    description: string | null
    date: Date | null
    status: $Enums.request_solde_status | null
    imageUrl: string | null
    client_id: string | null
  }

  export type Request_soldeMaxAggregateOutputType = {
    id: string | null
    montant: Decimal | null
    description: string | null
    date: Date | null
    status: $Enums.request_solde_status | null
    imageUrl: string | null
    client_id: string | null
  }

  export type Request_soldeCountAggregateOutputType = {
    id: number
    montant: number
    description: number
    date: number
    status: number
    imageUrl: number
    client_id: number
    _all: number
  }


  export type Request_soldeAvgAggregateInputType = {
    montant?: true
  }

  export type Request_soldeSumAggregateInputType = {
    montant?: true
  }

  export type Request_soldeMinAggregateInputType = {
    id?: true
    montant?: true
    description?: true
    date?: true
    status?: true
    imageUrl?: true
    client_id?: true
  }

  export type Request_soldeMaxAggregateInputType = {
    id?: true
    montant?: true
    description?: true
    date?: true
    status?: true
    imageUrl?: true
    client_id?: true
  }

  export type Request_soldeCountAggregateInputType = {
    id?: true
    montant?: true
    description?: true
    date?: true
    status?: true
    imageUrl?: true
    client_id?: true
    _all?: true
  }

  export type Request_soldeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which request_solde to aggregate.
     */
    where?: request_soldeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_soldes to fetch.
     */
    orderBy?: request_soldeOrderByWithRelationInput | request_soldeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: request_soldeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_soldes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_soldes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned request_soldes
    **/
    _count?: true | Request_soldeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Request_soldeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Request_soldeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Request_soldeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Request_soldeMaxAggregateInputType
  }

  export type GetRequest_soldeAggregateType<T extends Request_soldeAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest_solde]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest_solde[P]>
      : GetScalarType<T[P], AggregateRequest_solde[P]>
  }




  export type request_soldeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: request_soldeWhereInput
    orderBy?: request_soldeOrderByWithAggregationInput | request_soldeOrderByWithAggregationInput[]
    by: Request_soldeScalarFieldEnum[] | Request_soldeScalarFieldEnum
    having?: request_soldeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Request_soldeCountAggregateInputType | true
    _avg?: Request_soldeAvgAggregateInputType
    _sum?: Request_soldeSumAggregateInputType
    _min?: Request_soldeMinAggregateInputType
    _max?: Request_soldeMaxAggregateInputType
  }

  export type Request_soldeGroupByOutputType = {
    id: string
    montant: Decimal
    description: string | null
    date: Date
    status: $Enums.request_solde_status
    imageUrl: string | null
    client_id: string | null
    _count: Request_soldeCountAggregateOutputType | null
    _avg: Request_soldeAvgAggregateOutputType | null
    _sum: Request_soldeSumAggregateOutputType | null
    _min: Request_soldeMinAggregateOutputType | null
    _max: Request_soldeMaxAggregateOutputType | null
  }

  type GetRequest_soldeGroupByPayload<T extends request_soldeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Request_soldeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Request_soldeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Request_soldeGroupByOutputType[P]>
            : GetScalarType<T[P], Request_soldeGroupByOutputType[P]>
        }
      >
    >


  export type request_soldeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    montant?: boolean
    description?: boolean
    date?: boolean
    status?: boolean
    imageUrl?: boolean
    client_id?: boolean
    user?: boolean | request_solde$userArgs<ExtArgs>
  }, ExtArgs["result"]["request_solde"]>



  export type request_soldeSelectScalar = {
    id?: boolean
    montant?: boolean
    description?: boolean
    date?: boolean
    status?: boolean
    imageUrl?: boolean
    client_id?: boolean
  }

  export type request_soldeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "montant" | "description" | "date" | "status" | "imageUrl" | "client_id", ExtArgs["result"]["request_solde"]>
  export type request_soldeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | request_solde$userArgs<ExtArgs>
  }

  export type $request_soldePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "request_solde"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      montant: Prisma.Decimal
      description: string | null
      date: Date
      status: $Enums.request_solde_status
      imageUrl: string | null
      client_id: string | null
    }, ExtArgs["result"]["request_solde"]>
    composites: {}
  }

  type request_soldeGetPayload<S extends boolean | null | undefined | request_soldeDefaultArgs> = $Result.GetResult<Prisma.$request_soldePayload, S>

  type request_soldeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<request_soldeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Request_soldeCountAggregateInputType | true
    }

  export interface request_soldeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['request_solde'], meta: { name: 'request_solde' } }
    /**
     * Find zero or one Request_solde that matches the filter.
     * @param {request_soldeFindUniqueArgs} args - Arguments to find a Request_solde
     * @example
     * // Get one Request_solde
     * const request_solde = await prisma.request_solde.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends request_soldeFindUniqueArgs>(args: SelectSubset<T, request_soldeFindUniqueArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Request_solde that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {request_soldeFindUniqueOrThrowArgs} args - Arguments to find a Request_solde
     * @example
     * // Get one Request_solde
     * const request_solde = await prisma.request_solde.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends request_soldeFindUniqueOrThrowArgs>(args: SelectSubset<T, request_soldeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request_solde that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_soldeFindFirstArgs} args - Arguments to find a Request_solde
     * @example
     * // Get one Request_solde
     * const request_solde = await prisma.request_solde.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends request_soldeFindFirstArgs>(args?: SelectSubset<T, request_soldeFindFirstArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request_solde that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_soldeFindFirstOrThrowArgs} args - Arguments to find a Request_solde
     * @example
     * // Get one Request_solde
     * const request_solde = await prisma.request_solde.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends request_soldeFindFirstOrThrowArgs>(args?: SelectSubset<T, request_soldeFindFirstOrThrowArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Request_soldes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_soldeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Request_soldes
     * const request_soldes = await prisma.request_solde.findMany()
     * 
     * // Get first 10 Request_soldes
     * const request_soldes = await prisma.request_solde.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const request_soldeWithIdOnly = await prisma.request_solde.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends request_soldeFindManyArgs>(args?: SelectSubset<T, request_soldeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Request_solde.
     * @param {request_soldeCreateArgs} args - Arguments to create a Request_solde.
     * @example
     * // Create one Request_solde
     * const Request_solde = await prisma.request_solde.create({
     *   data: {
     *     // ... data to create a Request_solde
     *   }
     * })
     * 
     */
    create<T extends request_soldeCreateArgs>(args: SelectSubset<T, request_soldeCreateArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Request_soldes.
     * @param {request_soldeCreateManyArgs} args - Arguments to create many Request_soldes.
     * @example
     * // Create many Request_soldes
     * const request_solde = await prisma.request_solde.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends request_soldeCreateManyArgs>(args?: SelectSubset<T, request_soldeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Request_solde.
     * @param {request_soldeDeleteArgs} args - Arguments to delete one Request_solde.
     * @example
     * // Delete one Request_solde
     * const Request_solde = await prisma.request_solde.delete({
     *   where: {
     *     // ... filter to delete one Request_solde
     *   }
     * })
     * 
     */
    delete<T extends request_soldeDeleteArgs>(args: SelectSubset<T, request_soldeDeleteArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Request_solde.
     * @param {request_soldeUpdateArgs} args - Arguments to update one Request_solde.
     * @example
     * // Update one Request_solde
     * const request_solde = await prisma.request_solde.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends request_soldeUpdateArgs>(args: SelectSubset<T, request_soldeUpdateArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Request_soldes.
     * @param {request_soldeDeleteManyArgs} args - Arguments to filter Request_soldes to delete.
     * @example
     * // Delete a few Request_soldes
     * const { count } = await prisma.request_solde.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends request_soldeDeleteManyArgs>(args?: SelectSubset<T, request_soldeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Request_soldes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_soldeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Request_soldes
     * const request_solde = await prisma.request_solde.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends request_soldeUpdateManyArgs>(args: SelectSubset<T, request_soldeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Request_solde.
     * @param {request_soldeUpsertArgs} args - Arguments to update or create a Request_solde.
     * @example
     * // Update or create a Request_solde
     * const request_solde = await prisma.request_solde.upsert({
     *   create: {
     *     // ... data to create a Request_solde
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request_solde we want to update
     *   }
     * })
     */
    upsert<T extends request_soldeUpsertArgs>(args: SelectSubset<T, request_soldeUpsertArgs<ExtArgs>>): Prisma__request_soldeClient<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Request_soldes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_soldeCountArgs} args - Arguments to filter Request_soldes to count.
     * @example
     * // Count the number of Request_soldes
     * const count = await prisma.request_solde.count({
     *   where: {
     *     // ... the filter for the Request_soldes we want to count
     *   }
     * })
    **/
    count<T extends request_soldeCountArgs>(
      args?: Subset<T, request_soldeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Request_soldeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request_solde.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Request_soldeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Request_soldeAggregateArgs>(args: Subset<T, Request_soldeAggregateArgs>): Prisma.PrismaPromise<GetRequest_soldeAggregateType<T>>

    /**
     * Group by Request_solde.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_soldeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends request_soldeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: request_soldeGroupByArgs['orderBy'] }
        : { orderBy?: request_soldeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, request_soldeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequest_soldeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the request_solde model
   */
  readonly fields: request_soldeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for request_solde.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__request_soldeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends request_solde$userArgs<ExtArgs> = {}>(args?: Subset<T, request_solde$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the request_solde model
   */
  interface request_soldeFieldRefs {
    readonly id: FieldRef<"request_solde", 'String'>
    readonly montant: FieldRef<"request_solde", 'Decimal'>
    readonly description: FieldRef<"request_solde", 'String'>
    readonly date: FieldRef<"request_solde", 'DateTime'>
    readonly status: FieldRef<"request_solde", 'request_solde_status'>
    readonly imageUrl: FieldRef<"request_solde", 'String'>
    readonly client_id: FieldRef<"request_solde", 'String'>
  }
    

  // Custom InputTypes
  /**
   * request_solde findUnique
   */
  export type request_soldeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * Filter, which request_solde to fetch.
     */
    where: request_soldeWhereUniqueInput
  }

  /**
   * request_solde findUniqueOrThrow
   */
  export type request_soldeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * Filter, which request_solde to fetch.
     */
    where: request_soldeWhereUniqueInput
  }

  /**
   * request_solde findFirst
   */
  export type request_soldeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * Filter, which request_solde to fetch.
     */
    where?: request_soldeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_soldes to fetch.
     */
    orderBy?: request_soldeOrderByWithRelationInput | request_soldeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for request_soldes.
     */
    cursor?: request_soldeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_soldes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_soldes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of request_soldes.
     */
    distinct?: Request_soldeScalarFieldEnum | Request_soldeScalarFieldEnum[]
  }

  /**
   * request_solde findFirstOrThrow
   */
  export type request_soldeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * Filter, which request_solde to fetch.
     */
    where?: request_soldeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_soldes to fetch.
     */
    orderBy?: request_soldeOrderByWithRelationInput | request_soldeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for request_soldes.
     */
    cursor?: request_soldeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_soldes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_soldes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of request_soldes.
     */
    distinct?: Request_soldeScalarFieldEnum | Request_soldeScalarFieldEnum[]
  }

  /**
   * request_solde findMany
   */
  export type request_soldeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * Filter, which request_soldes to fetch.
     */
    where?: request_soldeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_soldes to fetch.
     */
    orderBy?: request_soldeOrderByWithRelationInput | request_soldeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing request_soldes.
     */
    cursor?: request_soldeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_soldes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_soldes.
     */
    skip?: number
    distinct?: Request_soldeScalarFieldEnum | Request_soldeScalarFieldEnum[]
  }

  /**
   * request_solde create
   */
  export type request_soldeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * The data needed to create a request_solde.
     */
    data: XOR<request_soldeCreateInput, request_soldeUncheckedCreateInput>
  }

  /**
   * request_solde createMany
   */
  export type request_soldeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many request_soldes.
     */
    data: request_soldeCreateManyInput | request_soldeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * request_solde update
   */
  export type request_soldeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * The data needed to update a request_solde.
     */
    data: XOR<request_soldeUpdateInput, request_soldeUncheckedUpdateInput>
    /**
     * Choose, which request_solde to update.
     */
    where: request_soldeWhereUniqueInput
  }

  /**
   * request_solde updateMany
   */
  export type request_soldeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update request_soldes.
     */
    data: XOR<request_soldeUpdateManyMutationInput, request_soldeUncheckedUpdateManyInput>
    /**
     * Filter which request_soldes to update
     */
    where?: request_soldeWhereInput
    /**
     * Limit how many request_soldes to update.
     */
    limit?: number
  }

  /**
   * request_solde upsert
   */
  export type request_soldeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * The filter to search for the request_solde to update in case it exists.
     */
    where: request_soldeWhereUniqueInput
    /**
     * In case the request_solde found by the `where` argument doesn't exist, create a new request_solde with this data.
     */
    create: XOR<request_soldeCreateInput, request_soldeUncheckedCreateInput>
    /**
     * In case the request_solde was found with the provided `where` argument, update it with this data.
     */
    update: XOR<request_soldeUpdateInput, request_soldeUncheckedUpdateInput>
  }

  /**
   * request_solde delete
   */
  export type request_soldeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    /**
     * Filter which request_solde to delete.
     */
    where: request_soldeWhereUniqueInput
  }

  /**
   * request_solde deleteMany
   */
  export type request_soldeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which request_soldes to delete
     */
    where?: request_soldeWhereInput
    /**
     * Limit how many request_soldes to delete.
     */
    limit?: number
  }

  /**
   * request_solde.user
   */
  export type request_solde$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * request_solde without action
   */
  export type request_soldeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
  }


  /**
   * Model reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    prix_total: Decimal | null
    nombre_passagers: number | null
    discount_amount: Decimal | null
  }

  export type ReservationSumAggregateOutputType = {
    prix_total: Decimal | null
    nombre_passagers: number | null
    discount_amount: Decimal | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    date_reservation: Date | null
    statut: string | null
    prix_total: Decimal | null
    nombre_passagers: number | null
    coupon_code: string | null
    discount_amount: Decimal | null
    class_type: string | null
    fare_type: string | null
    user_id: string | null
    flight_id: string | null
    coupon_id: string | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    date_reservation: Date | null
    statut: string | null
    prix_total: Decimal | null
    nombre_passagers: number | null
    coupon_code: string | null
    discount_amount: Decimal | null
    class_type: string | null
    fare_type: string | null
    user_id: string | null
    flight_id: string | null
    coupon_id: string | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    date_reservation: number
    statut: number
    prix_total: number
    nombre_passagers: number
    coupon_code: number
    discount_amount: number
    class_type: number
    fare_type: number
    user_id: number
    flight_id: number
    coupon_id: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    prix_total?: true
    nombre_passagers?: true
    discount_amount?: true
  }

  export type ReservationSumAggregateInputType = {
    prix_total?: true
    nombre_passagers?: true
    discount_amount?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    date_reservation?: true
    statut?: true
    prix_total?: true
    nombre_passagers?: true
    coupon_code?: true
    discount_amount?: true
    class_type?: true
    fare_type?: true
    user_id?: true
    flight_id?: true
    coupon_id?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    date_reservation?: true
    statut?: true
    prix_total?: true
    nombre_passagers?: true
    coupon_code?: true
    discount_amount?: true
    class_type?: true
    fare_type?: true
    user_id?: true
    flight_id?: true
    coupon_id?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    date_reservation?: true
    statut?: true
    prix_total?: true
    nombre_passagers?: true
    coupon_code?: true
    discount_amount?: true
    class_type?: true
    fare_type?: true
    user_id?: true
    flight_id?: true
    coupon_id?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reservation to aggregate.
     */
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type reservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservationWhereInput
    orderBy?: reservationOrderByWithAggregationInput | reservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: reservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    date_reservation: Date
    statut: string
    prix_total: Decimal
    nombre_passagers: number
    coupon_code: string | null
    discount_amount: Decimal | null
    class_type: string
    fare_type: string
    user_id: string | null
    flight_id: string | null
    coupon_id: string | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends reservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type reservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_reservation?: boolean
    statut?: boolean
    prix_total?: boolean
    nombre_passagers?: boolean
    coupon_code?: boolean
    discount_amount?: boolean
    class_type?: boolean
    fare_type?: boolean
    user_id?: boolean
    flight_id?: boolean
    coupon_id?: boolean
    flight_seat_reservation?: boolean | reservation$flight_seat_reservationArgs<ExtArgs>
    flight?: boolean | reservation$flightArgs<ExtArgs>
    coupon?: boolean | reservation$couponArgs<ExtArgs>
    user?: boolean | reservation$userArgs<ExtArgs>
    seat_reservation?: boolean | reservation$seat_reservationArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>



  export type reservationSelectScalar = {
    id?: boolean
    date_reservation?: boolean
    statut?: boolean
    prix_total?: boolean
    nombre_passagers?: boolean
    coupon_code?: boolean
    discount_amount?: boolean
    class_type?: boolean
    fare_type?: boolean
    user_id?: boolean
    flight_id?: boolean
    coupon_id?: boolean
  }

  export type reservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date_reservation" | "statut" | "prix_total" | "nombre_passagers" | "coupon_code" | "discount_amount" | "class_type" | "fare_type" | "user_id" | "flight_id" | "coupon_id", ExtArgs["result"]["reservation"]>
  export type reservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight_seat_reservation?: boolean | reservation$flight_seat_reservationArgs<ExtArgs>
    flight?: boolean | reservation$flightArgs<ExtArgs>
    coupon?: boolean | reservation$couponArgs<ExtArgs>
    user?: boolean | reservation$userArgs<ExtArgs>
    seat_reservation?: boolean | reservation$seat_reservationArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $reservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reservation"
    objects: {
      flight_seat_reservation: Prisma.$flight_seat_reservationPayload<ExtArgs>[]
      flight: Prisma.$flightPayload<ExtArgs> | null
      coupon: Prisma.$couponPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
      seat_reservation: Prisma.$seat_reservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date_reservation: Date
      statut: string
      prix_total: Prisma.Decimal
      nombre_passagers: number
      coupon_code: string | null
      discount_amount: Prisma.Decimal | null
      class_type: string
      fare_type: string
      user_id: string | null
      flight_id: string | null
      coupon_id: string | null
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type reservationGetPayload<S extends boolean | null | undefined | reservationDefaultArgs> = $Result.GetResult<Prisma.$reservationPayload, S>

  type reservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface reservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reservation'], meta: { name: 'reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {reservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reservationFindUniqueArgs>(args: SelectSubset<T, reservationFindUniqueArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reservationFindUniqueOrThrowArgs>(args: SelectSubset<T, reservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reservationFindFirstArgs>(args?: SelectSubset<T, reservationFindFirstArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reservationFindFirstOrThrowArgs>(args?: SelectSubset<T, reservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reservationFindManyArgs>(args?: SelectSubset<T, reservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {reservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends reservationCreateArgs>(args: SelectSubset<T, reservationCreateArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {reservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reservationCreateManyArgs>(args?: SelectSubset<T, reservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reservation.
     * @param {reservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends reservationDeleteArgs>(args: SelectSubset<T, reservationDeleteArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {reservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reservationUpdateArgs>(args: SelectSubset<T, reservationUpdateArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {reservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reservationDeleteManyArgs>(args?: SelectSubset<T, reservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reservationUpdateManyArgs>(args: SelectSubset<T, reservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {reservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends reservationUpsertArgs>(args: SelectSubset<T, reservationUpsertArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends reservationCountArgs>(
      args?: Subset<T, reservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reservationGroupByArgs['orderBy'] }
        : { orderBy?: reservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reservation model
   */
  readonly fields: reservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flight_seat_reservation<T extends reservation$flight_seat_reservationArgs<ExtArgs> = {}>(args?: Subset<T, reservation$flight_seat_reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flight<T extends reservation$flightArgs<ExtArgs> = {}>(args?: Subset<T, reservation$flightArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coupon<T extends reservation$couponArgs<ExtArgs> = {}>(args?: Subset<T, reservation$couponArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends reservation$userArgs<ExtArgs> = {}>(args?: Subset<T, reservation$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seat_reservation<T extends reservation$seat_reservationArgs<ExtArgs> = {}>(args?: Subset<T, reservation$seat_reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reservation model
   */
  interface reservationFieldRefs {
    readonly id: FieldRef<"reservation", 'String'>
    readonly date_reservation: FieldRef<"reservation", 'DateTime'>
    readonly statut: FieldRef<"reservation", 'String'>
    readonly prix_total: FieldRef<"reservation", 'Decimal'>
    readonly nombre_passagers: FieldRef<"reservation", 'Int'>
    readonly coupon_code: FieldRef<"reservation", 'String'>
    readonly discount_amount: FieldRef<"reservation", 'Decimal'>
    readonly class_type: FieldRef<"reservation", 'String'>
    readonly fare_type: FieldRef<"reservation", 'String'>
    readonly user_id: FieldRef<"reservation", 'String'>
    readonly flight_id: FieldRef<"reservation", 'String'>
    readonly coupon_id: FieldRef<"reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reservation findUnique
   */
  export type reservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * Filter, which reservation to fetch.
     */
    where: reservationWhereUniqueInput
  }

  /**
   * reservation findUniqueOrThrow
   */
  export type reservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * Filter, which reservation to fetch.
     */
    where: reservationWhereUniqueInput
  }

  /**
   * reservation findFirst
   */
  export type reservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * Filter, which reservation to fetch.
     */
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     */
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * reservation findFirstOrThrow
   */
  export type reservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * Filter, which reservation to fetch.
     */
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     */
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * reservation findMany
   */
  export type reservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reservations.
     */
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * reservation create
   */
  export type reservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * The data needed to create a reservation.
     */
    data: XOR<reservationCreateInput, reservationUncheckedCreateInput>
  }

  /**
   * reservation createMany
   */
  export type reservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reservations.
     */
    data: reservationCreateManyInput | reservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reservation update
   */
  export type reservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * The data needed to update a reservation.
     */
    data: XOR<reservationUpdateInput, reservationUncheckedUpdateInput>
    /**
     * Choose, which reservation to update.
     */
    where: reservationWhereUniqueInput
  }

  /**
   * reservation updateMany
   */
  export type reservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reservations.
     */
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyInput>
    /**
     * Filter which reservations to update
     */
    where?: reservationWhereInput
    /**
     * Limit how many reservations to update.
     */
    limit?: number
  }

  /**
   * reservation upsert
   */
  export type reservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * The filter to search for the reservation to update in case it exists.
     */
    where: reservationWhereUniqueInput
    /**
     * In case the reservation found by the `where` argument doesn't exist, create a new reservation with this data.
     */
    create: XOR<reservationCreateInput, reservationUncheckedCreateInput>
    /**
     * In case the reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reservationUpdateInput, reservationUncheckedUpdateInput>
  }

  /**
   * reservation delete
   */
  export type reservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    /**
     * Filter which reservation to delete.
     */
    where: reservationWhereUniqueInput
  }

  /**
   * reservation deleteMany
   */
  export type reservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reservations to delete
     */
    where?: reservationWhereInput
    /**
     * Limit how many reservations to delete.
     */
    limit?: number
  }

  /**
   * reservation.flight_seat_reservation
   */
  export type reservation$flight_seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    where?: flight_seat_reservationWhereInput
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    cursor?: flight_seat_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Flight_seat_reservationScalarFieldEnum | Flight_seat_reservationScalarFieldEnum[]
  }

  /**
   * reservation.flight
   */
  export type reservation$flightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
  }

  /**
   * reservation.coupon
   */
  export type reservation$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    where?: couponWhereInput
  }

  /**
   * reservation.user
   */
  export type reservation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * reservation.seat_reservation
   */
  export type reservation$seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    where?: seat_reservationWhereInput
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    cursor?: seat_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Seat_reservationScalarFieldEnum | Seat_reservationScalarFieldEnum[]
  }

  /**
   * reservation without action
   */
  export type reservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
  }


  /**
   * Model seat
   */

  export type AggregateSeat = {
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  export type SeatAvgAggregateOutputType = {
    idSeat: number | null
    availability: number | null
    idPlane: number | null
  }

  export type SeatSumAggregateOutputType = {
    idSeat: number | null
    availability: number | null
    idPlane: number | null
  }

  export type SeatMinAggregateOutputType = {
    idSeat: number | null
    seatNumber: string | null
    classType: $Enums.seat_classType | null
    availability: number | null
    idPlane: number | null
  }

  export type SeatMaxAggregateOutputType = {
    idSeat: number | null
    seatNumber: string | null
    classType: $Enums.seat_classType | null
    availability: number | null
    idPlane: number | null
  }

  export type SeatCountAggregateOutputType = {
    idSeat: number
    seatNumber: number
    classType: number
    availability: number
    idPlane: number
    _all: number
  }


  export type SeatAvgAggregateInputType = {
    idSeat?: true
    availability?: true
    idPlane?: true
  }

  export type SeatSumAggregateInputType = {
    idSeat?: true
    availability?: true
    idPlane?: true
  }

  export type SeatMinAggregateInputType = {
    idSeat?: true
    seatNumber?: true
    classType?: true
    availability?: true
    idPlane?: true
  }

  export type SeatMaxAggregateInputType = {
    idSeat?: true
    seatNumber?: true
    classType?: true
    availability?: true
    idPlane?: true
  }

  export type SeatCountAggregateInputType = {
    idSeat?: true
    seatNumber?: true
    classType?: true
    availability?: true
    idPlane?: true
    _all?: true
  }

  export type SeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seat to aggregate.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seats
    **/
    _count?: true | SeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatMaxAggregateInputType
  }

  export type GetSeatAggregateType<T extends SeatAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat[P]>
      : GetScalarType<T[P], AggregateSeat[P]>
  }




  export type seatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seatWhereInput
    orderBy?: seatOrderByWithAggregationInput | seatOrderByWithAggregationInput[]
    by: SeatScalarFieldEnum[] | SeatScalarFieldEnum
    having?: seatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatCountAggregateInputType | true
    _avg?: SeatAvgAggregateInputType
    _sum?: SeatSumAggregateInputType
    _min?: SeatMinAggregateInputType
    _max?: SeatMaxAggregateInputType
  }

  export type SeatGroupByOutputType = {
    idSeat: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability: number
    idPlane: number | null
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  type GetSeatGroupByPayload<T extends seatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatGroupByOutputType[P]>
            : GetScalarType<T[P], SeatGroupByOutputType[P]>
        }
      >
    >


  export type seatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeat?: boolean
    seatNumber?: boolean
    classType?: boolean
    availability?: boolean
    idPlane?: boolean
    flight_seat_reservation?: boolean | seat$flight_seat_reservationArgs<ExtArgs>
    plane?: boolean | seat$planeArgs<ExtArgs>
    seat_reservation?: boolean | seat$seat_reservationArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>



  export type seatSelectScalar = {
    idSeat?: boolean
    seatNumber?: boolean
    classType?: boolean
    availability?: boolean
    idPlane?: boolean
  }

  export type seatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSeat" | "seatNumber" | "classType" | "availability" | "idPlane", ExtArgs["result"]["seat"]>
  export type seatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight_seat_reservation?: boolean | seat$flight_seat_reservationArgs<ExtArgs>
    plane?: boolean | seat$planeArgs<ExtArgs>
    seat_reservation?: boolean | seat$seat_reservationArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $seatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seat"
    objects: {
      flight_seat_reservation: Prisma.$flight_seat_reservationPayload<ExtArgs>[]
      plane: Prisma.$planePayload<ExtArgs> | null
      seat_reservation: Prisma.$seat_reservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idSeat: number
      seatNumber: string
      classType: $Enums.seat_classType
      availability: number
      idPlane: number | null
    }, ExtArgs["result"]["seat"]>
    composites: {}
  }

  type seatGetPayload<S extends boolean | null | undefined | seatDefaultArgs> = $Result.GetResult<Prisma.$seatPayload, S>

  type seatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatCountAggregateInputType | true
    }

  export interface seatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seat'], meta: { name: 'seat' } }
    /**
     * Find zero or one Seat that matches the filter.
     * @param {seatFindUniqueArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seatFindUniqueArgs>(args: SelectSubset<T, seatFindUniqueArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seatFindUniqueOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seatFindUniqueOrThrowArgs>(args: SelectSubset<T, seatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatFindFirstArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seatFindFirstArgs>(args?: SelectSubset<T, seatFindFirstArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatFindFirstOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seatFindFirstOrThrowArgs>(args?: SelectSubset<T, seatFindFirstOrThrowArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seats
     * const seats = await prisma.seat.findMany()
     * 
     * // Get first 10 Seats
     * const seats = await prisma.seat.findMany({ take: 10 })
     * 
     * // Only select the `idSeat`
     * const seatWithIdSeatOnly = await prisma.seat.findMany({ select: { idSeat: true } })
     * 
     */
    findMany<T extends seatFindManyArgs>(args?: SelectSubset<T, seatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seat.
     * @param {seatCreateArgs} args - Arguments to create a Seat.
     * @example
     * // Create one Seat
     * const Seat = await prisma.seat.create({
     *   data: {
     *     // ... data to create a Seat
     *   }
     * })
     * 
     */
    create<T extends seatCreateArgs>(args: SelectSubset<T, seatCreateArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seats.
     * @param {seatCreateManyArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seatCreateManyArgs>(args?: SelectSubset<T, seatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seat.
     * @param {seatDeleteArgs} args - Arguments to delete one Seat.
     * @example
     * // Delete one Seat
     * const Seat = await prisma.seat.delete({
     *   where: {
     *     // ... filter to delete one Seat
     *   }
     * })
     * 
     */
    delete<T extends seatDeleteArgs>(args: SelectSubset<T, seatDeleteArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seat.
     * @param {seatUpdateArgs} args - Arguments to update one Seat.
     * @example
     * // Update one Seat
     * const seat = await prisma.seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seatUpdateArgs>(args: SelectSubset<T, seatUpdateArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seats.
     * @param {seatDeleteManyArgs} args - Arguments to filter Seats to delete.
     * @example
     * // Delete a few Seats
     * const { count } = await prisma.seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seatDeleteManyArgs>(args?: SelectSubset<T, seatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seatUpdateManyArgs>(args: SelectSubset<T, seatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seat.
     * @param {seatUpsertArgs} args - Arguments to update or create a Seat.
     * @example
     * // Update or create a Seat
     * const seat = await prisma.seat.upsert({
     *   create: {
     *     // ... data to create a Seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat we want to update
     *   }
     * })
     */
    upsert<T extends seatUpsertArgs>(args: SelectSubset<T, seatUpsertArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatCountArgs} args - Arguments to filter Seats to count.
     * @example
     * // Count the number of Seats
     * const count = await prisma.seat.count({
     *   where: {
     *     // ... the filter for the Seats we want to count
     *   }
     * })
    **/
    count<T extends seatCountArgs>(
      args?: Subset<T, seatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAggregateArgs>(args: Subset<T, SeatAggregateArgs>): Prisma.PrismaPromise<GetSeatAggregateType<T>>

    /**
     * Group by Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seatGroupByArgs['orderBy'] }
        : { orderBy?: seatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seat model
   */
  readonly fields: seatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flight_seat_reservation<T extends seat$flight_seat_reservationArgs<ExtArgs> = {}>(args?: Subset<T, seat$flight_seat_reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flight_seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plane<T extends seat$planeArgs<ExtArgs> = {}>(args?: Subset<T, seat$planeArgs<ExtArgs>>): Prisma__planeClient<$Result.GetResult<Prisma.$planePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seat_reservation<T extends seat$seat_reservationArgs<ExtArgs> = {}>(args?: Subset<T, seat$seat_reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seat model
   */
  interface seatFieldRefs {
    readonly idSeat: FieldRef<"seat", 'Int'>
    readonly seatNumber: FieldRef<"seat", 'String'>
    readonly classType: FieldRef<"seat", 'seat_classType'>
    readonly availability: FieldRef<"seat", 'Int'>
    readonly idPlane: FieldRef<"seat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * seat findUnique
   */
  export type seatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat findUniqueOrThrow
   */
  export type seatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat findFirst
   */
  export type seatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seats.
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seat findFirstOrThrow
   */
  export type seatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seats.
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seat findMany
   */
  export type seatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seats to fetch.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seats.
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seat create
   */
  export type seatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * The data needed to create a seat.
     */
    data: XOR<seatCreateInput, seatUncheckedCreateInput>
  }

  /**
   * seat createMany
   */
  export type seatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seats.
     */
    data: seatCreateManyInput | seatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seat update
   */
  export type seatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * The data needed to update a seat.
     */
    data: XOR<seatUpdateInput, seatUncheckedUpdateInput>
    /**
     * Choose, which seat to update.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat updateMany
   */
  export type seatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seats.
     */
    data: XOR<seatUpdateManyMutationInput, seatUncheckedUpdateManyInput>
    /**
     * Filter which seats to update
     */
    where?: seatWhereInput
    /**
     * Limit how many seats to update.
     */
    limit?: number
  }

  /**
   * seat upsert
   */
  export type seatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * The filter to search for the seat to update in case it exists.
     */
    where: seatWhereUniqueInput
    /**
     * In case the seat found by the `where` argument doesn't exist, create a new seat with this data.
     */
    create: XOR<seatCreateInput, seatUncheckedCreateInput>
    /**
     * In case the seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seatUpdateInput, seatUncheckedUpdateInput>
  }

  /**
   * seat delete
   */
  export type seatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter which seat to delete.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat deleteMany
   */
  export type seatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seats to delete
     */
    where?: seatWhereInput
    /**
     * Limit how many seats to delete.
     */
    limit?: number
  }

  /**
   * seat.flight_seat_reservation
   */
  export type seat$flight_seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight_seat_reservation
     */
    select?: flight_seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight_seat_reservation
     */
    omit?: flight_seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flight_seat_reservationInclude<ExtArgs> | null
    where?: flight_seat_reservationWhereInput
    orderBy?: flight_seat_reservationOrderByWithRelationInput | flight_seat_reservationOrderByWithRelationInput[]
    cursor?: flight_seat_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Flight_seat_reservationScalarFieldEnum | Flight_seat_reservationScalarFieldEnum[]
  }

  /**
   * seat.plane
   */
  export type seat$planeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plane
     */
    select?: planeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plane
     */
    omit?: planeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planeInclude<ExtArgs> | null
    where?: planeWhereInput
  }

  /**
   * seat.seat_reservation
   */
  export type seat$seat_reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    where?: seat_reservationWhereInput
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    cursor?: seat_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Seat_reservationScalarFieldEnum | Seat_reservationScalarFieldEnum[]
  }

  /**
   * seat without action
   */
  export type seatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
  }


  /**
   * Model seat_reservation
   */

  export type AggregateSeat_reservation = {
    _count: Seat_reservationCountAggregateOutputType | null
    _avg: Seat_reservationAvgAggregateOutputType | null
    _sum: Seat_reservationSumAggregateOutputType | null
    _min: Seat_reservationMinAggregateOutputType | null
    _max: Seat_reservationMaxAggregateOutputType | null
  }

  export type Seat_reservationAvgAggregateOutputType = {
    id: number | null
    seat_id: number | null
  }

  export type Seat_reservationSumAggregateOutputType = {
    id: number | null
    seat_id: number | null
  }

  export type Seat_reservationMinAggregateOutputType = {
    id: number | null
    seat_id: number | null
    reservation_id: string | null
    flight_id: string | null
  }

  export type Seat_reservationMaxAggregateOutputType = {
    id: number | null
    seat_id: number | null
    reservation_id: string | null
    flight_id: string | null
  }

  export type Seat_reservationCountAggregateOutputType = {
    id: number
    seat_id: number
    reservation_id: number
    flight_id: number
    _all: number
  }


  export type Seat_reservationAvgAggregateInputType = {
    id?: true
    seat_id?: true
  }

  export type Seat_reservationSumAggregateInputType = {
    id?: true
    seat_id?: true
  }

  export type Seat_reservationMinAggregateInputType = {
    id?: true
    seat_id?: true
    reservation_id?: true
    flight_id?: true
  }

  export type Seat_reservationMaxAggregateInputType = {
    id?: true
    seat_id?: true
    reservation_id?: true
    flight_id?: true
  }

  export type Seat_reservationCountAggregateInputType = {
    id?: true
    seat_id?: true
    reservation_id?: true
    flight_id?: true
    _all?: true
  }

  export type Seat_reservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seat_reservation to aggregate.
     */
    where?: seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seat_reservations to fetch.
     */
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seat_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seat_reservations
    **/
    _count?: true | Seat_reservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Seat_reservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Seat_reservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Seat_reservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Seat_reservationMaxAggregateInputType
  }

  export type GetSeat_reservationAggregateType<T extends Seat_reservationAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat_reservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat_reservation[P]>
      : GetScalarType<T[P], AggregateSeat_reservation[P]>
  }




  export type seat_reservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seat_reservationWhereInput
    orderBy?: seat_reservationOrderByWithAggregationInput | seat_reservationOrderByWithAggregationInput[]
    by: Seat_reservationScalarFieldEnum[] | Seat_reservationScalarFieldEnum
    having?: seat_reservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Seat_reservationCountAggregateInputType | true
    _avg?: Seat_reservationAvgAggregateInputType
    _sum?: Seat_reservationSumAggregateInputType
    _min?: Seat_reservationMinAggregateInputType
    _max?: Seat_reservationMaxAggregateInputType
  }

  export type Seat_reservationGroupByOutputType = {
    id: number
    seat_id: number | null
    reservation_id: string | null
    flight_id: string | null
    _count: Seat_reservationCountAggregateOutputType | null
    _avg: Seat_reservationAvgAggregateOutputType | null
    _sum: Seat_reservationSumAggregateOutputType | null
    _min: Seat_reservationMinAggregateOutputType | null
    _max: Seat_reservationMaxAggregateOutputType | null
  }

  type GetSeat_reservationGroupByPayload<T extends seat_reservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Seat_reservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Seat_reservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Seat_reservationGroupByOutputType[P]>
            : GetScalarType<T[P], Seat_reservationGroupByOutputType[P]>
        }
      >
    >


  export type seat_reservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seat_id?: boolean
    reservation_id?: boolean
    flight_id?: boolean
    flight?: boolean | seat_reservation$flightArgs<ExtArgs>
    reservation?: boolean | seat_reservation$reservationArgs<ExtArgs>
    seat?: boolean | seat_reservation$seatArgs<ExtArgs>
  }, ExtArgs["result"]["seat_reservation"]>



  export type seat_reservationSelectScalar = {
    id?: boolean
    seat_id?: boolean
    reservation_id?: boolean
    flight_id?: boolean
  }

  export type seat_reservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seat_id" | "reservation_id" | "flight_id", ExtArgs["result"]["seat_reservation"]>
  export type seat_reservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight?: boolean | seat_reservation$flightArgs<ExtArgs>
    reservation?: boolean | seat_reservation$reservationArgs<ExtArgs>
    seat?: boolean | seat_reservation$seatArgs<ExtArgs>
  }

  export type $seat_reservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seat_reservation"
    objects: {
      flight: Prisma.$flightPayload<ExtArgs> | null
      reservation: Prisma.$reservationPayload<ExtArgs> | null
      seat: Prisma.$seatPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seat_id: number | null
      reservation_id: string | null
      flight_id: string | null
    }, ExtArgs["result"]["seat_reservation"]>
    composites: {}
  }

  type seat_reservationGetPayload<S extends boolean | null | undefined | seat_reservationDefaultArgs> = $Result.GetResult<Prisma.$seat_reservationPayload, S>

  type seat_reservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seat_reservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Seat_reservationCountAggregateInputType | true
    }

  export interface seat_reservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seat_reservation'], meta: { name: 'seat_reservation' } }
    /**
     * Find zero or one Seat_reservation that matches the filter.
     * @param {seat_reservationFindUniqueArgs} args - Arguments to find a Seat_reservation
     * @example
     * // Get one Seat_reservation
     * const seat_reservation = await prisma.seat_reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seat_reservationFindUniqueArgs>(args: SelectSubset<T, seat_reservationFindUniqueArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seat_reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seat_reservationFindUniqueOrThrowArgs} args - Arguments to find a Seat_reservation
     * @example
     * // Get one Seat_reservation
     * const seat_reservation = await prisma.seat_reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seat_reservationFindUniqueOrThrowArgs>(args: SelectSubset<T, seat_reservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat_reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seat_reservationFindFirstArgs} args - Arguments to find a Seat_reservation
     * @example
     * // Get one Seat_reservation
     * const seat_reservation = await prisma.seat_reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seat_reservationFindFirstArgs>(args?: SelectSubset<T, seat_reservationFindFirstArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat_reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seat_reservationFindFirstOrThrowArgs} args - Arguments to find a Seat_reservation
     * @example
     * // Get one Seat_reservation
     * const seat_reservation = await prisma.seat_reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seat_reservationFindFirstOrThrowArgs>(args?: SelectSubset<T, seat_reservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seat_reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seat_reservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seat_reservations
     * const seat_reservations = await prisma.seat_reservation.findMany()
     * 
     * // Get first 10 Seat_reservations
     * const seat_reservations = await prisma.seat_reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seat_reservationWithIdOnly = await prisma.seat_reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends seat_reservationFindManyArgs>(args?: SelectSubset<T, seat_reservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seat_reservation.
     * @param {seat_reservationCreateArgs} args - Arguments to create a Seat_reservation.
     * @example
     * // Create one Seat_reservation
     * const Seat_reservation = await prisma.seat_reservation.create({
     *   data: {
     *     // ... data to create a Seat_reservation
     *   }
     * })
     * 
     */
    create<T extends seat_reservationCreateArgs>(args: SelectSubset<T, seat_reservationCreateArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seat_reservations.
     * @param {seat_reservationCreateManyArgs} args - Arguments to create many Seat_reservations.
     * @example
     * // Create many Seat_reservations
     * const seat_reservation = await prisma.seat_reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seat_reservationCreateManyArgs>(args?: SelectSubset<T, seat_reservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seat_reservation.
     * @param {seat_reservationDeleteArgs} args - Arguments to delete one Seat_reservation.
     * @example
     * // Delete one Seat_reservation
     * const Seat_reservation = await prisma.seat_reservation.delete({
     *   where: {
     *     // ... filter to delete one Seat_reservation
     *   }
     * })
     * 
     */
    delete<T extends seat_reservationDeleteArgs>(args: SelectSubset<T, seat_reservationDeleteArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seat_reservation.
     * @param {seat_reservationUpdateArgs} args - Arguments to update one Seat_reservation.
     * @example
     * // Update one Seat_reservation
     * const seat_reservation = await prisma.seat_reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seat_reservationUpdateArgs>(args: SelectSubset<T, seat_reservationUpdateArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seat_reservations.
     * @param {seat_reservationDeleteManyArgs} args - Arguments to filter Seat_reservations to delete.
     * @example
     * // Delete a few Seat_reservations
     * const { count } = await prisma.seat_reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seat_reservationDeleteManyArgs>(args?: SelectSubset<T, seat_reservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seat_reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seat_reservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seat_reservations
     * const seat_reservation = await prisma.seat_reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seat_reservationUpdateManyArgs>(args: SelectSubset<T, seat_reservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seat_reservation.
     * @param {seat_reservationUpsertArgs} args - Arguments to update or create a Seat_reservation.
     * @example
     * // Update or create a Seat_reservation
     * const seat_reservation = await prisma.seat_reservation.upsert({
     *   create: {
     *     // ... data to create a Seat_reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat_reservation we want to update
     *   }
     * })
     */
    upsert<T extends seat_reservationUpsertArgs>(args: SelectSubset<T, seat_reservationUpsertArgs<ExtArgs>>): Prisma__seat_reservationClient<$Result.GetResult<Prisma.$seat_reservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seat_reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seat_reservationCountArgs} args - Arguments to filter Seat_reservations to count.
     * @example
     * // Count the number of Seat_reservations
     * const count = await prisma.seat_reservation.count({
     *   where: {
     *     // ... the filter for the Seat_reservations we want to count
     *   }
     * })
    **/
    count<T extends seat_reservationCountArgs>(
      args?: Subset<T, seat_reservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Seat_reservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat_reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Seat_reservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Seat_reservationAggregateArgs>(args: Subset<T, Seat_reservationAggregateArgs>): Prisma.PrismaPromise<GetSeat_reservationAggregateType<T>>

    /**
     * Group by Seat_reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seat_reservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seat_reservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seat_reservationGroupByArgs['orderBy'] }
        : { orderBy?: seat_reservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seat_reservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeat_reservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seat_reservation model
   */
  readonly fields: seat_reservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seat_reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seat_reservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flight<T extends seat_reservation$flightArgs<ExtArgs> = {}>(args?: Subset<T, seat_reservation$flightArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservation<T extends seat_reservation$reservationArgs<ExtArgs> = {}>(args?: Subset<T, seat_reservation$reservationArgs<ExtArgs>>): Prisma__reservationClient<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seat<T extends seat_reservation$seatArgs<ExtArgs> = {}>(args?: Subset<T, seat_reservation$seatArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seat_reservation model
   */
  interface seat_reservationFieldRefs {
    readonly id: FieldRef<"seat_reservation", 'Int'>
    readonly seat_id: FieldRef<"seat_reservation", 'Int'>
    readonly reservation_id: FieldRef<"seat_reservation", 'String'>
    readonly flight_id: FieldRef<"seat_reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * seat_reservation findUnique
   */
  export type seat_reservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which seat_reservation to fetch.
     */
    where: seat_reservationWhereUniqueInput
  }

  /**
   * seat_reservation findUniqueOrThrow
   */
  export type seat_reservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which seat_reservation to fetch.
     */
    where: seat_reservationWhereUniqueInput
  }

  /**
   * seat_reservation findFirst
   */
  export type seat_reservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which seat_reservation to fetch.
     */
    where?: seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seat_reservations to fetch.
     */
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seat_reservations.
     */
    cursor?: seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seat_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seat_reservations.
     */
    distinct?: Seat_reservationScalarFieldEnum | Seat_reservationScalarFieldEnum[]
  }

  /**
   * seat_reservation findFirstOrThrow
   */
  export type seat_reservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which seat_reservation to fetch.
     */
    where?: seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seat_reservations to fetch.
     */
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seat_reservations.
     */
    cursor?: seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seat_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seat_reservations.
     */
    distinct?: Seat_reservationScalarFieldEnum | Seat_reservationScalarFieldEnum[]
  }

  /**
   * seat_reservation findMany
   */
  export type seat_reservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * Filter, which seat_reservations to fetch.
     */
    where?: seat_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seat_reservations to fetch.
     */
    orderBy?: seat_reservationOrderByWithRelationInput | seat_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seat_reservations.
     */
    cursor?: seat_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seat_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seat_reservations.
     */
    skip?: number
    distinct?: Seat_reservationScalarFieldEnum | Seat_reservationScalarFieldEnum[]
  }

  /**
   * seat_reservation create
   */
  export type seat_reservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * The data needed to create a seat_reservation.
     */
    data?: XOR<seat_reservationCreateInput, seat_reservationUncheckedCreateInput>
  }

  /**
   * seat_reservation createMany
   */
  export type seat_reservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seat_reservations.
     */
    data: seat_reservationCreateManyInput | seat_reservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seat_reservation update
   */
  export type seat_reservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * The data needed to update a seat_reservation.
     */
    data: XOR<seat_reservationUpdateInput, seat_reservationUncheckedUpdateInput>
    /**
     * Choose, which seat_reservation to update.
     */
    where: seat_reservationWhereUniqueInput
  }

  /**
   * seat_reservation updateMany
   */
  export type seat_reservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seat_reservations.
     */
    data: XOR<seat_reservationUpdateManyMutationInput, seat_reservationUncheckedUpdateManyInput>
    /**
     * Filter which seat_reservations to update
     */
    where?: seat_reservationWhereInput
    /**
     * Limit how many seat_reservations to update.
     */
    limit?: number
  }

  /**
   * seat_reservation upsert
   */
  export type seat_reservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * The filter to search for the seat_reservation to update in case it exists.
     */
    where: seat_reservationWhereUniqueInput
    /**
     * In case the seat_reservation found by the `where` argument doesn't exist, create a new seat_reservation with this data.
     */
    create: XOR<seat_reservationCreateInput, seat_reservationUncheckedCreateInput>
    /**
     * In case the seat_reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seat_reservationUpdateInput, seat_reservationUncheckedUpdateInput>
  }

  /**
   * seat_reservation delete
   */
  export type seat_reservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
    /**
     * Filter which seat_reservation to delete.
     */
    where: seat_reservationWhereUniqueInput
  }

  /**
   * seat_reservation deleteMany
   */
  export type seat_reservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seat_reservations to delete
     */
    where?: seat_reservationWhereInput
    /**
     * Limit how many seat_reservations to delete.
     */
    limit?: number
  }

  /**
   * seat_reservation.flight
   */
  export type seat_reservation$flightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
  }

  /**
   * seat_reservation.reservation
   */
  export type seat_reservation$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    where?: reservationWhereInput
  }

  /**
   * seat_reservation.seat
   */
  export type seat_reservation$seatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    where?: seatWhereInput
  }

  /**
   * seat_reservation without action
   */
  export type seat_reservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat_reservation
     */
    select?: seat_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat_reservation
     */
    omit?: seat_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seat_reservationInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    est_admin: number | null
  }

  export type UserSumAggregateOutputType = {
    est_admin: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    nom: string | null
    email: string | null
    numero_telephone: string | null
    pays: string | null
    adresse: string | null
    est_admin: number | null
    mot_de_passe: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    email: string | null
    numero_telephone: string | null
    pays: string | null
    adresse: string | null
    est_admin: number | null
    mot_de_passe: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    numero_telephone: number
    pays: number
    adresse: number
    est_admin: number
    mot_de_passe: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    est_admin?: true
  }

  export type UserSumAggregateInputType = {
    est_admin?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    numero_telephone?: true
    pays?: true
    adresse?: true
    est_admin?: true
    mot_de_passe?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    numero_telephone?: true
    pays?: true
    adresse?: true
    est_admin?: true
    mot_de_passe?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    numero_telephone?: true
    pays?: true
    adresse?: true
    est_admin?: true
    mot_de_passe?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    nom: string
    email: string
    numero_telephone: string | null
    pays: string | null
    adresse: string | null
    est_admin: number
    mot_de_passe: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    numero_telephone?: boolean
    pays?: boolean
    adresse?: boolean
    est_admin?: boolean
    mot_de_passe?: boolean
    compte?: boolean | user$compteArgs<ExtArgs>
    contract?: boolean | user$contractArgs<ExtArgs>
    reclamation?: boolean | user$reclamationArgs<ExtArgs>
    request_solde?: boolean | user$request_soldeArgs<ExtArgs>
    reservation?: boolean | user$reservationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    numero_telephone?: boolean
    pays?: boolean
    adresse?: boolean
    est_admin?: boolean
    mot_de_passe?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "email" | "numero_telephone" | "pays" | "adresse" | "est_admin" | "mot_de_passe", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compte?: boolean | user$compteArgs<ExtArgs>
    contract?: boolean | user$contractArgs<ExtArgs>
    reclamation?: boolean | user$reclamationArgs<ExtArgs>
    request_solde?: boolean | user$request_soldeArgs<ExtArgs>
    reservation?: boolean | user$reservationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      compte: Prisma.$comptePayload<ExtArgs> | null
      contract: Prisma.$contractPayload<ExtArgs>[]
      reclamation: Prisma.$reclamationPayload<ExtArgs>[]
      request_solde: Prisma.$request_soldePayload<ExtArgs>[]
      reservation: Prisma.$reservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      email: string
      numero_telephone: string | null
      pays: string | null
      adresse: string | null
      est_admin: number
      mot_de_passe: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compte<T extends user$compteArgs<ExtArgs> = {}>(args?: Subset<T, user$compteArgs<ExtArgs>>): Prisma__compteClient<$Result.GetResult<Prisma.$comptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contract<T extends user$contractArgs<ExtArgs> = {}>(args?: Subset<T, user$contractArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reclamation<T extends user$reclamationArgs<ExtArgs> = {}>(args?: Subset<T, user$reclamationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reclamationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    request_solde<T extends user$request_soldeArgs<ExtArgs> = {}>(args?: Subset<T, user$request_soldeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$request_soldePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservation<T extends user$reservationArgs<ExtArgs> = {}>(args?: Subset<T, user$reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly nom: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly numero_telephone: FieldRef<"user", 'String'>
    readonly pays: FieldRef<"user", 'String'>
    readonly adresse: FieldRef<"user", 'String'>
    readonly est_admin: FieldRef<"user", 'Int'>
    readonly mot_de_passe: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.compte
   */
  export type user$compteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compte
     */
    select?: compteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compte
     */
    omit?: compteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compteInclude<ExtArgs> | null
    where?: compteWhereInput
  }

  /**
   * user.contract
   */
  export type user$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contract
     */
    select?: contractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contract
     */
    omit?: contractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractInclude<ExtArgs> | null
    where?: contractWhereInput
    orderBy?: contractOrderByWithRelationInput | contractOrderByWithRelationInput[]
    cursor?: contractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * user.reclamation
   */
  export type user$reclamationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reclamation
     */
    omit?: reclamationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reclamationInclude<ExtArgs> | null
    where?: reclamationWhereInput
    orderBy?: reclamationOrderByWithRelationInput | reclamationOrderByWithRelationInput[]
    cursor?: reclamationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReclamationScalarFieldEnum | ReclamationScalarFieldEnum[]
  }

  /**
   * user.request_solde
   */
  export type user$request_soldeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_solde
     */
    select?: request_soldeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_solde
     */
    omit?: request_soldeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: request_soldeInclude<ExtArgs> | null
    where?: request_soldeWhereInput
    orderBy?: request_soldeOrderByWithRelationInput | request_soldeOrderByWithRelationInput[]
    cursor?: request_soldeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Request_soldeScalarFieldEnum | Request_soldeScalarFieldEnum[]
  }

  /**
   * user.reservation
   */
  export type user$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservation
     */
    select?: reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reservation
     */
    omit?: reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationInclude<ExtArgs> | null
    where?: reservationWhereInput
    orderBy?: reservationOrderByWithRelationInput | reservationOrderByWithRelationInput[]
    cursor?: reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AirportScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    pays: 'pays',
    description: 'description',
    est_actif: 'est_actif',
    location_id: 'location_id'
  };

  export type AirportScalarFieldEnum = (typeof AirportScalarFieldEnum)[keyof typeof AirportScalarFieldEnum]


  export const CompteScalarFieldEnum: {
    id: 'id',
    solde: 'solde',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id'
  };

  export type CompteScalarFieldEnum = (typeof CompteScalarFieldEnum)[keyof typeof CompteScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    clientType: 'clientType',
    label: 'label',
    contractStartDate: 'contractStartDate',
    contractEndDate: 'contractEndDate',
    guaranteedMinimum: 'guaranteedMinimum',
    travelStartDate: 'travelStartDate',
    travelEndDate: 'travelEndDate',
    isActive: 'isActive',
    modifiedFeeAmount: 'modifiedFeeAmount',
    payLater: 'payLater',
    payLaterTimeLimit: 'payLaterTimeLimit',
    minTimeBeforeBalanceFlight: 'minTimeBeforeBalanceFlight',
    invoiceStamp: 'invoiceStamp',
    finalClientAdditionalFees: 'finalClientAdditionalFees',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    client_id: 'client_id',
    fixedTicketPrice: 'fixedTicketPrice',
    coupon_id: 'coupon_id'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const Contract_couponsScalarFieldEnum: {
    contract_id: 'contract_id',
    coupon_id: 'coupon_id'
  };

  export type Contract_couponsScalarFieldEnum = (typeof Contract_couponsScalarFieldEnum)[keyof typeof Contract_couponsScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    reduction: 'reduction',
    reduction_type: 'reduction_type',
    date_fin: 'date_fin',
    date_creation: 'date_creation'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const FlightScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    prix: 'prix',
    date_depart: 'date_depart',
    date_retour: 'date_retour',
    duree: 'duree',
    status: 'status',
    airport_depart_id: 'airport_depart_id',
    airport_arrivee_id: 'airport_arrivee_id',
    plane_id: 'plane_id'
  };

  export type FlightScalarFieldEnum = (typeof FlightScalarFieldEnum)[keyof typeof FlightScalarFieldEnum]


  export const Flight_seat_reservationScalarFieldEnum: {
    id: 'id',
    isReserved: 'isReserved',
    flight_id: 'flight_id',
    seat_id: 'seat_id',
    reservation_id: 'reservation_id'
  };

  export type Flight_seat_reservationScalarFieldEnum = (typeof Flight_seat_reservationScalarFieldEnum)[keyof typeof Flight_seat_reservationScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    pays: 'pays',
    ville: 'ville',
    description: 'description',
    url_image: 'url_image'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    contenu: 'contenu',
    image_url: 'image_url',
    date_creation: 'date_creation'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const PlaneScalarFieldEnum: {
    idPlane: 'idPlane',
    planeModel: 'planeModel',
    totalSeats: 'totalSeats',
    seatConfiguration: 'seatConfiguration'
  };

  export type PlaneScalarFieldEnum = (typeof PlaneScalarFieldEnum)[keyof typeof PlaneScalarFieldEnum]


  export const ReclamationScalarFieldEnum: {
    id: 'id',
    sujet: 'sujet',
    description: 'description',
    statut: 'statut',
    date_creation: 'date_creation',
    reponse: 'reponse',
    date_reponse: 'date_reponse',
    user_id: 'user_id'
  };

  export type ReclamationScalarFieldEnum = (typeof ReclamationScalarFieldEnum)[keyof typeof ReclamationScalarFieldEnum]


  export const Request_soldeScalarFieldEnum: {
    id: 'id',
    montant: 'montant',
    description: 'description',
    date: 'date',
    status: 'status',
    imageUrl: 'imageUrl',
    client_id: 'client_id'
  };

  export type Request_soldeScalarFieldEnum = (typeof Request_soldeScalarFieldEnum)[keyof typeof Request_soldeScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    date_reservation: 'date_reservation',
    statut: 'statut',
    prix_total: 'prix_total',
    nombre_passagers: 'nombre_passagers',
    coupon_code: 'coupon_code',
    discount_amount: 'discount_amount',
    class_type: 'class_type',
    fare_type: 'fare_type',
    user_id: 'user_id',
    flight_id: 'flight_id',
    coupon_id: 'coupon_id'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const SeatScalarFieldEnum: {
    idSeat: 'idSeat',
    seatNumber: 'seatNumber',
    classType: 'classType',
    availability: 'availability',
    idPlane: 'idPlane'
  };

  export type SeatScalarFieldEnum = (typeof SeatScalarFieldEnum)[keyof typeof SeatScalarFieldEnum]


  export const Seat_reservationScalarFieldEnum: {
    id: 'id',
    seat_id: 'seat_id',
    reservation_id: 'reservation_id',
    flight_id: 'flight_id'
  };

  export type Seat_reservationScalarFieldEnum = (typeof Seat_reservationScalarFieldEnum)[keyof typeof Seat_reservationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    numero_telephone: 'numero_telephone',
    pays: 'pays',
    adresse: 'adresse',
    est_admin: 'est_admin',
    mot_de_passe: 'mot_de_passe'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const airportOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    pays: 'pays',
    description: 'description',
    location_id: 'location_id'
  };

  export type airportOrderByRelevanceFieldEnum = (typeof airportOrderByRelevanceFieldEnum)[keyof typeof airportOrderByRelevanceFieldEnum]


  export const compteOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type compteOrderByRelevanceFieldEnum = (typeof compteOrderByRelevanceFieldEnum)[keyof typeof compteOrderByRelevanceFieldEnum]


  export const contractOrderByRelevanceFieldEnum: {
    id: 'id',
    clientType: 'clientType',
    label: 'label',
    client_id: 'client_id',
    coupon_id: 'coupon_id'
  };

  export type contractOrderByRelevanceFieldEnum = (typeof contractOrderByRelevanceFieldEnum)[keyof typeof contractOrderByRelevanceFieldEnum]


  export const contract_couponsOrderByRelevanceFieldEnum: {
    contract_id: 'contract_id',
    coupon_id: 'coupon_id'
  };

  export type contract_couponsOrderByRelevanceFieldEnum = (typeof contract_couponsOrderByRelevanceFieldEnum)[keyof typeof contract_couponsOrderByRelevanceFieldEnum]


  export const couponOrderByRelevanceFieldEnum: {
    id: 'id',
    code: 'code'
  };

  export type couponOrderByRelevanceFieldEnum = (typeof couponOrderByRelevanceFieldEnum)[keyof typeof couponOrderByRelevanceFieldEnum]


  export const flightOrderByRelevanceFieldEnum: {
    id: 'id',
    titre: 'titre',
    duree: 'duree',
    status: 'status',
    airport_depart_id: 'airport_depart_id',
    airport_arrivee_id: 'airport_arrivee_id'
  };

  export type flightOrderByRelevanceFieldEnum = (typeof flightOrderByRelevanceFieldEnum)[keyof typeof flightOrderByRelevanceFieldEnum]


  export const flight_seat_reservationOrderByRelevanceFieldEnum: {
    id: 'id',
    flight_id: 'flight_id',
    reservation_id: 'reservation_id'
  };

  export type flight_seat_reservationOrderByRelevanceFieldEnum = (typeof flight_seat_reservationOrderByRelevanceFieldEnum)[keyof typeof flight_seat_reservationOrderByRelevanceFieldEnum]


  export const locationOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    pays: 'pays',
    ville: 'ville',
    description: 'description',
    url_image: 'url_image'
  };

  export type locationOrderByRelevanceFieldEnum = (typeof locationOrderByRelevanceFieldEnum)[keyof typeof locationOrderByRelevanceFieldEnum]


  export const newsOrderByRelevanceFieldEnum: {
    id: 'id',
    titre: 'titre',
    contenu: 'contenu',
    image_url: 'image_url'
  };

  export type newsOrderByRelevanceFieldEnum = (typeof newsOrderByRelevanceFieldEnum)[keyof typeof newsOrderByRelevanceFieldEnum]


  export const planeOrderByRelevanceFieldEnum: {
    planeModel: 'planeModel',
    seatConfiguration: 'seatConfiguration'
  };

  export type planeOrderByRelevanceFieldEnum = (typeof planeOrderByRelevanceFieldEnum)[keyof typeof planeOrderByRelevanceFieldEnum]


  export const reclamationOrderByRelevanceFieldEnum: {
    id: 'id',
    sujet: 'sujet',
    description: 'description',
    statut: 'statut',
    reponse: 'reponse',
    user_id: 'user_id'
  };

  export type reclamationOrderByRelevanceFieldEnum = (typeof reclamationOrderByRelevanceFieldEnum)[keyof typeof reclamationOrderByRelevanceFieldEnum]


  export const request_soldeOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    imageUrl: 'imageUrl',
    client_id: 'client_id'
  };

  export type request_soldeOrderByRelevanceFieldEnum = (typeof request_soldeOrderByRelevanceFieldEnum)[keyof typeof request_soldeOrderByRelevanceFieldEnum]


  export const reservationOrderByRelevanceFieldEnum: {
    id: 'id',
    statut: 'statut',
    coupon_code: 'coupon_code',
    class_type: 'class_type',
    fare_type: 'fare_type',
    user_id: 'user_id',
    flight_id: 'flight_id',
    coupon_id: 'coupon_id'
  };

  export type reservationOrderByRelevanceFieldEnum = (typeof reservationOrderByRelevanceFieldEnum)[keyof typeof reservationOrderByRelevanceFieldEnum]


  export const seatOrderByRelevanceFieldEnum: {
    seatNumber: 'seatNumber'
  };

  export type seatOrderByRelevanceFieldEnum = (typeof seatOrderByRelevanceFieldEnum)[keyof typeof seatOrderByRelevanceFieldEnum]


  export const seat_reservationOrderByRelevanceFieldEnum: {
    reservation_id: 'reservation_id',
    flight_id: 'flight_id'
  };

  export type seat_reservationOrderByRelevanceFieldEnum = (typeof seat_reservationOrderByRelevanceFieldEnum)[keyof typeof seat_reservationOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    numero_telephone: 'numero_telephone',
    pays: 'pays',
    adresse: 'adresse',
    mot_de_passe: 'mot_de_passe'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'coupon_reduction_type'
   */
  export type Enumcoupon_reduction_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'coupon_reduction_type'>
    


  /**
   * Reference to a field of type 'request_solde_status'
   */
  export type Enumrequest_solde_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'request_solde_status'>
    


  /**
   * Reference to a field of type 'seat_classType'
   */
  export type Enumseat_classTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'seat_classType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type airportWhereInput = {
    AND?: airportWhereInput | airportWhereInput[]
    OR?: airportWhereInput[]
    NOT?: airportWhereInput | airportWhereInput[]
    id?: StringFilter<"airport"> | string
    nom?: StringFilter<"airport"> | string
    code?: StringFilter<"airport"> | string
    pays?: StringFilter<"airport"> | string
    description?: StringNullableFilter<"airport"> | string | null
    est_actif?: IntFilter<"airport"> | number
    location_id?: StringNullableFilter<"airport"> | string | null
    location?: XOR<LocationNullableScalarRelationFilter, locationWhereInput> | null
    flight_flight_airport_depart_idToairport?: FlightListRelationFilter
    flight_flight_airport_arrivee_idToairport?: FlightListRelationFilter
  }

  export type airportOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    pays?: SortOrder
    description?: SortOrderInput | SortOrder
    est_actif?: SortOrder
    location_id?: SortOrderInput | SortOrder
    location?: locationOrderByWithRelationInput
    flight_flight_airport_depart_idToairport?: flightOrderByRelationAggregateInput
    flight_flight_airport_arrivee_idToairport?: flightOrderByRelationAggregateInput
    _relevance?: airportOrderByRelevanceInput
  }

  export type airportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: airportWhereInput | airportWhereInput[]
    OR?: airportWhereInput[]
    NOT?: airportWhereInput | airportWhereInput[]
    nom?: StringFilter<"airport"> | string
    code?: StringFilter<"airport"> | string
    pays?: StringFilter<"airport"> | string
    description?: StringNullableFilter<"airport"> | string | null
    est_actif?: IntFilter<"airport"> | number
    location_id?: StringNullableFilter<"airport"> | string | null
    location?: XOR<LocationNullableScalarRelationFilter, locationWhereInput> | null
    flight_flight_airport_depart_idToairport?: FlightListRelationFilter
    flight_flight_airport_arrivee_idToairport?: FlightListRelationFilter
  }, "id">

  export type airportOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    pays?: SortOrder
    description?: SortOrderInput | SortOrder
    est_actif?: SortOrder
    location_id?: SortOrderInput | SortOrder
    _count?: airportCountOrderByAggregateInput
    _avg?: airportAvgOrderByAggregateInput
    _max?: airportMaxOrderByAggregateInput
    _min?: airportMinOrderByAggregateInput
    _sum?: airportSumOrderByAggregateInput
  }

  export type airportScalarWhereWithAggregatesInput = {
    AND?: airportScalarWhereWithAggregatesInput | airportScalarWhereWithAggregatesInput[]
    OR?: airportScalarWhereWithAggregatesInput[]
    NOT?: airportScalarWhereWithAggregatesInput | airportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"airport"> | string
    nom?: StringWithAggregatesFilter<"airport"> | string
    code?: StringWithAggregatesFilter<"airport"> | string
    pays?: StringWithAggregatesFilter<"airport"> | string
    description?: StringNullableWithAggregatesFilter<"airport"> | string | null
    est_actif?: IntWithAggregatesFilter<"airport"> | number
    location_id?: StringNullableWithAggregatesFilter<"airport"> | string | null
  }

  export type compteWhereInput = {
    AND?: compteWhereInput | compteWhereInput[]
    OR?: compteWhereInput[]
    NOT?: compteWhereInput | compteWhereInput[]
    id?: StringFilter<"compte"> | string
    solde?: DecimalFilter<"compte"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"compte"> | Date | string
    updated_at?: DateTimeFilter<"compte"> | Date | string
    user_id?: StringNullableFilter<"compte"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type compteOrderByWithRelationInput = {
    id?: SortOrder
    solde?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: compteOrderByRelevanceInput
  }

  export type compteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: compteWhereInput | compteWhereInput[]
    OR?: compteWhereInput[]
    NOT?: compteWhereInput | compteWhereInput[]
    solde?: DecimalFilter<"compte"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"compte"> | Date | string
    updated_at?: DateTimeFilter<"compte"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id" | "user_id">

  export type compteOrderByWithAggregationInput = {
    id?: SortOrder
    solde?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: compteCountOrderByAggregateInput
    _avg?: compteAvgOrderByAggregateInput
    _max?: compteMaxOrderByAggregateInput
    _min?: compteMinOrderByAggregateInput
    _sum?: compteSumOrderByAggregateInput
  }

  export type compteScalarWhereWithAggregatesInput = {
    AND?: compteScalarWhereWithAggregatesInput | compteScalarWhereWithAggregatesInput[]
    OR?: compteScalarWhereWithAggregatesInput[]
    NOT?: compteScalarWhereWithAggregatesInput | compteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"compte"> | string
    solde?: DecimalWithAggregatesFilter<"compte"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"compte"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"compte"> | Date | string
    user_id?: StringNullableWithAggregatesFilter<"compte"> | string | null
  }

  export type contractWhereInput = {
    AND?: contractWhereInput | contractWhereInput[]
    OR?: contractWhereInput[]
    NOT?: contractWhereInput | contractWhereInput[]
    id?: StringFilter<"contract"> | string
    clientType?: StringFilter<"contract"> | string
    label?: StringFilter<"contract"> | string
    contractStartDate?: DateTimeFilter<"contract"> | Date | string
    contractEndDate?: DateTimeFilter<"contract"> | Date | string
    guaranteedMinimum?: DecimalFilter<"contract"> | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFilter<"contract"> | Date | string
    travelEndDate?: DateTimeFilter<"contract"> | Date | string
    isActive?: IntFilter<"contract"> | number
    modifiedFeeAmount?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFilter<"contract"> | number
    payLaterTimeLimit?: IntNullableFilter<"contract"> | number | null
    minTimeBeforeBalanceFlight?: IntNullableFilter<"contract"> | number | null
    invoiceStamp?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"contract"> | Date | string
    updatedAt?: DateTimeFilter<"contract"> | Date | string
    client_id?: StringNullableFilter<"contract"> | string | null
    fixedTicketPrice?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    coupon_id?: StringNullableFilter<"contract"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, couponWhereInput> | null
    contract_coupons?: Contract_couponsListRelationFilter
  }

  export type contractOrderByWithRelationInput = {
    id?: SortOrder
    clientType?: SortOrder
    label?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    guaranteedMinimum?: SortOrder
    travelStartDate?: SortOrder
    travelEndDate?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrderInput | SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrderInput | SortOrder
    minTimeBeforeBalanceFlight?: SortOrderInput | SortOrder
    invoiceStamp?: SortOrderInput | SortOrder
    finalClientAdditionalFees?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrderInput | SortOrder
    fixedTicketPrice?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    coupon?: couponOrderByWithRelationInput
    contract_coupons?: contract_couponsOrderByRelationAggregateInput
    _relevance?: contractOrderByRelevanceInput
  }

  export type contractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contractWhereInput | contractWhereInput[]
    OR?: contractWhereInput[]
    NOT?: contractWhereInput | contractWhereInput[]
    clientType?: StringFilter<"contract"> | string
    label?: StringFilter<"contract"> | string
    contractStartDate?: DateTimeFilter<"contract"> | Date | string
    contractEndDate?: DateTimeFilter<"contract"> | Date | string
    guaranteedMinimum?: DecimalFilter<"contract"> | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFilter<"contract"> | Date | string
    travelEndDate?: DateTimeFilter<"contract"> | Date | string
    isActive?: IntFilter<"contract"> | number
    modifiedFeeAmount?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFilter<"contract"> | number
    payLaterTimeLimit?: IntNullableFilter<"contract"> | number | null
    minTimeBeforeBalanceFlight?: IntNullableFilter<"contract"> | number | null
    invoiceStamp?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"contract"> | Date | string
    updatedAt?: DateTimeFilter<"contract"> | Date | string
    client_id?: StringNullableFilter<"contract"> | string | null
    fixedTicketPrice?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    coupon_id?: StringNullableFilter<"contract"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, couponWhereInput> | null
    contract_coupons?: Contract_couponsListRelationFilter
  }, "id">

  export type contractOrderByWithAggregationInput = {
    id?: SortOrder
    clientType?: SortOrder
    label?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    guaranteedMinimum?: SortOrder
    travelStartDate?: SortOrder
    travelEndDate?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrderInput | SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrderInput | SortOrder
    minTimeBeforeBalanceFlight?: SortOrderInput | SortOrder
    invoiceStamp?: SortOrderInput | SortOrder
    finalClientAdditionalFees?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrderInput | SortOrder
    fixedTicketPrice?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    _count?: contractCountOrderByAggregateInput
    _avg?: contractAvgOrderByAggregateInput
    _max?: contractMaxOrderByAggregateInput
    _min?: contractMinOrderByAggregateInput
    _sum?: contractSumOrderByAggregateInput
  }

  export type contractScalarWhereWithAggregatesInput = {
    AND?: contractScalarWhereWithAggregatesInput | contractScalarWhereWithAggregatesInput[]
    OR?: contractScalarWhereWithAggregatesInput[]
    NOT?: contractScalarWhereWithAggregatesInput | contractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contract"> | string
    clientType?: StringWithAggregatesFilter<"contract"> | string
    label?: StringWithAggregatesFilter<"contract"> | string
    contractStartDate?: DateTimeWithAggregatesFilter<"contract"> | Date | string
    contractEndDate?: DateTimeWithAggregatesFilter<"contract"> | Date | string
    guaranteedMinimum?: DecimalWithAggregatesFilter<"contract"> | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeWithAggregatesFilter<"contract"> | Date | string
    travelEndDate?: DateTimeWithAggregatesFilter<"contract"> | Date | string
    isActive?: IntWithAggregatesFilter<"contract"> | number
    modifiedFeeAmount?: DecimalNullableWithAggregatesFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    payLater?: IntWithAggregatesFilter<"contract"> | number
    payLaterTimeLimit?: IntNullableWithAggregatesFilter<"contract"> | number | null
    minTimeBeforeBalanceFlight?: IntNullableWithAggregatesFilter<"contract"> | number | null
    invoiceStamp?: DecimalNullableWithAggregatesFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: DecimalNullableWithAggregatesFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"contract"> | Date | string
    client_id?: StringNullableWithAggregatesFilter<"contract"> | string | null
    fixedTicketPrice?: DecimalNullableWithAggregatesFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    coupon_id?: StringNullableWithAggregatesFilter<"contract"> | string | null
  }

  export type contract_couponsWhereInput = {
    AND?: contract_couponsWhereInput | contract_couponsWhereInput[]
    OR?: contract_couponsWhereInput[]
    NOT?: contract_couponsWhereInput | contract_couponsWhereInput[]
    contract_id?: StringFilter<"contract_coupons"> | string
    coupon_id?: StringFilter<"contract_coupons"> | string
    contract?: XOR<ContractScalarRelationFilter, contractWhereInput>
    coupon?: XOR<CouponScalarRelationFilter, couponWhereInput>
  }

  export type contract_couponsOrderByWithRelationInput = {
    contract_id?: SortOrder
    coupon_id?: SortOrder
    contract?: contractOrderByWithRelationInput
    coupon?: couponOrderByWithRelationInput
    _relevance?: contract_couponsOrderByRelevanceInput
  }

  export type contract_couponsWhereUniqueInput = Prisma.AtLeast<{
    contract_id_coupon_id?: contract_couponsContract_idCoupon_idCompoundUniqueInput
    AND?: contract_couponsWhereInput | contract_couponsWhereInput[]
    OR?: contract_couponsWhereInput[]
    NOT?: contract_couponsWhereInput | contract_couponsWhereInput[]
    contract_id?: StringFilter<"contract_coupons"> | string
    coupon_id?: StringFilter<"contract_coupons"> | string
    contract?: XOR<ContractScalarRelationFilter, contractWhereInput>
    coupon?: XOR<CouponScalarRelationFilter, couponWhereInput>
  }, "contract_id_coupon_id">

  export type contract_couponsOrderByWithAggregationInput = {
    contract_id?: SortOrder
    coupon_id?: SortOrder
    _count?: contract_couponsCountOrderByAggregateInput
    _max?: contract_couponsMaxOrderByAggregateInput
    _min?: contract_couponsMinOrderByAggregateInput
  }

  export type contract_couponsScalarWhereWithAggregatesInput = {
    AND?: contract_couponsScalarWhereWithAggregatesInput | contract_couponsScalarWhereWithAggregatesInput[]
    OR?: contract_couponsScalarWhereWithAggregatesInput[]
    NOT?: contract_couponsScalarWhereWithAggregatesInput | contract_couponsScalarWhereWithAggregatesInput[]
    contract_id?: StringWithAggregatesFilter<"contract_coupons"> | string
    coupon_id?: StringWithAggregatesFilter<"contract_coupons"> | string
  }

  export type couponWhereInput = {
    AND?: couponWhereInput | couponWhereInput[]
    OR?: couponWhereInput[]
    NOT?: couponWhereInput | couponWhereInput[]
    id?: StringFilter<"coupon"> | string
    code?: StringFilter<"coupon"> | string
    reduction?: DecimalFilter<"coupon"> | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFilter<"coupon"> | $Enums.coupon_reduction_type
    date_fin?: DateTimeFilter<"coupon"> | Date | string
    date_creation?: DateTimeFilter<"coupon"> | Date | string
    contract?: ContractListRelationFilter
    contract_coupons?: Contract_couponsListRelationFilter
    reservation?: ReservationListRelationFilter
  }

  export type couponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    reduction?: SortOrder
    reduction_type?: SortOrder
    date_fin?: SortOrder
    date_creation?: SortOrder
    contract?: contractOrderByRelationAggregateInput
    contract_coupons?: contract_couponsOrderByRelationAggregateInput
    reservation?: reservationOrderByRelationAggregateInput
    _relevance?: couponOrderByRelevanceInput
  }

  export type couponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: couponWhereInput | couponWhereInput[]
    OR?: couponWhereInput[]
    NOT?: couponWhereInput | couponWhereInput[]
    reduction?: DecimalFilter<"coupon"> | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFilter<"coupon"> | $Enums.coupon_reduction_type
    date_fin?: DateTimeFilter<"coupon"> | Date | string
    date_creation?: DateTimeFilter<"coupon"> | Date | string
    contract?: ContractListRelationFilter
    contract_coupons?: Contract_couponsListRelationFilter
    reservation?: ReservationListRelationFilter
  }, "id" | "code">

  export type couponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    reduction?: SortOrder
    reduction_type?: SortOrder
    date_fin?: SortOrder
    date_creation?: SortOrder
    _count?: couponCountOrderByAggregateInput
    _avg?: couponAvgOrderByAggregateInput
    _max?: couponMaxOrderByAggregateInput
    _min?: couponMinOrderByAggregateInput
    _sum?: couponSumOrderByAggregateInput
  }

  export type couponScalarWhereWithAggregatesInput = {
    AND?: couponScalarWhereWithAggregatesInput | couponScalarWhereWithAggregatesInput[]
    OR?: couponScalarWhereWithAggregatesInput[]
    NOT?: couponScalarWhereWithAggregatesInput | couponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"coupon"> | string
    code?: StringWithAggregatesFilter<"coupon"> | string
    reduction?: DecimalWithAggregatesFilter<"coupon"> | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeWithAggregatesFilter<"coupon"> | $Enums.coupon_reduction_type
    date_fin?: DateTimeWithAggregatesFilter<"coupon"> | Date | string
    date_creation?: DateTimeWithAggregatesFilter<"coupon"> | Date | string
  }

  export type flightWhereInput = {
    AND?: flightWhereInput | flightWhereInput[]
    OR?: flightWhereInput[]
    NOT?: flightWhereInput | flightWhereInput[]
    id?: StringFilter<"flight"> | string
    titre?: StringFilter<"flight"> | string
    prix?: DecimalFilter<"flight"> | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFilter<"flight"> | Date | string
    date_retour?: DateTimeFilter<"flight"> | Date | string
    duree?: StringNullableFilter<"flight"> | string | null
    status?: StringFilter<"flight"> | string
    airport_depart_id?: StringNullableFilter<"flight"> | string | null
    airport_arrivee_id?: StringNullableFilter<"flight"> | string | null
    plane_id?: IntNullableFilter<"flight"> | number | null
    plane?: XOR<PlaneNullableScalarRelationFilter, planeWhereInput> | null
    airport_flight_airport_depart_idToairport?: XOR<AirportNullableScalarRelationFilter, airportWhereInput> | null
    airport_flight_airport_arrivee_idToairport?: XOR<AirportNullableScalarRelationFilter, airportWhereInput> | null
    flight_seat_reservation?: Flight_seat_reservationListRelationFilter
    reservation?: ReservationListRelationFilter
    seat_reservation?: Seat_reservationListRelationFilter
  }

  export type flightOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    prix?: SortOrder
    date_depart?: SortOrder
    date_retour?: SortOrder
    duree?: SortOrderInput | SortOrder
    status?: SortOrder
    airport_depart_id?: SortOrderInput | SortOrder
    airport_arrivee_id?: SortOrderInput | SortOrder
    plane_id?: SortOrderInput | SortOrder
    plane?: planeOrderByWithRelationInput
    airport_flight_airport_depart_idToairport?: airportOrderByWithRelationInput
    airport_flight_airport_arrivee_idToairport?: airportOrderByWithRelationInput
    flight_seat_reservation?: flight_seat_reservationOrderByRelationAggregateInput
    reservation?: reservationOrderByRelationAggregateInput
    seat_reservation?: seat_reservationOrderByRelationAggregateInput
    _relevance?: flightOrderByRelevanceInput
  }

  export type flightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: flightWhereInput | flightWhereInput[]
    OR?: flightWhereInput[]
    NOT?: flightWhereInput | flightWhereInput[]
    titre?: StringFilter<"flight"> | string
    prix?: DecimalFilter<"flight"> | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFilter<"flight"> | Date | string
    date_retour?: DateTimeFilter<"flight"> | Date | string
    duree?: StringNullableFilter<"flight"> | string | null
    status?: StringFilter<"flight"> | string
    airport_depart_id?: StringNullableFilter<"flight"> | string | null
    airport_arrivee_id?: StringNullableFilter<"flight"> | string | null
    plane_id?: IntNullableFilter<"flight"> | number | null
    plane?: XOR<PlaneNullableScalarRelationFilter, planeWhereInput> | null
    airport_flight_airport_depart_idToairport?: XOR<AirportNullableScalarRelationFilter, airportWhereInput> | null
    airport_flight_airport_arrivee_idToairport?: XOR<AirportNullableScalarRelationFilter, airportWhereInput> | null
    flight_seat_reservation?: Flight_seat_reservationListRelationFilter
    reservation?: ReservationListRelationFilter
    seat_reservation?: Seat_reservationListRelationFilter
  }, "id">

  export type flightOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    prix?: SortOrder
    date_depart?: SortOrder
    date_retour?: SortOrder
    duree?: SortOrderInput | SortOrder
    status?: SortOrder
    airport_depart_id?: SortOrderInput | SortOrder
    airport_arrivee_id?: SortOrderInput | SortOrder
    plane_id?: SortOrderInput | SortOrder
    _count?: flightCountOrderByAggregateInput
    _avg?: flightAvgOrderByAggregateInput
    _max?: flightMaxOrderByAggregateInput
    _min?: flightMinOrderByAggregateInput
    _sum?: flightSumOrderByAggregateInput
  }

  export type flightScalarWhereWithAggregatesInput = {
    AND?: flightScalarWhereWithAggregatesInput | flightScalarWhereWithAggregatesInput[]
    OR?: flightScalarWhereWithAggregatesInput[]
    NOT?: flightScalarWhereWithAggregatesInput | flightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"flight"> | string
    titre?: StringWithAggregatesFilter<"flight"> | string
    prix?: DecimalWithAggregatesFilter<"flight"> | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeWithAggregatesFilter<"flight"> | Date | string
    date_retour?: DateTimeWithAggregatesFilter<"flight"> | Date | string
    duree?: StringNullableWithAggregatesFilter<"flight"> | string | null
    status?: StringWithAggregatesFilter<"flight"> | string
    airport_depart_id?: StringNullableWithAggregatesFilter<"flight"> | string | null
    airport_arrivee_id?: StringNullableWithAggregatesFilter<"flight"> | string | null
    plane_id?: IntNullableWithAggregatesFilter<"flight"> | number | null
  }

  export type flight_seat_reservationWhereInput = {
    AND?: flight_seat_reservationWhereInput | flight_seat_reservationWhereInput[]
    OR?: flight_seat_reservationWhereInput[]
    NOT?: flight_seat_reservationWhereInput | flight_seat_reservationWhereInput[]
    id?: StringFilter<"flight_seat_reservation"> | string
    isReserved?: IntFilter<"flight_seat_reservation"> | number
    flight_id?: StringNullableFilter<"flight_seat_reservation"> | string | null
    seat_id?: IntNullableFilter<"flight_seat_reservation"> | number | null
    reservation_id?: StringNullableFilter<"flight_seat_reservation"> | string | null
    seat?: XOR<SeatNullableScalarRelationFilter, seatWhereInput> | null
    flight?: XOR<FlightNullableScalarRelationFilter, flightWhereInput> | null
    reservation?: XOR<ReservationNullableScalarRelationFilter, reservationWhereInput> | null
  }

  export type flight_seat_reservationOrderByWithRelationInput = {
    id?: SortOrder
    isReserved?: SortOrder
    flight_id?: SortOrderInput | SortOrder
    seat_id?: SortOrderInput | SortOrder
    reservation_id?: SortOrderInput | SortOrder
    seat?: seatOrderByWithRelationInput
    flight?: flightOrderByWithRelationInput
    reservation?: reservationOrderByWithRelationInput
    _relevance?: flight_seat_reservationOrderByRelevanceInput
  }

  export type flight_seat_reservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: flight_seat_reservationWhereInput | flight_seat_reservationWhereInput[]
    OR?: flight_seat_reservationWhereInput[]
    NOT?: flight_seat_reservationWhereInput | flight_seat_reservationWhereInput[]
    isReserved?: IntFilter<"flight_seat_reservation"> | number
    flight_id?: StringNullableFilter<"flight_seat_reservation"> | string | null
    seat_id?: IntNullableFilter<"flight_seat_reservation"> | number | null
    reservation_id?: StringNullableFilter<"flight_seat_reservation"> | string | null
    seat?: XOR<SeatNullableScalarRelationFilter, seatWhereInput> | null
    flight?: XOR<FlightNullableScalarRelationFilter, flightWhereInput> | null
    reservation?: XOR<ReservationNullableScalarRelationFilter, reservationWhereInput> | null
  }, "id">

  export type flight_seat_reservationOrderByWithAggregationInput = {
    id?: SortOrder
    isReserved?: SortOrder
    flight_id?: SortOrderInput | SortOrder
    seat_id?: SortOrderInput | SortOrder
    reservation_id?: SortOrderInput | SortOrder
    _count?: flight_seat_reservationCountOrderByAggregateInput
    _avg?: flight_seat_reservationAvgOrderByAggregateInput
    _max?: flight_seat_reservationMaxOrderByAggregateInput
    _min?: flight_seat_reservationMinOrderByAggregateInput
    _sum?: flight_seat_reservationSumOrderByAggregateInput
  }

  export type flight_seat_reservationScalarWhereWithAggregatesInput = {
    AND?: flight_seat_reservationScalarWhereWithAggregatesInput | flight_seat_reservationScalarWhereWithAggregatesInput[]
    OR?: flight_seat_reservationScalarWhereWithAggregatesInput[]
    NOT?: flight_seat_reservationScalarWhereWithAggregatesInput | flight_seat_reservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"flight_seat_reservation"> | string
    isReserved?: IntWithAggregatesFilter<"flight_seat_reservation"> | number
    flight_id?: StringNullableWithAggregatesFilter<"flight_seat_reservation"> | string | null
    seat_id?: IntNullableWithAggregatesFilter<"flight_seat_reservation"> | number | null
    reservation_id?: StringNullableWithAggregatesFilter<"flight_seat_reservation"> | string | null
  }

  export type locationWhereInput = {
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    id?: StringFilter<"location"> | string
    nom?: StringFilter<"location"> | string
    pays?: StringFilter<"location"> | string
    ville?: StringFilter<"location"> | string
    description?: StringNullableFilter<"location"> | string | null
    url_image?: StringNullableFilter<"location"> | string | null
    airport?: AirportListRelationFilter
  }

  export type locationOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    pays?: SortOrder
    ville?: SortOrder
    description?: SortOrderInput | SortOrder
    url_image?: SortOrderInput | SortOrder
    airport?: airportOrderByRelationAggregateInput
    _relevance?: locationOrderByRelevanceInput
  }

  export type locationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    nom?: StringFilter<"location"> | string
    pays?: StringFilter<"location"> | string
    ville?: StringFilter<"location"> | string
    description?: StringNullableFilter<"location"> | string | null
    url_image?: StringNullableFilter<"location"> | string | null
    airport?: AirportListRelationFilter
  }, "id">

  export type locationOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    pays?: SortOrder
    ville?: SortOrder
    description?: SortOrderInput | SortOrder
    url_image?: SortOrderInput | SortOrder
    _count?: locationCountOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    OR?: locationScalarWhereWithAggregatesInput[]
    NOT?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"location"> | string
    nom?: StringWithAggregatesFilter<"location"> | string
    pays?: StringWithAggregatesFilter<"location"> | string
    ville?: StringWithAggregatesFilter<"location"> | string
    description?: StringNullableWithAggregatesFilter<"location"> | string | null
    url_image?: StringNullableWithAggregatesFilter<"location"> | string | null
  }

  export type newsWhereInput = {
    AND?: newsWhereInput | newsWhereInput[]
    OR?: newsWhereInput[]
    NOT?: newsWhereInput | newsWhereInput[]
    id?: StringFilter<"news"> | string
    titre?: StringFilter<"news"> | string
    contenu?: StringFilter<"news"> | string
    image_url?: StringNullableFilter<"news"> | string | null
    date_creation?: DateTimeFilter<"news"> | Date | string
  }

  export type newsOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    image_url?: SortOrderInput | SortOrder
    date_creation?: SortOrder
    _relevance?: newsOrderByRelevanceInput
  }

  export type newsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: newsWhereInput | newsWhereInput[]
    OR?: newsWhereInput[]
    NOT?: newsWhereInput | newsWhereInput[]
    titre?: StringFilter<"news"> | string
    contenu?: StringFilter<"news"> | string
    image_url?: StringNullableFilter<"news"> | string | null
    date_creation?: DateTimeFilter<"news"> | Date | string
  }, "id">

  export type newsOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    image_url?: SortOrderInput | SortOrder
    date_creation?: SortOrder
    _count?: newsCountOrderByAggregateInput
    _max?: newsMaxOrderByAggregateInput
    _min?: newsMinOrderByAggregateInput
  }

  export type newsScalarWhereWithAggregatesInput = {
    AND?: newsScalarWhereWithAggregatesInput | newsScalarWhereWithAggregatesInput[]
    OR?: newsScalarWhereWithAggregatesInput[]
    NOT?: newsScalarWhereWithAggregatesInput | newsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"news"> | string
    titre?: StringWithAggregatesFilter<"news"> | string
    contenu?: StringWithAggregatesFilter<"news"> | string
    image_url?: StringNullableWithAggregatesFilter<"news"> | string | null
    date_creation?: DateTimeWithAggregatesFilter<"news"> | Date | string
  }

  export type planeWhereInput = {
    AND?: planeWhereInput | planeWhereInput[]
    OR?: planeWhereInput[]
    NOT?: planeWhereInput | planeWhereInput[]
    idPlane?: IntFilter<"plane"> | number
    planeModel?: StringFilter<"plane"> | string
    totalSeats?: IntFilter<"plane"> | number
    seatConfiguration?: StringFilter<"plane"> | string
    flight?: FlightListRelationFilter
    seat?: SeatListRelationFilter
  }

  export type planeOrderByWithRelationInput = {
    idPlane?: SortOrder
    planeModel?: SortOrder
    totalSeats?: SortOrder
    seatConfiguration?: SortOrder
    flight?: flightOrderByRelationAggregateInput
    seat?: seatOrderByRelationAggregateInput
    _relevance?: planeOrderByRelevanceInput
  }

  export type planeWhereUniqueInput = Prisma.AtLeast<{
    idPlane?: number
    AND?: planeWhereInput | planeWhereInput[]
    OR?: planeWhereInput[]
    NOT?: planeWhereInput | planeWhereInput[]
    planeModel?: StringFilter<"plane"> | string
    totalSeats?: IntFilter<"plane"> | number
    seatConfiguration?: StringFilter<"plane"> | string
    flight?: FlightListRelationFilter
    seat?: SeatListRelationFilter
  }, "idPlane">

  export type planeOrderByWithAggregationInput = {
    idPlane?: SortOrder
    planeModel?: SortOrder
    totalSeats?: SortOrder
    seatConfiguration?: SortOrder
    _count?: planeCountOrderByAggregateInput
    _avg?: planeAvgOrderByAggregateInput
    _max?: planeMaxOrderByAggregateInput
    _min?: planeMinOrderByAggregateInput
    _sum?: planeSumOrderByAggregateInput
  }

  export type planeScalarWhereWithAggregatesInput = {
    AND?: planeScalarWhereWithAggregatesInput | planeScalarWhereWithAggregatesInput[]
    OR?: planeScalarWhereWithAggregatesInput[]
    NOT?: planeScalarWhereWithAggregatesInput | planeScalarWhereWithAggregatesInput[]
    idPlane?: IntWithAggregatesFilter<"plane"> | number
    planeModel?: StringWithAggregatesFilter<"plane"> | string
    totalSeats?: IntWithAggregatesFilter<"plane"> | number
    seatConfiguration?: StringWithAggregatesFilter<"plane"> | string
  }

  export type reclamationWhereInput = {
    AND?: reclamationWhereInput | reclamationWhereInput[]
    OR?: reclamationWhereInput[]
    NOT?: reclamationWhereInput | reclamationWhereInput[]
    id?: StringFilter<"reclamation"> | string
    sujet?: StringFilter<"reclamation"> | string
    description?: StringFilter<"reclamation"> | string
    statut?: StringFilter<"reclamation"> | string
    date_creation?: DateTimeFilter<"reclamation"> | Date | string
    reponse?: StringNullableFilter<"reclamation"> | string | null
    date_reponse?: DateTimeNullableFilter<"reclamation"> | Date | string | null
    user_id?: StringNullableFilter<"reclamation"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type reclamationOrderByWithRelationInput = {
    id?: SortOrder
    sujet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    date_creation?: SortOrder
    reponse?: SortOrderInput | SortOrder
    date_reponse?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: reclamationOrderByRelevanceInput
  }

  export type reclamationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reclamationWhereInput | reclamationWhereInput[]
    OR?: reclamationWhereInput[]
    NOT?: reclamationWhereInput | reclamationWhereInput[]
    sujet?: StringFilter<"reclamation"> | string
    description?: StringFilter<"reclamation"> | string
    statut?: StringFilter<"reclamation"> | string
    date_creation?: DateTimeFilter<"reclamation"> | Date | string
    reponse?: StringNullableFilter<"reclamation"> | string | null
    date_reponse?: DateTimeNullableFilter<"reclamation"> | Date | string | null
    user_id?: StringNullableFilter<"reclamation"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type reclamationOrderByWithAggregationInput = {
    id?: SortOrder
    sujet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    date_creation?: SortOrder
    reponse?: SortOrderInput | SortOrder
    date_reponse?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: reclamationCountOrderByAggregateInput
    _max?: reclamationMaxOrderByAggregateInput
    _min?: reclamationMinOrderByAggregateInput
  }

  export type reclamationScalarWhereWithAggregatesInput = {
    AND?: reclamationScalarWhereWithAggregatesInput | reclamationScalarWhereWithAggregatesInput[]
    OR?: reclamationScalarWhereWithAggregatesInput[]
    NOT?: reclamationScalarWhereWithAggregatesInput | reclamationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reclamation"> | string
    sujet?: StringWithAggregatesFilter<"reclamation"> | string
    description?: StringWithAggregatesFilter<"reclamation"> | string
    statut?: StringWithAggregatesFilter<"reclamation"> | string
    date_creation?: DateTimeWithAggregatesFilter<"reclamation"> | Date | string
    reponse?: StringNullableWithAggregatesFilter<"reclamation"> | string | null
    date_reponse?: DateTimeNullableWithAggregatesFilter<"reclamation"> | Date | string | null
    user_id?: StringNullableWithAggregatesFilter<"reclamation"> | string | null
  }

  export type request_soldeWhereInput = {
    AND?: request_soldeWhereInput | request_soldeWhereInput[]
    OR?: request_soldeWhereInput[]
    NOT?: request_soldeWhereInput | request_soldeWhereInput[]
    id?: StringFilter<"request_solde"> | string
    montant?: DecimalFilter<"request_solde"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"request_solde"> | string | null
    date?: DateTimeFilter<"request_solde"> | Date | string
    status?: Enumrequest_solde_statusFilter<"request_solde"> | $Enums.request_solde_status
    imageUrl?: StringNullableFilter<"request_solde"> | string | null
    client_id?: StringNullableFilter<"request_solde"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type request_soldeOrderByWithRelationInput = {
    id?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: request_soldeOrderByRelevanceInput
  }

  export type request_soldeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: request_soldeWhereInput | request_soldeWhereInput[]
    OR?: request_soldeWhereInput[]
    NOT?: request_soldeWhereInput | request_soldeWhereInput[]
    montant?: DecimalFilter<"request_solde"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"request_solde"> | string | null
    date?: DateTimeFilter<"request_solde"> | Date | string
    status?: Enumrequest_solde_statusFilter<"request_solde"> | $Enums.request_solde_status
    imageUrl?: StringNullableFilter<"request_solde"> | string | null
    client_id?: StringNullableFilter<"request_solde"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type request_soldeOrderByWithAggregationInput = {
    id?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    _count?: request_soldeCountOrderByAggregateInput
    _avg?: request_soldeAvgOrderByAggregateInput
    _max?: request_soldeMaxOrderByAggregateInput
    _min?: request_soldeMinOrderByAggregateInput
    _sum?: request_soldeSumOrderByAggregateInput
  }

  export type request_soldeScalarWhereWithAggregatesInput = {
    AND?: request_soldeScalarWhereWithAggregatesInput | request_soldeScalarWhereWithAggregatesInput[]
    OR?: request_soldeScalarWhereWithAggregatesInput[]
    NOT?: request_soldeScalarWhereWithAggregatesInput | request_soldeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"request_solde"> | string
    montant?: DecimalWithAggregatesFilter<"request_solde"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"request_solde"> | string | null
    date?: DateTimeWithAggregatesFilter<"request_solde"> | Date | string
    status?: Enumrequest_solde_statusWithAggregatesFilter<"request_solde"> | $Enums.request_solde_status
    imageUrl?: StringNullableWithAggregatesFilter<"request_solde"> | string | null
    client_id?: StringNullableWithAggregatesFilter<"request_solde"> | string | null
  }

  export type reservationWhereInput = {
    AND?: reservationWhereInput | reservationWhereInput[]
    OR?: reservationWhereInput[]
    NOT?: reservationWhereInput | reservationWhereInput[]
    id?: StringFilter<"reservation"> | string
    date_reservation?: DateTimeFilter<"reservation"> | Date | string
    statut?: StringFilter<"reservation"> | string
    prix_total?: DecimalFilter<"reservation"> | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFilter<"reservation"> | number
    coupon_code?: StringNullableFilter<"reservation"> | string | null
    discount_amount?: DecimalNullableFilter<"reservation"> | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFilter<"reservation"> | string
    fare_type?: StringFilter<"reservation"> | string
    user_id?: StringNullableFilter<"reservation"> | string | null
    flight_id?: StringNullableFilter<"reservation"> | string | null
    coupon_id?: StringNullableFilter<"reservation"> | string | null
    flight_seat_reservation?: Flight_seat_reservationListRelationFilter
    flight?: XOR<FlightNullableScalarRelationFilter, flightWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, couponWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    seat_reservation?: Seat_reservationListRelationFilter
  }

  export type reservationOrderByWithRelationInput = {
    id?: SortOrder
    date_reservation?: SortOrder
    statut?: SortOrder
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    coupon_code?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    class_type?: SortOrder
    fare_type?: SortOrder
    user_id?: SortOrderInput | SortOrder
    flight_id?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    flight_seat_reservation?: flight_seat_reservationOrderByRelationAggregateInput
    flight?: flightOrderByWithRelationInput
    coupon?: couponOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    seat_reservation?: seat_reservationOrderByRelationAggregateInput
    _relevance?: reservationOrderByRelevanceInput
  }

  export type reservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reservationWhereInput | reservationWhereInput[]
    OR?: reservationWhereInput[]
    NOT?: reservationWhereInput | reservationWhereInput[]
    date_reservation?: DateTimeFilter<"reservation"> | Date | string
    statut?: StringFilter<"reservation"> | string
    prix_total?: DecimalFilter<"reservation"> | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFilter<"reservation"> | number
    coupon_code?: StringNullableFilter<"reservation"> | string | null
    discount_amount?: DecimalNullableFilter<"reservation"> | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFilter<"reservation"> | string
    fare_type?: StringFilter<"reservation"> | string
    user_id?: StringNullableFilter<"reservation"> | string | null
    flight_id?: StringNullableFilter<"reservation"> | string | null
    coupon_id?: StringNullableFilter<"reservation"> | string | null
    flight_seat_reservation?: Flight_seat_reservationListRelationFilter
    flight?: XOR<FlightNullableScalarRelationFilter, flightWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, couponWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    seat_reservation?: Seat_reservationListRelationFilter
  }, "id">

  export type reservationOrderByWithAggregationInput = {
    id?: SortOrder
    date_reservation?: SortOrder
    statut?: SortOrder
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    coupon_code?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    class_type?: SortOrder
    fare_type?: SortOrder
    user_id?: SortOrderInput | SortOrder
    flight_id?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    _count?: reservationCountOrderByAggregateInput
    _avg?: reservationAvgOrderByAggregateInput
    _max?: reservationMaxOrderByAggregateInput
    _min?: reservationMinOrderByAggregateInput
    _sum?: reservationSumOrderByAggregateInput
  }

  export type reservationScalarWhereWithAggregatesInput = {
    AND?: reservationScalarWhereWithAggregatesInput | reservationScalarWhereWithAggregatesInput[]
    OR?: reservationScalarWhereWithAggregatesInput[]
    NOT?: reservationScalarWhereWithAggregatesInput | reservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reservation"> | string
    date_reservation?: DateTimeWithAggregatesFilter<"reservation"> | Date | string
    statut?: StringWithAggregatesFilter<"reservation"> | string
    prix_total?: DecimalWithAggregatesFilter<"reservation"> | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntWithAggregatesFilter<"reservation"> | number
    coupon_code?: StringNullableWithAggregatesFilter<"reservation"> | string | null
    discount_amount?: DecimalNullableWithAggregatesFilter<"reservation"> | Decimal | DecimalJsLike | number | string | null
    class_type?: StringWithAggregatesFilter<"reservation"> | string
    fare_type?: StringWithAggregatesFilter<"reservation"> | string
    user_id?: StringNullableWithAggregatesFilter<"reservation"> | string | null
    flight_id?: StringNullableWithAggregatesFilter<"reservation"> | string | null
    coupon_id?: StringNullableWithAggregatesFilter<"reservation"> | string | null
  }

  export type seatWhereInput = {
    AND?: seatWhereInput | seatWhereInput[]
    OR?: seatWhereInput[]
    NOT?: seatWhereInput | seatWhereInput[]
    idSeat?: IntFilter<"seat"> | number
    seatNumber?: StringFilter<"seat"> | string
    classType?: Enumseat_classTypeFilter<"seat"> | $Enums.seat_classType
    availability?: IntFilter<"seat"> | number
    idPlane?: IntNullableFilter<"seat"> | number | null
    flight_seat_reservation?: Flight_seat_reservationListRelationFilter
    plane?: XOR<PlaneNullableScalarRelationFilter, planeWhereInput> | null
    seat_reservation?: Seat_reservationListRelationFilter
  }

  export type seatOrderByWithRelationInput = {
    idSeat?: SortOrder
    seatNumber?: SortOrder
    classType?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrderInput | SortOrder
    flight_seat_reservation?: flight_seat_reservationOrderByRelationAggregateInput
    plane?: planeOrderByWithRelationInput
    seat_reservation?: seat_reservationOrderByRelationAggregateInput
    _relevance?: seatOrderByRelevanceInput
  }

  export type seatWhereUniqueInput = Prisma.AtLeast<{
    idSeat?: number
    AND?: seatWhereInput | seatWhereInput[]
    OR?: seatWhereInput[]
    NOT?: seatWhereInput | seatWhereInput[]
    seatNumber?: StringFilter<"seat"> | string
    classType?: Enumseat_classTypeFilter<"seat"> | $Enums.seat_classType
    availability?: IntFilter<"seat"> | number
    idPlane?: IntNullableFilter<"seat"> | number | null
    flight_seat_reservation?: Flight_seat_reservationListRelationFilter
    plane?: XOR<PlaneNullableScalarRelationFilter, planeWhereInput> | null
    seat_reservation?: Seat_reservationListRelationFilter
  }, "idSeat">

  export type seatOrderByWithAggregationInput = {
    idSeat?: SortOrder
    seatNumber?: SortOrder
    classType?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrderInput | SortOrder
    _count?: seatCountOrderByAggregateInput
    _avg?: seatAvgOrderByAggregateInput
    _max?: seatMaxOrderByAggregateInput
    _min?: seatMinOrderByAggregateInput
    _sum?: seatSumOrderByAggregateInput
  }

  export type seatScalarWhereWithAggregatesInput = {
    AND?: seatScalarWhereWithAggregatesInput | seatScalarWhereWithAggregatesInput[]
    OR?: seatScalarWhereWithAggregatesInput[]
    NOT?: seatScalarWhereWithAggregatesInput | seatScalarWhereWithAggregatesInput[]
    idSeat?: IntWithAggregatesFilter<"seat"> | number
    seatNumber?: StringWithAggregatesFilter<"seat"> | string
    classType?: Enumseat_classTypeWithAggregatesFilter<"seat"> | $Enums.seat_classType
    availability?: IntWithAggregatesFilter<"seat"> | number
    idPlane?: IntNullableWithAggregatesFilter<"seat"> | number | null
  }

  export type seat_reservationWhereInput = {
    AND?: seat_reservationWhereInput | seat_reservationWhereInput[]
    OR?: seat_reservationWhereInput[]
    NOT?: seat_reservationWhereInput | seat_reservationWhereInput[]
    id?: IntFilter<"seat_reservation"> | number
    seat_id?: IntNullableFilter<"seat_reservation"> | number | null
    reservation_id?: StringNullableFilter<"seat_reservation"> | string | null
    flight_id?: StringNullableFilter<"seat_reservation"> | string | null
    flight?: XOR<FlightNullableScalarRelationFilter, flightWhereInput> | null
    reservation?: XOR<ReservationNullableScalarRelationFilter, reservationWhereInput> | null
    seat?: XOR<SeatNullableScalarRelationFilter, seatWhereInput> | null
  }

  export type seat_reservationOrderByWithRelationInput = {
    id?: SortOrder
    seat_id?: SortOrderInput | SortOrder
    reservation_id?: SortOrderInput | SortOrder
    flight_id?: SortOrderInput | SortOrder
    flight?: flightOrderByWithRelationInput
    reservation?: reservationOrderByWithRelationInput
    seat?: seatOrderByWithRelationInput
    _relevance?: seat_reservationOrderByRelevanceInput
  }

  export type seat_reservationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    seat_id_flight_id?: seat_reservationSeat_idFlight_idCompoundUniqueInput
    AND?: seat_reservationWhereInput | seat_reservationWhereInput[]
    OR?: seat_reservationWhereInput[]
    NOT?: seat_reservationWhereInput | seat_reservationWhereInput[]
    seat_id?: IntNullableFilter<"seat_reservation"> | number | null
    reservation_id?: StringNullableFilter<"seat_reservation"> | string | null
    flight_id?: StringNullableFilter<"seat_reservation"> | string | null
    flight?: XOR<FlightNullableScalarRelationFilter, flightWhereInput> | null
    reservation?: XOR<ReservationNullableScalarRelationFilter, reservationWhereInput> | null
    seat?: XOR<SeatNullableScalarRelationFilter, seatWhereInput> | null
  }, "id" | "seat_id_flight_id">

  export type seat_reservationOrderByWithAggregationInput = {
    id?: SortOrder
    seat_id?: SortOrderInput | SortOrder
    reservation_id?: SortOrderInput | SortOrder
    flight_id?: SortOrderInput | SortOrder
    _count?: seat_reservationCountOrderByAggregateInput
    _avg?: seat_reservationAvgOrderByAggregateInput
    _max?: seat_reservationMaxOrderByAggregateInput
    _min?: seat_reservationMinOrderByAggregateInput
    _sum?: seat_reservationSumOrderByAggregateInput
  }

  export type seat_reservationScalarWhereWithAggregatesInput = {
    AND?: seat_reservationScalarWhereWithAggregatesInput | seat_reservationScalarWhereWithAggregatesInput[]
    OR?: seat_reservationScalarWhereWithAggregatesInput[]
    NOT?: seat_reservationScalarWhereWithAggregatesInput | seat_reservationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"seat_reservation"> | number
    seat_id?: IntNullableWithAggregatesFilter<"seat_reservation"> | number | null
    reservation_id?: StringNullableWithAggregatesFilter<"seat_reservation"> | string | null
    flight_id?: StringNullableWithAggregatesFilter<"seat_reservation"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    nom?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    numero_telephone?: StringNullableFilter<"user"> | string | null
    pays?: StringNullableFilter<"user"> | string | null
    adresse?: StringNullableFilter<"user"> | string | null
    est_admin?: IntFilter<"user"> | number
    mot_de_passe?: StringFilter<"user"> | string
    compte?: XOR<CompteNullableScalarRelationFilter, compteWhereInput> | null
    contract?: ContractListRelationFilter
    reclamation?: ReclamationListRelationFilter
    request_solde?: Request_soldeListRelationFilter
    reservation?: ReservationListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    numero_telephone?: SortOrderInput | SortOrder
    pays?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    est_admin?: SortOrder
    mot_de_passe?: SortOrder
    compte?: compteOrderByWithRelationInput
    contract?: contractOrderByRelationAggregateInput
    reclamation?: reclamationOrderByRelationAggregateInput
    request_solde?: request_soldeOrderByRelationAggregateInput
    reservation?: reservationOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    nom?: StringFilter<"user"> | string
    numero_telephone?: StringNullableFilter<"user"> | string | null
    pays?: StringNullableFilter<"user"> | string | null
    adresse?: StringNullableFilter<"user"> | string | null
    est_admin?: IntFilter<"user"> | number
    mot_de_passe?: StringFilter<"user"> | string
    compte?: XOR<CompteNullableScalarRelationFilter, compteWhereInput> | null
    contract?: ContractListRelationFilter
    reclamation?: ReclamationListRelationFilter
    request_solde?: Request_soldeListRelationFilter
    reservation?: ReservationListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    numero_telephone?: SortOrderInput | SortOrder
    pays?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    est_admin?: SortOrder
    mot_de_passe?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    nom?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    numero_telephone?: StringNullableWithAggregatesFilter<"user"> | string | null
    pays?: StringNullableWithAggregatesFilter<"user"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"user"> | string | null
    est_admin?: IntWithAggregatesFilter<"user"> | number
    mot_de_passe?: StringWithAggregatesFilter<"user"> | string
  }

  export type airportCreateInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location?: locationCreateNestedOneWithoutAirportInput
    flight_flight_airport_depart_idToairport?: flightCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput
    flight_flight_airport_arrivee_idToairport?: flightCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput
  }

  export type airportUncheckedCreateInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location_id?: string | null
    flight_flight_airport_depart_idToairport?: flightUncheckedCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput
    flight_flight_airport_arrivee_idToairport?: flightUncheckedCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput
  }

  export type airportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location?: locationUpdateOneWithoutAirportNestedInput
    flight_flight_airport_depart_idToairport?: flightUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput
    flight_flight_airport_arrivee_idToairport?: flightUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput
  }

  export type airportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_flight_airport_depart_idToairport?: flightUncheckedUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput
    flight_flight_airport_arrivee_idToairport?: flightUncheckedUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput
  }

  export type airportCreateManyInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location_id?: string | null
  }

  export type airportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
  }

  export type airportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type compteCreateInput = {
    id: string
    solde?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user?: userCreateNestedOneWithoutCompteInput
  }

  export type compteUncheckedCreateInput = {
    id: string
    solde?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
  }

  export type compteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    solde?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutCompteNestedInput
  }

  export type compteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    solde?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type compteCreateManyInput = {
    id: string
    solde?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
  }

  export type compteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    solde?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type compteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    solde?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contractCreateInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    user?: userCreateNestedOneWithoutContractInput
    coupon?: couponCreateNestedOneWithoutContractInput
    contract_coupons?: contract_couponsCreateNestedManyWithoutContractInput
  }

  export type contractUncheckedCreateInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    coupon_id?: string | null
    contract_coupons?: contract_couponsUncheckedCreateNestedManyWithoutContractInput
  }

  export type contractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: userUpdateOneWithoutContractNestedInput
    coupon?: couponUpdateOneWithoutContractNestedInput
    contract_coupons?: contract_couponsUpdateManyWithoutContractNestedInput
  }

  export type contractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_coupons?: contract_couponsUncheckedUpdateManyWithoutContractNestedInput
  }

  export type contractCreateManyInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    coupon_id?: string | null
  }

  export type contractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type contractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contract_couponsCreateInput = {
    contract: contractCreateNestedOneWithoutContract_couponsInput
    coupon: couponCreateNestedOneWithoutContract_couponsInput
  }

  export type contract_couponsUncheckedCreateInput = {
    contract_id: string
    coupon_id: string
  }

  export type contract_couponsUpdateInput = {
    contract?: contractUpdateOneRequiredWithoutContract_couponsNestedInput
    coupon?: couponUpdateOneRequiredWithoutContract_couponsNestedInput
  }

  export type contract_couponsUncheckedUpdateInput = {
    contract_id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
  }

  export type contract_couponsCreateManyInput = {
    contract_id: string
    coupon_id: string
  }

  export type contract_couponsUpdateManyMutationInput = {

  }

  export type contract_couponsUncheckedUpdateManyInput = {
    contract_id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
  }

  export type couponCreateInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract?: contractCreateNestedManyWithoutCouponInput
    contract_coupons?: contract_couponsCreateNestedManyWithoutCouponInput
    reservation?: reservationCreateNestedManyWithoutCouponInput
  }

  export type couponUncheckedCreateInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract?: contractUncheckedCreateNestedManyWithoutCouponInput
    contract_coupons?: contract_couponsUncheckedCreateNestedManyWithoutCouponInput
    reservation?: reservationUncheckedCreateNestedManyWithoutCouponInput
  }

  export type couponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: contractUpdateManyWithoutCouponNestedInput
    contract_coupons?: contract_couponsUpdateManyWithoutCouponNestedInput
    reservation?: reservationUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: contractUncheckedUpdateManyWithoutCouponNestedInput
    contract_coupons?: contract_couponsUncheckedUpdateManyWithoutCouponNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type couponCreateManyInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
  }

  export type couponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type couponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type flightCreateInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    plane?: planeCreateNestedOneWithoutFlightInput
    airport_flight_airport_depart_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput
    airport_flight_airport_arrivee_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutFlightInput
    reservation?: reservationCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
    plane_id?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput
    reservation?: reservationUncheckedCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plane?: planeUpdateOneWithoutFlightNestedInput
    airport_flight_airport_depart_idToairport?: airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput
    airport_flight_airport_arrivee_idToairport?: airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutFlightNestedInput
    reservation?: reservationUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightCreateManyInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
    plane_id?: number | null
  }

  export type flightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type flightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type flight_seat_reservationCreateInput = {
    id: string
    isReserved?: number
    seat?: seatCreateNestedOneWithoutFlight_seat_reservationInput
    flight?: flightCreateNestedOneWithoutFlight_seat_reservationInput
    reservation?: reservationCreateNestedOneWithoutFlight_seat_reservationInput
  }

  export type flight_seat_reservationUncheckedCreateInput = {
    id: string
    isReserved?: number
    flight_id?: string | null
    seat_id?: number | null
    reservation_id?: string | null
  }

  export type flight_seat_reservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    seat?: seatUpdateOneWithoutFlight_seat_reservationNestedInput
    flight?: flightUpdateOneWithoutFlight_seat_reservationNestedInput
    reservation?: reservationUpdateOneWithoutFlight_seat_reservationNestedInput
  }

  export type flight_seat_reservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type flight_seat_reservationCreateManyInput = {
    id: string
    isReserved?: number
    flight_id?: string | null
    seat_id?: number | null
    reservation_id?: string | null
  }

  export type flight_seat_reservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
  }

  export type flight_seat_reservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationCreateInput = {
    id: string
    nom: string
    pays: string
    ville: string
    description?: string | null
    url_image?: string | null
    airport?: airportCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id: string
    nom: string
    pays: string
    ville: string
    description?: string | null
    url_image?: string | null
    airport?: airportUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url_image?: NullableStringFieldUpdateOperationsInput | string | null
    airport?: airportUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url_image?: NullableStringFieldUpdateOperationsInput | string | null
    airport?: airportUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationCreateManyInput = {
    id: string
    nom: string
    pays: string
    ville: string
    description?: string | null
    url_image?: string | null
  }

  export type locationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsCreateInput = {
    id: string
    titre: string
    contenu: string
    image_url?: string | null
    date_creation?: Date | string
  }

  export type newsUncheckedCreateInput = {
    id: string
    titre: string
    contenu: string
    image_url?: string | null
    date_creation?: Date | string
  }

  export type newsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type newsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type newsCreateManyInput = {
    id: string
    titre: string
    contenu: string
    image_url?: string | null
    date_creation?: Date | string
  }

  export type newsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type newsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type planeCreateInput = {
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    flight?: flightCreateNestedManyWithoutPlaneInput
    seat?: seatCreateNestedManyWithoutPlaneInput
  }

  export type planeUncheckedCreateInput = {
    idPlane?: number
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    flight?: flightUncheckedCreateNestedManyWithoutPlaneInput
    seat?: seatUncheckedCreateNestedManyWithoutPlaneInput
  }

  export type planeUpdateInput = {
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
    flight?: flightUpdateManyWithoutPlaneNestedInput
    seat?: seatUpdateManyWithoutPlaneNestedInput
  }

  export type planeUncheckedUpdateInput = {
    idPlane?: IntFieldUpdateOperationsInput | number
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
    flight?: flightUncheckedUpdateManyWithoutPlaneNestedInput
    seat?: seatUncheckedUpdateManyWithoutPlaneNestedInput
  }

  export type planeCreateManyInput = {
    idPlane?: number
    planeModel: string
    totalSeats: number
    seatConfiguration: string
  }

  export type planeUpdateManyMutationInput = {
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
  }

  export type planeUncheckedUpdateManyInput = {
    idPlane?: IntFieldUpdateOperationsInput | number
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
  }

  export type reclamationCreateInput = {
    id: string
    sujet: string
    description: string
    statut?: string
    date_creation?: Date | string
    reponse?: string | null
    date_reponse?: Date | string | null
    user?: userCreateNestedOneWithoutReclamationInput
  }

  export type reclamationUncheckedCreateInput = {
    id: string
    sujet: string
    description: string
    statut?: string
    date_creation?: Date | string
    reponse?: string | null
    date_reponse?: Date | string | null
    user_id?: string | null
  }

  export type reclamationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutReclamationNestedInput
  }

  export type reclamationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reclamationCreateManyInput = {
    id: string
    sujet: string
    description: string
    statut?: string
    date_creation?: Date | string
    reponse?: string | null
    date_reponse?: Date | string | null
    user_id?: string | null
  }

  export type reclamationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reclamationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type request_soldeCreateInput = {
    id: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    date?: Date | string
    status?: $Enums.request_solde_status
    imageUrl?: string | null
    user?: userCreateNestedOneWithoutRequest_soldeInput
  }

  export type request_soldeUncheckedCreateInput = {
    id: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    date?: Date | string
    status?: $Enums.request_solde_status
    imageUrl?: string | null
    client_id?: string | null
  }

  export type request_soldeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutRequest_soldeNestedInput
  }

  export type request_soldeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type request_soldeCreateManyInput = {
    id: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    date?: Date | string
    status?: $Enums.request_solde_status
    imageUrl?: string | null
    client_id?: string | null
  }

  export type request_soldeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type request_soldeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationCreateInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutReservationInput
    flight?: flightCreateNestedOneWithoutReservationInput
    coupon?: couponCreateNestedOneWithoutReservationInput
    user?: userCreateNestedOneWithoutReservationInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    flight_id?: string | null
    coupon_id?: string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutReservationInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutReservationNestedInput
    flight?: flightUpdateOneWithoutReservationNestedInput
    coupon?: couponUpdateOneWithoutReservationNestedInput
    user?: userUpdateOneWithoutReservationNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type reservationCreateManyInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    flight_id?: string | null
    coupon_id?: string | null
  }

  export type reservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
  }

  export type reservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seatCreateInput = {
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutSeatInput
    plane?: planeCreateNestedOneWithoutSeatInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutSeatInput
  }

  export type seatUncheckedCreateInput = {
    idSeat?: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    idPlane?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutSeatInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutSeatInput
  }

  export type seatUpdateInput = {
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutSeatNestedInput
    plane?: planeUpdateOneWithoutSeatNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateInput = {
    idSeat?: IntFieldUpdateOperationsInput | number
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    idPlane?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutSeatNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type seatCreateManyInput = {
    idSeat?: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    idPlane?: number | null
  }

  export type seatUpdateManyMutationInput = {
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
  }

  export type seatUncheckedUpdateManyInput = {
    idSeat?: IntFieldUpdateOperationsInput | number
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    idPlane?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type seat_reservationCreateInput = {
    flight?: flightCreateNestedOneWithoutSeat_reservationInput
    reservation?: reservationCreateNestedOneWithoutSeat_reservationInput
    seat?: seatCreateNestedOneWithoutSeat_reservationInput
  }

  export type seat_reservationUncheckedCreateInput = {
    id?: number
    seat_id?: number | null
    reservation_id?: string | null
    flight_id?: string | null
  }

  export type seat_reservationUpdateInput = {
    flight?: flightUpdateOneWithoutSeat_reservationNestedInput
    reservation?: reservationUpdateOneWithoutSeat_reservationNestedInput
    seat?: seatUpdateOneWithoutSeat_reservationNestedInput
  }

  export type seat_reservationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seat_reservationCreateManyInput = {
    id?: number
    seat_id?: number | null
    reservation_id?: string | null
    flight_id?: string | null
  }

  export type seat_reservationUpdateManyMutationInput = {

  }

  export type seat_reservationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteCreateNestedOneWithoutUserInput
    contract?: contractCreateNestedManyWithoutUserInput
    reclamation?: reclamationCreateNestedManyWithoutUserInput
    request_solde?: request_soldeCreateNestedManyWithoutUserInput
    reservation?: reservationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteUncheckedCreateNestedOneWithoutUserInput
    contract?: contractUncheckedCreateNestedManyWithoutUserInput
    reclamation?: reclamationUncheckedCreateNestedManyWithoutUserInput
    request_solde?: request_soldeUncheckedCreateNestedManyWithoutUserInput
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUpdateOneWithoutUserNestedInput
    contract?: contractUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUpdateManyWithoutUserNestedInput
    reservation?: reservationUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUncheckedUpdateOneWithoutUserNestedInput
    contract?: contractUncheckedUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUncheckedUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUncheckedUpdateManyWithoutUserNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LocationNullableScalarRelationFilter = {
    is?: locationWhereInput | null
    isNot?: locationWhereInput | null
  }

  export type FlightListRelationFilter = {
    every?: flightWhereInput
    some?: flightWhereInput
    none?: flightWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type flightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type airportOrderByRelevanceInput = {
    fields: airportOrderByRelevanceFieldEnum | airportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type airportCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    pays?: SortOrder
    description?: SortOrder
    est_actif?: SortOrder
    location_id?: SortOrder
  }

  export type airportAvgOrderByAggregateInput = {
    est_actif?: SortOrder
  }

  export type airportMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    pays?: SortOrder
    description?: SortOrder
    est_actif?: SortOrder
    location_id?: SortOrder
  }

  export type airportMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    pays?: SortOrder
    description?: SortOrder
    est_actif?: SortOrder
    location_id?: SortOrder
  }

  export type airportSumOrderByAggregateInput = {
    est_actif?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type compteOrderByRelevanceInput = {
    fields: compteOrderByRelevanceFieldEnum | compteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type compteCountOrderByAggregateInput = {
    id?: SortOrder
    solde?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type compteAvgOrderByAggregateInput = {
    solde?: SortOrder
  }

  export type compteMaxOrderByAggregateInput = {
    id?: SortOrder
    solde?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type compteMinOrderByAggregateInput = {
    id?: SortOrder
    solde?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type compteSumOrderByAggregateInput = {
    solde?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CouponNullableScalarRelationFilter = {
    is?: couponWhereInput | null
    isNot?: couponWhereInput | null
  }

  export type Contract_couponsListRelationFilter = {
    every?: contract_couponsWhereInput
    some?: contract_couponsWhereInput
    none?: contract_couponsWhereInput
  }

  export type contract_couponsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contractOrderByRelevanceInput = {
    fields: contractOrderByRelevanceFieldEnum | contractOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contractCountOrderByAggregateInput = {
    id?: SortOrder
    clientType?: SortOrder
    label?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    guaranteedMinimum?: SortOrder
    travelStartDate?: SortOrder
    travelEndDate?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrder
    minTimeBeforeBalanceFlight?: SortOrder
    invoiceStamp?: SortOrder
    finalClientAdditionalFees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    fixedTicketPrice?: SortOrder
    coupon_id?: SortOrder
  }

  export type contractAvgOrderByAggregateInput = {
    guaranteedMinimum?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrder
    minTimeBeforeBalanceFlight?: SortOrder
    invoiceStamp?: SortOrder
    finalClientAdditionalFees?: SortOrder
    fixedTicketPrice?: SortOrder
  }

  export type contractMaxOrderByAggregateInput = {
    id?: SortOrder
    clientType?: SortOrder
    label?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    guaranteedMinimum?: SortOrder
    travelStartDate?: SortOrder
    travelEndDate?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrder
    minTimeBeforeBalanceFlight?: SortOrder
    invoiceStamp?: SortOrder
    finalClientAdditionalFees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    fixedTicketPrice?: SortOrder
    coupon_id?: SortOrder
  }

  export type contractMinOrderByAggregateInput = {
    id?: SortOrder
    clientType?: SortOrder
    label?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    guaranteedMinimum?: SortOrder
    travelStartDate?: SortOrder
    travelEndDate?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrder
    minTimeBeforeBalanceFlight?: SortOrder
    invoiceStamp?: SortOrder
    finalClientAdditionalFees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    fixedTicketPrice?: SortOrder
    coupon_id?: SortOrder
  }

  export type contractSumOrderByAggregateInput = {
    guaranteedMinimum?: SortOrder
    isActive?: SortOrder
    modifiedFeeAmount?: SortOrder
    payLater?: SortOrder
    payLaterTimeLimit?: SortOrder
    minTimeBeforeBalanceFlight?: SortOrder
    invoiceStamp?: SortOrder
    finalClientAdditionalFees?: SortOrder
    fixedTicketPrice?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContractScalarRelationFilter = {
    is?: contractWhereInput
    isNot?: contractWhereInput
  }

  export type CouponScalarRelationFilter = {
    is?: couponWhereInput
    isNot?: couponWhereInput
  }

  export type contract_couponsOrderByRelevanceInput = {
    fields: contract_couponsOrderByRelevanceFieldEnum | contract_couponsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contract_couponsContract_idCoupon_idCompoundUniqueInput = {
    contract_id: string
    coupon_id: string
  }

  export type contract_couponsCountOrderByAggregateInput = {
    contract_id?: SortOrder
    coupon_id?: SortOrder
  }

  export type contract_couponsMaxOrderByAggregateInput = {
    contract_id?: SortOrder
    coupon_id?: SortOrder
  }

  export type contract_couponsMinOrderByAggregateInput = {
    contract_id?: SortOrder
    coupon_id?: SortOrder
  }

  export type Enumcoupon_reduction_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.coupon_reduction_type | Enumcoupon_reduction_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coupon_reduction_type[]
    notIn?: $Enums.coupon_reduction_type[]
    not?: NestedEnumcoupon_reduction_typeFilter<$PrismaModel> | $Enums.coupon_reduction_type
  }

  export type ContractListRelationFilter = {
    every?: contractWhereInput
    some?: contractWhereInput
    none?: contractWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: reservationWhereInput
    some?: reservationWhereInput
    none?: reservationWhereInput
  }

  export type contractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type couponOrderByRelevanceInput = {
    fields: couponOrderByRelevanceFieldEnum | couponOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type couponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    reduction?: SortOrder
    reduction_type?: SortOrder
    date_fin?: SortOrder
    date_creation?: SortOrder
  }

  export type couponAvgOrderByAggregateInput = {
    reduction?: SortOrder
  }

  export type couponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    reduction?: SortOrder
    reduction_type?: SortOrder
    date_fin?: SortOrder
    date_creation?: SortOrder
  }

  export type couponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    reduction?: SortOrder
    reduction_type?: SortOrder
    date_fin?: SortOrder
    date_creation?: SortOrder
  }

  export type couponSumOrderByAggregateInput = {
    reduction?: SortOrder
  }

  export type Enumcoupon_reduction_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.coupon_reduction_type | Enumcoupon_reduction_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coupon_reduction_type[]
    notIn?: $Enums.coupon_reduction_type[]
    not?: NestedEnumcoupon_reduction_typeWithAggregatesFilter<$PrismaModel> | $Enums.coupon_reduction_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcoupon_reduction_typeFilter<$PrismaModel>
    _max?: NestedEnumcoupon_reduction_typeFilter<$PrismaModel>
  }

  export type PlaneNullableScalarRelationFilter = {
    is?: planeWhereInput | null
    isNot?: planeWhereInput | null
  }

  export type AirportNullableScalarRelationFilter = {
    is?: airportWhereInput | null
    isNot?: airportWhereInput | null
  }

  export type Flight_seat_reservationListRelationFilter = {
    every?: flight_seat_reservationWhereInput
    some?: flight_seat_reservationWhereInput
    none?: flight_seat_reservationWhereInput
  }

  export type Seat_reservationListRelationFilter = {
    every?: seat_reservationWhereInput
    some?: seat_reservationWhereInput
    none?: seat_reservationWhereInput
  }

  export type flight_seat_reservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type seat_reservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type flightOrderByRelevanceInput = {
    fields: flightOrderByRelevanceFieldEnum | flightOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type flightCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    prix?: SortOrder
    date_depart?: SortOrder
    date_retour?: SortOrder
    duree?: SortOrder
    status?: SortOrder
    airport_depart_id?: SortOrder
    airport_arrivee_id?: SortOrder
    plane_id?: SortOrder
  }

  export type flightAvgOrderByAggregateInput = {
    prix?: SortOrder
    plane_id?: SortOrder
  }

  export type flightMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    prix?: SortOrder
    date_depart?: SortOrder
    date_retour?: SortOrder
    duree?: SortOrder
    status?: SortOrder
    airport_depart_id?: SortOrder
    airport_arrivee_id?: SortOrder
    plane_id?: SortOrder
  }

  export type flightMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    prix?: SortOrder
    date_depart?: SortOrder
    date_retour?: SortOrder
    duree?: SortOrder
    status?: SortOrder
    airport_depart_id?: SortOrder
    airport_arrivee_id?: SortOrder
    plane_id?: SortOrder
  }

  export type flightSumOrderByAggregateInput = {
    prix?: SortOrder
    plane_id?: SortOrder
  }

  export type SeatNullableScalarRelationFilter = {
    is?: seatWhereInput | null
    isNot?: seatWhereInput | null
  }

  export type FlightNullableScalarRelationFilter = {
    is?: flightWhereInput | null
    isNot?: flightWhereInput | null
  }

  export type ReservationNullableScalarRelationFilter = {
    is?: reservationWhereInput | null
    isNot?: reservationWhereInput | null
  }

  export type flight_seat_reservationOrderByRelevanceInput = {
    fields: flight_seat_reservationOrderByRelevanceFieldEnum | flight_seat_reservationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type flight_seat_reservationCountOrderByAggregateInput = {
    id?: SortOrder
    isReserved?: SortOrder
    flight_id?: SortOrder
    seat_id?: SortOrder
    reservation_id?: SortOrder
  }

  export type flight_seat_reservationAvgOrderByAggregateInput = {
    isReserved?: SortOrder
    seat_id?: SortOrder
  }

  export type flight_seat_reservationMaxOrderByAggregateInput = {
    id?: SortOrder
    isReserved?: SortOrder
    flight_id?: SortOrder
    seat_id?: SortOrder
    reservation_id?: SortOrder
  }

  export type flight_seat_reservationMinOrderByAggregateInput = {
    id?: SortOrder
    isReserved?: SortOrder
    flight_id?: SortOrder
    seat_id?: SortOrder
    reservation_id?: SortOrder
  }

  export type flight_seat_reservationSumOrderByAggregateInput = {
    isReserved?: SortOrder
    seat_id?: SortOrder
  }

  export type AirportListRelationFilter = {
    every?: airportWhereInput
    some?: airportWhereInput
    none?: airportWhereInput
  }

  export type airportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationOrderByRelevanceInput = {
    fields: locationOrderByRelevanceFieldEnum | locationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type locationCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    pays?: SortOrder
    ville?: SortOrder
    description?: SortOrder
    url_image?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    pays?: SortOrder
    ville?: SortOrder
    description?: SortOrder
    url_image?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    pays?: SortOrder
    ville?: SortOrder
    description?: SortOrder
    url_image?: SortOrder
  }

  export type newsOrderByRelevanceInput = {
    fields: newsOrderByRelevanceFieldEnum | newsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type newsCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    image_url?: SortOrder
    date_creation?: SortOrder
  }

  export type newsMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    image_url?: SortOrder
    date_creation?: SortOrder
  }

  export type newsMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    image_url?: SortOrder
    date_creation?: SortOrder
  }

  export type SeatListRelationFilter = {
    every?: seatWhereInput
    some?: seatWhereInput
    none?: seatWhereInput
  }

  export type seatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type planeOrderByRelevanceInput = {
    fields: planeOrderByRelevanceFieldEnum | planeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type planeCountOrderByAggregateInput = {
    idPlane?: SortOrder
    planeModel?: SortOrder
    totalSeats?: SortOrder
    seatConfiguration?: SortOrder
  }

  export type planeAvgOrderByAggregateInput = {
    idPlane?: SortOrder
    totalSeats?: SortOrder
  }

  export type planeMaxOrderByAggregateInput = {
    idPlane?: SortOrder
    planeModel?: SortOrder
    totalSeats?: SortOrder
    seatConfiguration?: SortOrder
  }

  export type planeMinOrderByAggregateInput = {
    idPlane?: SortOrder
    planeModel?: SortOrder
    totalSeats?: SortOrder
    seatConfiguration?: SortOrder
  }

  export type planeSumOrderByAggregateInput = {
    idPlane?: SortOrder
    totalSeats?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type reclamationOrderByRelevanceInput = {
    fields: reclamationOrderByRelevanceFieldEnum | reclamationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type reclamationCountOrderByAggregateInput = {
    id?: SortOrder
    sujet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    date_creation?: SortOrder
    reponse?: SortOrder
    date_reponse?: SortOrder
    user_id?: SortOrder
  }

  export type reclamationMaxOrderByAggregateInput = {
    id?: SortOrder
    sujet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    date_creation?: SortOrder
    reponse?: SortOrder
    date_reponse?: SortOrder
    user_id?: SortOrder
  }

  export type reclamationMinOrderByAggregateInput = {
    id?: SortOrder
    sujet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    date_creation?: SortOrder
    reponse?: SortOrder
    date_reponse?: SortOrder
    user_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumrequest_solde_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.request_solde_status | Enumrequest_solde_statusFieldRefInput<$PrismaModel>
    in?: $Enums.request_solde_status[]
    notIn?: $Enums.request_solde_status[]
    not?: NestedEnumrequest_solde_statusFilter<$PrismaModel> | $Enums.request_solde_status
  }

  export type request_soldeOrderByRelevanceInput = {
    fields: request_soldeOrderByRelevanceFieldEnum | request_soldeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type request_soldeCountOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    client_id?: SortOrder
  }

  export type request_soldeAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type request_soldeMaxOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    client_id?: SortOrder
  }

  export type request_soldeMinOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    client_id?: SortOrder
  }

  export type request_soldeSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type Enumrequest_solde_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.request_solde_status | Enumrequest_solde_statusFieldRefInput<$PrismaModel>
    in?: $Enums.request_solde_status[]
    notIn?: $Enums.request_solde_status[]
    not?: NestedEnumrequest_solde_statusWithAggregatesFilter<$PrismaModel> | $Enums.request_solde_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrequest_solde_statusFilter<$PrismaModel>
    _max?: NestedEnumrequest_solde_statusFilter<$PrismaModel>
  }

  export type reservationOrderByRelevanceInput = {
    fields: reservationOrderByRelevanceFieldEnum | reservationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type reservationCountOrderByAggregateInput = {
    id?: SortOrder
    date_reservation?: SortOrder
    statut?: SortOrder
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    coupon_code?: SortOrder
    discount_amount?: SortOrder
    class_type?: SortOrder
    fare_type?: SortOrder
    user_id?: SortOrder
    flight_id?: SortOrder
    coupon_id?: SortOrder
  }

  export type reservationAvgOrderByAggregateInput = {
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    discount_amount?: SortOrder
  }

  export type reservationMaxOrderByAggregateInput = {
    id?: SortOrder
    date_reservation?: SortOrder
    statut?: SortOrder
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    coupon_code?: SortOrder
    discount_amount?: SortOrder
    class_type?: SortOrder
    fare_type?: SortOrder
    user_id?: SortOrder
    flight_id?: SortOrder
    coupon_id?: SortOrder
  }

  export type reservationMinOrderByAggregateInput = {
    id?: SortOrder
    date_reservation?: SortOrder
    statut?: SortOrder
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    coupon_code?: SortOrder
    discount_amount?: SortOrder
    class_type?: SortOrder
    fare_type?: SortOrder
    user_id?: SortOrder
    flight_id?: SortOrder
    coupon_id?: SortOrder
  }

  export type reservationSumOrderByAggregateInput = {
    prix_total?: SortOrder
    nombre_passagers?: SortOrder
    discount_amount?: SortOrder
  }

  export type Enumseat_classTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.seat_classType | Enumseat_classTypeFieldRefInput<$PrismaModel>
    in?: $Enums.seat_classType[]
    notIn?: $Enums.seat_classType[]
    not?: NestedEnumseat_classTypeFilter<$PrismaModel> | $Enums.seat_classType
  }

  export type seatOrderByRelevanceInput = {
    fields: seatOrderByRelevanceFieldEnum | seatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type seatCountOrderByAggregateInput = {
    idSeat?: SortOrder
    seatNumber?: SortOrder
    classType?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrder
  }

  export type seatAvgOrderByAggregateInput = {
    idSeat?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrder
  }

  export type seatMaxOrderByAggregateInput = {
    idSeat?: SortOrder
    seatNumber?: SortOrder
    classType?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrder
  }

  export type seatMinOrderByAggregateInput = {
    idSeat?: SortOrder
    seatNumber?: SortOrder
    classType?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrder
  }

  export type seatSumOrderByAggregateInput = {
    idSeat?: SortOrder
    availability?: SortOrder
    idPlane?: SortOrder
  }

  export type Enumseat_classTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.seat_classType | Enumseat_classTypeFieldRefInput<$PrismaModel>
    in?: $Enums.seat_classType[]
    notIn?: $Enums.seat_classType[]
    not?: NestedEnumseat_classTypeWithAggregatesFilter<$PrismaModel> | $Enums.seat_classType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumseat_classTypeFilter<$PrismaModel>
    _max?: NestedEnumseat_classTypeFilter<$PrismaModel>
  }

  export type seat_reservationOrderByRelevanceInput = {
    fields: seat_reservationOrderByRelevanceFieldEnum | seat_reservationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type seat_reservationSeat_idFlight_idCompoundUniqueInput = {
    seat_id: number
    flight_id: string
  }

  export type seat_reservationCountOrderByAggregateInput = {
    id?: SortOrder
    seat_id?: SortOrder
    reservation_id?: SortOrder
    flight_id?: SortOrder
  }

  export type seat_reservationAvgOrderByAggregateInput = {
    id?: SortOrder
    seat_id?: SortOrder
  }

  export type seat_reservationMaxOrderByAggregateInput = {
    id?: SortOrder
    seat_id?: SortOrder
    reservation_id?: SortOrder
    flight_id?: SortOrder
  }

  export type seat_reservationMinOrderByAggregateInput = {
    id?: SortOrder
    seat_id?: SortOrder
    reservation_id?: SortOrder
    flight_id?: SortOrder
  }

  export type seat_reservationSumOrderByAggregateInput = {
    id?: SortOrder
    seat_id?: SortOrder
  }

  export type CompteNullableScalarRelationFilter = {
    is?: compteWhereInput | null
    isNot?: compteWhereInput | null
  }

  export type ReclamationListRelationFilter = {
    every?: reclamationWhereInput
    some?: reclamationWhereInput
    none?: reclamationWhereInput
  }

  export type Request_soldeListRelationFilter = {
    every?: request_soldeWhereInput
    some?: request_soldeWhereInput
    none?: request_soldeWhereInput
  }

  export type reclamationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type request_soldeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    numero_telephone?: SortOrder
    pays?: SortOrder
    adresse?: SortOrder
    est_admin?: SortOrder
    mot_de_passe?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    est_admin?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    numero_telephone?: SortOrder
    pays?: SortOrder
    adresse?: SortOrder
    est_admin?: SortOrder
    mot_de_passe?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    numero_telephone?: SortOrder
    pays?: SortOrder
    adresse?: SortOrder
    est_admin?: SortOrder
    mot_de_passe?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    est_admin?: SortOrder
  }

  export type locationCreateNestedOneWithoutAirportInput = {
    create?: XOR<locationCreateWithoutAirportInput, locationUncheckedCreateWithoutAirportInput>
    connectOrCreate?: locationCreateOrConnectWithoutAirportInput
    connect?: locationWhereUniqueInput
  }

  export type flightCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput> | flightCreateWithoutAirport_flight_airport_depart_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_depart_idToairportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type flightCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput> | flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_arrivee_idToairportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type flightUncheckedCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput> | flightCreateWithoutAirport_flight_airport_depart_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_depart_idToairportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type flightUncheckedCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput> | flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_arrivee_idToairportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type locationUpdateOneWithoutAirportNestedInput = {
    create?: XOR<locationCreateWithoutAirportInput, locationUncheckedCreateWithoutAirportInput>
    connectOrCreate?: locationCreateOrConnectWithoutAirportInput
    upsert?: locationUpsertWithoutAirportInput
    disconnect?: locationWhereInput | boolean
    delete?: locationWhereInput | boolean
    connect?: locationWhereUniqueInput
    update?: XOR<XOR<locationUpdateToOneWithWhereWithoutAirportInput, locationUpdateWithoutAirportInput>, locationUncheckedUpdateWithoutAirportInput>
  }

  export type flightUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput> | flightCreateWithoutAirport_flight_airport_depart_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput | flightUpsertWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_depart_idToairportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput | flightUpdateWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutAirport_flight_airport_depart_idToairportInput | flightUpdateManyWithWhereWithoutAirport_flight_airport_depart_idToairportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type flightUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput> | flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput | flightUpsertWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_arrivee_idToairportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput | flightUpdateWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutAirport_flight_airport_arrivee_idToairportInput | flightUpdateManyWithWhereWithoutAirport_flight_airport_arrivee_idToairportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type flightUncheckedUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput> | flightCreateWithoutAirport_flight_airport_depart_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput | flightUpsertWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_depart_idToairportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput | flightUpdateWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutAirport_flight_airport_depart_idToairportInput | flightUpdateManyWithWhereWithoutAirport_flight_airport_depart_idToairportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type flightUncheckedUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput = {
    create?: XOR<flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput> | flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput[] | flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput | flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput | flightUpsertWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput[]
    createMany?: flightCreateManyAirport_flight_airport_arrivee_idToairportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput | flightUpdateWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutAirport_flight_airport_arrivee_idToairportInput | flightUpdateManyWithWhereWithoutAirport_flight_airport_arrivee_idToairportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutCompteInput = {
    create?: XOR<userCreateWithoutCompteInput, userUncheckedCreateWithoutCompteInput>
    connectOrCreate?: userCreateOrConnectWithoutCompteInput
    connect?: userWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type userUpdateOneWithoutCompteNestedInput = {
    create?: XOR<userCreateWithoutCompteInput, userUncheckedCreateWithoutCompteInput>
    connectOrCreate?: userCreateOrConnectWithoutCompteInput
    upsert?: userUpsertWithoutCompteInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCompteInput, userUpdateWithoutCompteInput>, userUncheckedUpdateWithoutCompteInput>
  }

  export type userCreateNestedOneWithoutContractInput = {
    create?: XOR<userCreateWithoutContractInput, userUncheckedCreateWithoutContractInput>
    connectOrCreate?: userCreateOrConnectWithoutContractInput
    connect?: userWhereUniqueInput
  }

  export type couponCreateNestedOneWithoutContractInput = {
    create?: XOR<couponCreateWithoutContractInput, couponUncheckedCreateWithoutContractInput>
    connectOrCreate?: couponCreateOrConnectWithoutContractInput
    connect?: couponWhereUniqueInput
  }

  export type contract_couponsCreateNestedManyWithoutContractInput = {
    create?: XOR<contract_couponsCreateWithoutContractInput, contract_couponsUncheckedCreateWithoutContractInput> | contract_couponsCreateWithoutContractInput[] | contract_couponsUncheckedCreateWithoutContractInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutContractInput | contract_couponsCreateOrConnectWithoutContractInput[]
    createMany?: contract_couponsCreateManyContractInputEnvelope
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
  }

  export type contract_couponsUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<contract_couponsCreateWithoutContractInput, contract_couponsUncheckedCreateWithoutContractInput> | contract_couponsCreateWithoutContractInput[] | contract_couponsUncheckedCreateWithoutContractInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutContractInput | contract_couponsCreateOrConnectWithoutContractInput[]
    createMany?: contract_couponsCreateManyContractInputEnvelope
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUpdateOneWithoutContractNestedInput = {
    create?: XOR<userCreateWithoutContractInput, userUncheckedCreateWithoutContractInput>
    connectOrCreate?: userCreateOrConnectWithoutContractInput
    upsert?: userUpsertWithoutContractInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutContractInput, userUpdateWithoutContractInput>, userUncheckedUpdateWithoutContractInput>
  }

  export type couponUpdateOneWithoutContractNestedInput = {
    create?: XOR<couponCreateWithoutContractInput, couponUncheckedCreateWithoutContractInput>
    connectOrCreate?: couponCreateOrConnectWithoutContractInput
    upsert?: couponUpsertWithoutContractInput
    disconnect?: couponWhereInput | boolean
    delete?: couponWhereInput | boolean
    connect?: couponWhereUniqueInput
    update?: XOR<XOR<couponUpdateToOneWithWhereWithoutContractInput, couponUpdateWithoutContractInput>, couponUncheckedUpdateWithoutContractInput>
  }

  export type contract_couponsUpdateManyWithoutContractNestedInput = {
    create?: XOR<contract_couponsCreateWithoutContractInput, contract_couponsUncheckedCreateWithoutContractInput> | contract_couponsCreateWithoutContractInput[] | contract_couponsUncheckedCreateWithoutContractInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutContractInput | contract_couponsCreateOrConnectWithoutContractInput[]
    upsert?: contract_couponsUpsertWithWhereUniqueWithoutContractInput | contract_couponsUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: contract_couponsCreateManyContractInputEnvelope
    set?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    disconnect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    delete?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    update?: contract_couponsUpdateWithWhereUniqueWithoutContractInput | contract_couponsUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: contract_couponsUpdateManyWithWhereWithoutContractInput | contract_couponsUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: contract_couponsScalarWhereInput | contract_couponsScalarWhereInput[]
  }

  export type contract_couponsUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<contract_couponsCreateWithoutContractInput, contract_couponsUncheckedCreateWithoutContractInput> | contract_couponsCreateWithoutContractInput[] | contract_couponsUncheckedCreateWithoutContractInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutContractInput | contract_couponsCreateOrConnectWithoutContractInput[]
    upsert?: contract_couponsUpsertWithWhereUniqueWithoutContractInput | contract_couponsUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: contract_couponsCreateManyContractInputEnvelope
    set?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    disconnect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    delete?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    update?: contract_couponsUpdateWithWhereUniqueWithoutContractInput | contract_couponsUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: contract_couponsUpdateManyWithWhereWithoutContractInput | contract_couponsUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: contract_couponsScalarWhereInput | contract_couponsScalarWhereInput[]
  }

  export type contractCreateNestedOneWithoutContract_couponsInput = {
    create?: XOR<contractCreateWithoutContract_couponsInput, contractUncheckedCreateWithoutContract_couponsInput>
    connectOrCreate?: contractCreateOrConnectWithoutContract_couponsInput
    connect?: contractWhereUniqueInput
  }

  export type couponCreateNestedOneWithoutContract_couponsInput = {
    create?: XOR<couponCreateWithoutContract_couponsInput, couponUncheckedCreateWithoutContract_couponsInput>
    connectOrCreate?: couponCreateOrConnectWithoutContract_couponsInput
    connect?: couponWhereUniqueInput
  }

  export type contractUpdateOneRequiredWithoutContract_couponsNestedInput = {
    create?: XOR<contractCreateWithoutContract_couponsInput, contractUncheckedCreateWithoutContract_couponsInput>
    connectOrCreate?: contractCreateOrConnectWithoutContract_couponsInput
    upsert?: contractUpsertWithoutContract_couponsInput
    connect?: contractWhereUniqueInput
    update?: XOR<XOR<contractUpdateToOneWithWhereWithoutContract_couponsInput, contractUpdateWithoutContract_couponsInput>, contractUncheckedUpdateWithoutContract_couponsInput>
  }

  export type couponUpdateOneRequiredWithoutContract_couponsNestedInput = {
    create?: XOR<couponCreateWithoutContract_couponsInput, couponUncheckedCreateWithoutContract_couponsInput>
    connectOrCreate?: couponCreateOrConnectWithoutContract_couponsInput
    upsert?: couponUpsertWithoutContract_couponsInput
    connect?: couponWhereUniqueInput
    update?: XOR<XOR<couponUpdateToOneWithWhereWithoutContract_couponsInput, couponUpdateWithoutContract_couponsInput>, couponUncheckedUpdateWithoutContract_couponsInput>
  }

  export type contractCreateNestedManyWithoutCouponInput = {
    create?: XOR<contractCreateWithoutCouponInput, contractUncheckedCreateWithoutCouponInput> | contractCreateWithoutCouponInput[] | contractUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contractCreateOrConnectWithoutCouponInput | contractCreateOrConnectWithoutCouponInput[]
    createMany?: contractCreateManyCouponInputEnvelope
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
  }

  export type contract_couponsCreateNestedManyWithoutCouponInput = {
    create?: XOR<contract_couponsCreateWithoutCouponInput, contract_couponsUncheckedCreateWithoutCouponInput> | contract_couponsCreateWithoutCouponInput[] | contract_couponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutCouponInput | contract_couponsCreateOrConnectWithoutCouponInput[]
    createMany?: contract_couponsCreateManyCouponInputEnvelope
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
  }

  export type reservationCreateNestedManyWithoutCouponInput = {
    create?: XOR<reservationCreateWithoutCouponInput, reservationUncheckedCreateWithoutCouponInput> | reservationCreateWithoutCouponInput[] | reservationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutCouponInput | reservationCreateOrConnectWithoutCouponInput[]
    createMany?: reservationCreateManyCouponInputEnvelope
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
  }

  export type contractUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<contractCreateWithoutCouponInput, contractUncheckedCreateWithoutCouponInput> | contractCreateWithoutCouponInput[] | contractUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contractCreateOrConnectWithoutCouponInput | contractCreateOrConnectWithoutCouponInput[]
    createMany?: contractCreateManyCouponInputEnvelope
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
  }

  export type contract_couponsUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<contract_couponsCreateWithoutCouponInput, contract_couponsUncheckedCreateWithoutCouponInput> | contract_couponsCreateWithoutCouponInput[] | contract_couponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutCouponInput | contract_couponsCreateOrConnectWithoutCouponInput[]
    createMany?: contract_couponsCreateManyCouponInputEnvelope
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
  }

  export type reservationUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<reservationCreateWithoutCouponInput, reservationUncheckedCreateWithoutCouponInput> | reservationCreateWithoutCouponInput[] | reservationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutCouponInput | reservationCreateOrConnectWithoutCouponInput[]
    createMany?: reservationCreateManyCouponInputEnvelope
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
  }

  export type Enumcoupon_reduction_typeFieldUpdateOperationsInput = {
    set?: $Enums.coupon_reduction_type
  }

  export type contractUpdateManyWithoutCouponNestedInput = {
    create?: XOR<contractCreateWithoutCouponInput, contractUncheckedCreateWithoutCouponInput> | contractCreateWithoutCouponInput[] | contractUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contractCreateOrConnectWithoutCouponInput | contractCreateOrConnectWithoutCouponInput[]
    upsert?: contractUpsertWithWhereUniqueWithoutCouponInput | contractUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: contractCreateManyCouponInputEnvelope
    set?: contractWhereUniqueInput | contractWhereUniqueInput[]
    disconnect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    delete?: contractWhereUniqueInput | contractWhereUniqueInput[]
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    update?: contractUpdateWithWhereUniqueWithoutCouponInput | contractUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: contractUpdateManyWithWhereWithoutCouponInput | contractUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: contractScalarWhereInput | contractScalarWhereInput[]
  }

  export type contract_couponsUpdateManyWithoutCouponNestedInput = {
    create?: XOR<contract_couponsCreateWithoutCouponInput, contract_couponsUncheckedCreateWithoutCouponInput> | contract_couponsCreateWithoutCouponInput[] | contract_couponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutCouponInput | contract_couponsCreateOrConnectWithoutCouponInput[]
    upsert?: contract_couponsUpsertWithWhereUniqueWithoutCouponInput | contract_couponsUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: contract_couponsCreateManyCouponInputEnvelope
    set?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    disconnect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    delete?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    update?: contract_couponsUpdateWithWhereUniqueWithoutCouponInput | contract_couponsUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: contract_couponsUpdateManyWithWhereWithoutCouponInput | contract_couponsUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: contract_couponsScalarWhereInput | contract_couponsScalarWhereInput[]
  }

  export type reservationUpdateManyWithoutCouponNestedInput = {
    create?: XOR<reservationCreateWithoutCouponInput, reservationUncheckedCreateWithoutCouponInput> | reservationCreateWithoutCouponInput[] | reservationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutCouponInput | reservationCreateOrConnectWithoutCouponInput[]
    upsert?: reservationUpsertWithWhereUniqueWithoutCouponInput | reservationUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: reservationCreateManyCouponInputEnvelope
    set?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    disconnect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    delete?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    update?: reservationUpdateWithWhereUniqueWithoutCouponInput | reservationUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: reservationUpdateManyWithWhereWithoutCouponInput | reservationUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: reservationScalarWhereInput | reservationScalarWhereInput[]
  }

  export type contractUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<contractCreateWithoutCouponInput, contractUncheckedCreateWithoutCouponInput> | contractCreateWithoutCouponInput[] | contractUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contractCreateOrConnectWithoutCouponInput | contractCreateOrConnectWithoutCouponInput[]
    upsert?: contractUpsertWithWhereUniqueWithoutCouponInput | contractUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: contractCreateManyCouponInputEnvelope
    set?: contractWhereUniqueInput | contractWhereUniqueInput[]
    disconnect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    delete?: contractWhereUniqueInput | contractWhereUniqueInput[]
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    update?: contractUpdateWithWhereUniqueWithoutCouponInput | contractUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: contractUpdateManyWithWhereWithoutCouponInput | contractUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: contractScalarWhereInput | contractScalarWhereInput[]
  }

  export type contract_couponsUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<contract_couponsCreateWithoutCouponInput, contract_couponsUncheckedCreateWithoutCouponInput> | contract_couponsCreateWithoutCouponInput[] | contract_couponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: contract_couponsCreateOrConnectWithoutCouponInput | contract_couponsCreateOrConnectWithoutCouponInput[]
    upsert?: contract_couponsUpsertWithWhereUniqueWithoutCouponInput | contract_couponsUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: contract_couponsCreateManyCouponInputEnvelope
    set?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    disconnect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    delete?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    connect?: contract_couponsWhereUniqueInput | contract_couponsWhereUniqueInput[]
    update?: contract_couponsUpdateWithWhereUniqueWithoutCouponInput | contract_couponsUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: contract_couponsUpdateManyWithWhereWithoutCouponInput | contract_couponsUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: contract_couponsScalarWhereInput | contract_couponsScalarWhereInput[]
  }

  export type reservationUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<reservationCreateWithoutCouponInput, reservationUncheckedCreateWithoutCouponInput> | reservationCreateWithoutCouponInput[] | reservationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutCouponInput | reservationCreateOrConnectWithoutCouponInput[]
    upsert?: reservationUpsertWithWhereUniqueWithoutCouponInput | reservationUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: reservationCreateManyCouponInputEnvelope
    set?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    disconnect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    delete?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    update?: reservationUpdateWithWhereUniqueWithoutCouponInput | reservationUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: reservationUpdateManyWithWhereWithoutCouponInput | reservationUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: reservationScalarWhereInput | reservationScalarWhereInput[]
  }

  export type planeCreateNestedOneWithoutFlightInput = {
    create?: XOR<planeCreateWithoutFlightInput, planeUncheckedCreateWithoutFlightInput>
    connectOrCreate?: planeCreateOrConnectWithoutFlightInput
    connect?: planeWhereUniqueInput
  }

  export type airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput = {
    create?: XOR<airportCreateWithoutFlight_flight_airport_depart_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_depart_idToairportInput>
    connectOrCreate?: airportCreateOrConnectWithoutFlight_flight_airport_depart_idToairportInput
    connect?: airportWhereUniqueInput
  }

  export type airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput = {
    create?: XOR<airportCreateWithoutFlight_flight_airport_arrivee_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_arrivee_idToairportInput>
    connectOrCreate?: airportCreateOrConnectWithoutFlight_flight_airport_arrivee_idToairportInput
    connect?: airportWhereUniqueInput
  }

  export type flight_seat_reservationCreateNestedManyWithoutFlightInput = {
    create?: XOR<flight_seat_reservationCreateWithoutFlightInput, flight_seat_reservationUncheckedCreateWithoutFlightInput> | flight_seat_reservationCreateWithoutFlightInput[] | flight_seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutFlightInput | flight_seat_reservationCreateOrConnectWithoutFlightInput[]
    createMany?: flight_seat_reservationCreateManyFlightInputEnvelope
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
  }

  export type reservationCreateNestedManyWithoutFlightInput = {
    create?: XOR<reservationCreateWithoutFlightInput, reservationUncheckedCreateWithoutFlightInput> | reservationCreateWithoutFlightInput[] | reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutFlightInput | reservationCreateOrConnectWithoutFlightInput[]
    createMany?: reservationCreateManyFlightInputEnvelope
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
  }

  export type seat_reservationCreateNestedManyWithoutFlightInput = {
    create?: XOR<seat_reservationCreateWithoutFlightInput, seat_reservationUncheckedCreateWithoutFlightInput> | seat_reservationCreateWithoutFlightInput[] | seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutFlightInput | seat_reservationCreateOrConnectWithoutFlightInput[]
    createMany?: seat_reservationCreateManyFlightInputEnvelope
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
  }

  export type flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<flight_seat_reservationCreateWithoutFlightInput, flight_seat_reservationUncheckedCreateWithoutFlightInput> | flight_seat_reservationCreateWithoutFlightInput[] | flight_seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutFlightInput | flight_seat_reservationCreateOrConnectWithoutFlightInput[]
    createMany?: flight_seat_reservationCreateManyFlightInputEnvelope
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
  }

  export type reservationUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<reservationCreateWithoutFlightInput, reservationUncheckedCreateWithoutFlightInput> | reservationCreateWithoutFlightInput[] | reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutFlightInput | reservationCreateOrConnectWithoutFlightInput[]
    createMany?: reservationCreateManyFlightInputEnvelope
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
  }

  export type seat_reservationUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<seat_reservationCreateWithoutFlightInput, seat_reservationUncheckedCreateWithoutFlightInput> | seat_reservationCreateWithoutFlightInput[] | seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutFlightInput | seat_reservationCreateOrConnectWithoutFlightInput[]
    createMany?: seat_reservationCreateManyFlightInputEnvelope
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
  }

  export type planeUpdateOneWithoutFlightNestedInput = {
    create?: XOR<planeCreateWithoutFlightInput, planeUncheckedCreateWithoutFlightInput>
    connectOrCreate?: planeCreateOrConnectWithoutFlightInput
    upsert?: planeUpsertWithoutFlightInput
    disconnect?: planeWhereInput | boolean
    delete?: planeWhereInput | boolean
    connect?: planeWhereUniqueInput
    update?: XOR<XOR<planeUpdateToOneWithWhereWithoutFlightInput, planeUpdateWithoutFlightInput>, planeUncheckedUpdateWithoutFlightInput>
  }

  export type airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput = {
    create?: XOR<airportCreateWithoutFlight_flight_airport_depart_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_depart_idToairportInput>
    connectOrCreate?: airportCreateOrConnectWithoutFlight_flight_airport_depart_idToairportInput
    upsert?: airportUpsertWithoutFlight_flight_airport_depart_idToairportInput
    disconnect?: airportWhereInput | boolean
    delete?: airportWhereInput | boolean
    connect?: airportWhereUniqueInput
    update?: XOR<XOR<airportUpdateToOneWithWhereWithoutFlight_flight_airport_depart_idToairportInput, airportUpdateWithoutFlight_flight_airport_depart_idToairportInput>, airportUncheckedUpdateWithoutFlight_flight_airport_depart_idToairportInput>
  }

  export type airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput = {
    create?: XOR<airportCreateWithoutFlight_flight_airport_arrivee_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_arrivee_idToairportInput>
    connectOrCreate?: airportCreateOrConnectWithoutFlight_flight_airport_arrivee_idToairportInput
    upsert?: airportUpsertWithoutFlight_flight_airport_arrivee_idToairportInput
    disconnect?: airportWhereInput | boolean
    delete?: airportWhereInput | boolean
    connect?: airportWhereUniqueInput
    update?: XOR<XOR<airportUpdateToOneWithWhereWithoutFlight_flight_airport_arrivee_idToairportInput, airportUpdateWithoutFlight_flight_airport_arrivee_idToairportInput>, airportUncheckedUpdateWithoutFlight_flight_airport_arrivee_idToairportInput>
  }

  export type flight_seat_reservationUpdateManyWithoutFlightNestedInput = {
    create?: XOR<flight_seat_reservationCreateWithoutFlightInput, flight_seat_reservationUncheckedCreateWithoutFlightInput> | flight_seat_reservationCreateWithoutFlightInput[] | flight_seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutFlightInput | flight_seat_reservationCreateOrConnectWithoutFlightInput[]
    upsert?: flight_seat_reservationUpsertWithWhereUniqueWithoutFlightInput | flight_seat_reservationUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: flight_seat_reservationCreateManyFlightInputEnvelope
    set?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    disconnect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    delete?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    update?: flight_seat_reservationUpdateWithWhereUniqueWithoutFlightInput | flight_seat_reservationUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: flight_seat_reservationUpdateManyWithWhereWithoutFlightInput | flight_seat_reservationUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
  }

  export type reservationUpdateManyWithoutFlightNestedInput = {
    create?: XOR<reservationCreateWithoutFlightInput, reservationUncheckedCreateWithoutFlightInput> | reservationCreateWithoutFlightInput[] | reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutFlightInput | reservationCreateOrConnectWithoutFlightInput[]
    upsert?: reservationUpsertWithWhereUniqueWithoutFlightInput | reservationUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: reservationCreateManyFlightInputEnvelope
    set?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    disconnect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    delete?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    update?: reservationUpdateWithWhereUniqueWithoutFlightInput | reservationUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: reservationUpdateManyWithWhereWithoutFlightInput | reservationUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: reservationScalarWhereInput | reservationScalarWhereInput[]
  }

  export type seat_reservationUpdateManyWithoutFlightNestedInput = {
    create?: XOR<seat_reservationCreateWithoutFlightInput, seat_reservationUncheckedCreateWithoutFlightInput> | seat_reservationCreateWithoutFlightInput[] | seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutFlightInput | seat_reservationCreateOrConnectWithoutFlightInput[]
    upsert?: seat_reservationUpsertWithWhereUniqueWithoutFlightInput | seat_reservationUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: seat_reservationCreateManyFlightInputEnvelope
    set?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    disconnect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    delete?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    update?: seat_reservationUpdateWithWhereUniqueWithoutFlightInput | seat_reservationUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: seat_reservationUpdateManyWithWhereWithoutFlightInput | seat_reservationUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
  }

  export type flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<flight_seat_reservationCreateWithoutFlightInput, flight_seat_reservationUncheckedCreateWithoutFlightInput> | flight_seat_reservationCreateWithoutFlightInput[] | flight_seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutFlightInput | flight_seat_reservationCreateOrConnectWithoutFlightInput[]
    upsert?: flight_seat_reservationUpsertWithWhereUniqueWithoutFlightInput | flight_seat_reservationUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: flight_seat_reservationCreateManyFlightInputEnvelope
    set?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    disconnect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    delete?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    update?: flight_seat_reservationUpdateWithWhereUniqueWithoutFlightInput | flight_seat_reservationUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: flight_seat_reservationUpdateManyWithWhereWithoutFlightInput | flight_seat_reservationUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
  }

  export type reservationUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<reservationCreateWithoutFlightInput, reservationUncheckedCreateWithoutFlightInput> | reservationCreateWithoutFlightInput[] | reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutFlightInput | reservationCreateOrConnectWithoutFlightInput[]
    upsert?: reservationUpsertWithWhereUniqueWithoutFlightInput | reservationUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: reservationCreateManyFlightInputEnvelope
    set?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    disconnect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    delete?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    update?: reservationUpdateWithWhereUniqueWithoutFlightInput | reservationUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: reservationUpdateManyWithWhereWithoutFlightInput | reservationUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: reservationScalarWhereInput | reservationScalarWhereInput[]
  }

  export type seat_reservationUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<seat_reservationCreateWithoutFlightInput, seat_reservationUncheckedCreateWithoutFlightInput> | seat_reservationCreateWithoutFlightInput[] | seat_reservationUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutFlightInput | seat_reservationCreateOrConnectWithoutFlightInput[]
    upsert?: seat_reservationUpsertWithWhereUniqueWithoutFlightInput | seat_reservationUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: seat_reservationCreateManyFlightInputEnvelope
    set?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    disconnect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    delete?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    update?: seat_reservationUpdateWithWhereUniqueWithoutFlightInput | seat_reservationUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: seat_reservationUpdateManyWithWhereWithoutFlightInput | seat_reservationUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
  }

  export type seatCreateNestedOneWithoutFlight_seat_reservationInput = {
    create?: XOR<seatCreateWithoutFlight_seat_reservationInput, seatUncheckedCreateWithoutFlight_seat_reservationInput>
    connectOrCreate?: seatCreateOrConnectWithoutFlight_seat_reservationInput
    connect?: seatWhereUniqueInput
  }

  export type flightCreateNestedOneWithoutFlight_seat_reservationInput = {
    create?: XOR<flightCreateWithoutFlight_seat_reservationInput, flightUncheckedCreateWithoutFlight_seat_reservationInput>
    connectOrCreate?: flightCreateOrConnectWithoutFlight_seat_reservationInput
    connect?: flightWhereUniqueInput
  }

  export type reservationCreateNestedOneWithoutFlight_seat_reservationInput = {
    create?: XOR<reservationCreateWithoutFlight_seat_reservationInput, reservationUncheckedCreateWithoutFlight_seat_reservationInput>
    connectOrCreate?: reservationCreateOrConnectWithoutFlight_seat_reservationInput
    connect?: reservationWhereUniqueInput
  }

  export type seatUpdateOneWithoutFlight_seat_reservationNestedInput = {
    create?: XOR<seatCreateWithoutFlight_seat_reservationInput, seatUncheckedCreateWithoutFlight_seat_reservationInput>
    connectOrCreate?: seatCreateOrConnectWithoutFlight_seat_reservationInput
    upsert?: seatUpsertWithoutFlight_seat_reservationInput
    disconnect?: seatWhereInput | boolean
    delete?: seatWhereInput | boolean
    connect?: seatWhereUniqueInput
    update?: XOR<XOR<seatUpdateToOneWithWhereWithoutFlight_seat_reservationInput, seatUpdateWithoutFlight_seat_reservationInput>, seatUncheckedUpdateWithoutFlight_seat_reservationInput>
  }

  export type flightUpdateOneWithoutFlight_seat_reservationNestedInput = {
    create?: XOR<flightCreateWithoutFlight_seat_reservationInput, flightUncheckedCreateWithoutFlight_seat_reservationInput>
    connectOrCreate?: flightCreateOrConnectWithoutFlight_seat_reservationInput
    upsert?: flightUpsertWithoutFlight_seat_reservationInput
    disconnect?: flightWhereInput | boolean
    delete?: flightWhereInput | boolean
    connect?: flightWhereUniqueInput
    update?: XOR<XOR<flightUpdateToOneWithWhereWithoutFlight_seat_reservationInput, flightUpdateWithoutFlight_seat_reservationInput>, flightUncheckedUpdateWithoutFlight_seat_reservationInput>
  }

  export type reservationUpdateOneWithoutFlight_seat_reservationNestedInput = {
    create?: XOR<reservationCreateWithoutFlight_seat_reservationInput, reservationUncheckedCreateWithoutFlight_seat_reservationInput>
    connectOrCreate?: reservationCreateOrConnectWithoutFlight_seat_reservationInput
    upsert?: reservationUpsertWithoutFlight_seat_reservationInput
    disconnect?: reservationWhereInput | boolean
    delete?: reservationWhereInput | boolean
    connect?: reservationWhereUniqueInput
    update?: XOR<XOR<reservationUpdateToOneWithWhereWithoutFlight_seat_reservationInput, reservationUpdateWithoutFlight_seat_reservationInput>, reservationUncheckedUpdateWithoutFlight_seat_reservationInput>
  }

  export type airportCreateNestedManyWithoutLocationInput = {
    create?: XOR<airportCreateWithoutLocationInput, airportUncheckedCreateWithoutLocationInput> | airportCreateWithoutLocationInput[] | airportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: airportCreateOrConnectWithoutLocationInput | airportCreateOrConnectWithoutLocationInput[]
    createMany?: airportCreateManyLocationInputEnvelope
    connect?: airportWhereUniqueInput | airportWhereUniqueInput[]
  }

  export type airportUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<airportCreateWithoutLocationInput, airportUncheckedCreateWithoutLocationInput> | airportCreateWithoutLocationInput[] | airportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: airportCreateOrConnectWithoutLocationInput | airportCreateOrConnectWithoutLocationInput[]
    createMany?: airportCreateManyLocationInputEnvelope
    connect?: airportWhereUniqueInput | airportWhereUniqueInput[]
  }

  export type airportUpdateManyWithoutLocationNestedInput = {
    create?: XOR<airportCreateWithoutLocationInput, airportUncheckedCreateWithoutLocationInput> | airportCreateWithoutLocationInput[] | airportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: airportCreateOrConnectWithoutLocationInput | airportCreateOrConnectWithoutLocationInput[]
    upsert?: airportUpsertWithWhereUniqueWithoutLocationInput | airportUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: airportCreateManyLocationInputEnvelope
    set?: airportWhereUniqueInput | airportWhereUniqueInput[]
    disconnect?: airportWhereUniqueInput | airportWhereUniqueInput[]
    delete?: airportWhereUniqueInput | airportWhereUniqueInput[]
    connect?: airportWhereUniqueInput | airportWhereUniqueInput[]
    update?: airportUpdateWithWhereUniqueWithoutLocationInput | airportUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: airportUpdateManyWithWhereWithoutLocationInput | airportUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: airportScalarWhereInput | airportScalarWhereInput[]
  }

  export type airportUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<airportCreateWithoutLocationInput, airportUncheckedCreateWithoutLocationInput> | airportCreateWithoutLocationInput[] | airportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: airportCreateOrConnectWithoutLocationInput | airportCreateOrConnectWithoutLocationInput[]
    upsert?: airportUpsertWithWhereUniqueWithoutLocationInput | airportUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: airportCreateManyLocationInputEnvelope
    set?: airportWhereUniqueInput | airportWhereUniqueInput[]
    disconnect?: airportWhereUniqueInput | airportWhereUniqueInput[]
    delete?: airportWhereUniqueInput | airportWhereUniqueInput[]
    connect?: airportWhereUniqueInput | airportWhereUniqueInput[]
    update?: airportUpdateWithWhereUniqueWithoutLocationInput | airportUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: airportUpdateManyWithWhereWithoutLocationInput | airportUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: airportScalarWhereInput | airportScalarWhereInput[]
  }

  export type flightCreateNestedManyWithoutPlaneInput = {
    create?: XOR<flightCreateWithoutPlaneInput, flightUncheckedCreateWithoutPlaneInput> | flightCreateWithoutPlaneInput[] | flightUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: flightCreateOrConnectWithoutPlaneInput | flightCreateOrConnectWithoutPlaneInput[]
    createMany?: flightCreateManyPlaneInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type seatCreateNestedManyWithoutPlaneInput = {
    create?: XOR<seatCreateWithoutPlaneInput, seatUncheckedCreateWithoutPlaneInput> | seatCreateWithoutPlaneInput[] | seatUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: seatCreateOrConnectWithoutPlaneInput | seatCreateOrConnectWithoutPlaneInput[]
    createMany?: seatCreateManyPlaneInputEnvelope
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
  }

  export type flightUncheckedCreateNestedManyWithoutPlaneInput = {
    create?: XOR<flightCreateWithoutPlaneInput, flightUncheckedCreateWithoutPlaneInput> | flightCreateWithoutPlaneInput[] | flightUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: flightCreateOrConnectWithoutPlaneInput | flightCreateOrConnectWithoutPlaneInput[]
    createMany?: flightCreateManyPlaneInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type seatUncheckedCreateNestedManyWithoutPlaneInput = {
    create?: XOR<seatCreateWithoutPlaneInput, seatUncheckedCreateWithoutPlaneInput> | seatCreateWithoutPlaneInput[] | seatUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: seatCreateOrConnectWithoutPlaneInput | seatCreateOrConnectWithoutPlaneInput[]
    createMany?: seatCreateManyPlaneInputEnvelope
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
  }

  export type flightUpdateManyWithoutPlaneNestedInput = {
    create?: XOR<flightCreateWithoutPlaneInput, flightUncheckedCreateWithoutPlaneInput> | flightCreateWithoutPlaneInput[] | flightUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: flightCreateOrConnectWithoutPlaneInput | flightCreateOrConnectWithoutPlaneInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutPlaneInput | flightUpsertWithWhereUniqueWithoutPlaneInput[]
    createMany?: flightCreateManyPlaneInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutPlaneInput | flightUpdateWithWhereUniqueWithoutPlaneInput[]
    updateMany?: flightUpdateManyWithWhereWithoutPlaneInput | flightUpdateManyWithWhereWithoutPlaneInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type seatUpdateManyWithoutPlaneNestedInput = {
    create?: XOR<seatCreateWithoutPlaneInput, seatUncheckedCreateWithoutPlaneInput> | seatCreateWithoutPlaneInput[] | seatUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: seatCreateOrConnectWithoutPlaneInput | seatCreateOrConnectWithoutPlaneInput[]
    upsert?: seatUpsertWithWhereUniqueWithoutPlaneInput | seatUpsertWithWhereUniqueWithoutPlaneInput[]
    createMany?: seatCreateManyPlaneInputEnvelope
    set?: seatWhereUniqueInput | seatWhereUniqueInput[]
    disconnect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    delete?: seatWhereUniqueInput | seatWhereUniqueInput[]
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    update?: seatUpdateWithWhereUniqueWithoutPlaneInput | seatUpdateWithWhereUniqueWithoutPlaneInput[]
    updateMany?: seatUpdateManyWithWhereWithoutPlaneInput | seatUpdateManyWithWhereWithoutPlaneInput[]
    deleteMany?: seatScalarWhereInput | seatScalarWhereInput[]
  }

  export type flightUncheckedUpdateManyWithoutPlaneNestedInput = {
    create?: XOR<flightCreateWithoutPlaneInput, flightUncheckedCreateWithoutPlaneInput> | flightCreateWithoutPlaneInput[] | flightUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: flightCreateOrConnectWithoutPlaneInput | flightCreateOrConnectWithoutPlaneInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutPlaneInput | flightUpsertWithWhereUniqueWithoutPlaneInput[]
    createMany?: flightCreateManyPlaneInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutPlaneInput | flightUpdateWithWhereUniqueWithoutPlaneInput[]
    updateMany?: flightUpdateManyWithWhereWithoutPlaneInput | flightUpdateManyWithWhereWithoutPlaneInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type seatUncheckedUpdateManyWithoutPlaneNestedInput = {
    create?: XOR<seatCreateWithoutPlaneInput, seatUncheckedCreateWithoutPlaneInput> | seatCreateWithoutPlaneInput[] | seatUncheckedCreateWithoutPlaneInput[]
    connectOrCreate?: seatCreateOrConnectWithoutPlaneInput | seatCreateOrConnectWithoutPlaneInput[]
    upsert?: seatUpsertWithWhereUniqueWithoutPlaneInput | seatUpsertWithWhereUniqueWithoutPlaneInput[]
    createMany?: seatCreateManyPlaneInputEnvelope
    set?: seatWhereUniqueInput | seatWhereUniqueInput[]
    disconnect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    delete?: seatWhereUniqueInput | seatWhereUniqueInput[]
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    update?: seatUpdateWithWhereUniqueWithoutPlaneInput | seatUpdateWithWhereUniqueWithoutPlaneInput[]
    updateMany?: seatUpdateManyWithWhereWithoutPlaneInput | seatUpdateManyWithWhereWithoutPlaneInput[]
    deleteMany?: seatScalarWhereInput | seatScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutReclamationInput = {
    create?: XOR<userCreateWithoutReclamationInput, userUncheckedCreateWithoutReclamationInput>
    connectOrCreate?: userCreateOrConnectWithoutReclamationInput
    connect?: userWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneWithoutReclamationNestedInput = {
    create?: XOR<userCreateWithoutReclamationInput, userUncheckedCreateWithoutReclamationInput>
    connectOrCreate?: userCreateOrConnectWithoutReclamationInput
    upsert?: userUpsertWithoutReclamationInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReclamationInput, userUpdateWithoutReclamationInput>, userUncheckedUpdateWithoutReclamationInput>
  }

  export type userCreateNestedOneWithoutRequest_soldeInput = {
    create?: XOR<userCreateWithoutRequest_soldeInput, userUncheckedCreateWithoutRequest_soldeInput>
    connectOrCreate?: userCreateOrConnectWithoutRequest_soldeInput
    connect?: userWhereUniqueInput
  }

  export type Enumrequest_solde_statusFieldUpdateOperationsInput = {
    set?: $Enums.request_solde_status
  }

  export type userUpdateOneWithoutRequest_soldeNestedInput = {
    create?: XOR<userCreateWithoutRequest_soldeInput, userUncheckedCreateWithoutRequest_soldeInput>
    connectOrCreate?: userCreateOrConnectWithoutRequest_soldeInput
    upsert?: userUpsertWithoutRequest_soldeInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRequest_soldeInput, userUpdateWithoutRequest_soldeInput>, userUncheckedUpdateWithoutRequest_soldeInput>
  }

  export type flight_seat_reservationCreateNestedManyWithoutReservationInput = {
    create?: XOR<flight_seat_reservationCreateWithoutReservationInput, flight_seat_reservationUncheckedCreateWithoutReservationInput> | flight_seat_reservationCreateWithoutReservationInput[] | flight_seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutReservationInput | flight_seat_reservationCreateOrConnectWithoutReservationInput[]
    createMany?: flight_seat_reservationCreateManyReservationInputEnvelope
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
  }

  export type flightCreateNestedOneWithoutReservationInput = {
    create?: XOR<flightCreateWithoutReservationInput, flightUncheckedCreateWithoutReservationInput>
    connectOrCreate?: flightCreateOrConnectWithoutReservationInput
    connect?: flightWhereUniqueInput
  }

  export type couponCreateNestedOneWithoutReservationInput = {
    create?: XOR<couponCreateWithoutReservationInput, couponUncheckedCreateWithoutReservationInput>
    connectOrCreate?: couponCreateOrConnectWithoutReservationInput
    connect?: couponWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReservationInput = {
    create?: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
    connectOrCreate?: userCreateOrConnectWithoutReservationInput
    connect?: userWhereUniqueInput
  }

  export type seat_reservationCreateNestedManyWithoutReservationInput = {
    create?: XOR<seat_reservationCreateWithoutReservationInput, seat_reservationUncheckedCreateWithoutReservationInput> | seat_reservationCreateWithoutReservationInput[] | seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutReservationInput | seat_reservationCreateOrConnectWithoutReservationInput[]
    createMany?: seat_reservationCreateManyReservationInputEnvelope
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
  }

  export type flight_seat_reservationUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<flight_seat_reservationCreateWithoutReservationInput, flight_seat_reservationUncheckedCreateWithoutReservationInput> | flight_seat_reservationCreateWithoutReservationInput[] | flight_seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutReservationInput | flight_seat_reservationCreateOrConnectWithoutReservationInput[]
    createMany?: flight_seat_reservationCreateManyReservationInputEnvelope
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
  }

  export type seat_reservationUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<seat_reservationCreateWithoutReservationInput, seat_reservationUncheckedCreateWithoutReservationInput> | seat_reservationCreateWithoutReservationInput[] | seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutReservationInput | seat_reservationCreateOrConnectWithoutReservationInput[]
    createMany?: seat_reservationCreateManyReservationInputEnvelope
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
  }

  export type flight_seat_reservationUpdateManyWithoutReservationNestedInput = {
    create?: XOR<flight_seat_reservationCreateWithoutReservationInput, flight_seat_reservationUncheckedCreateWithoutReservationInput> | flight_seat_reservationCreateWithoutReservationInput[] | flight_seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutReservationInput | flight_seat_reservationCreateOrConnectWithoutReservationInput[]
    upsert?: flight_seat_reservationUpsertWithWhereUniqueWithoutReservationInput | flight_seat_reservationUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: flight_seat_reservationCreateManyReservationInputEnvelope
    set?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    disconnect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    delete?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    update?: flight_seat_reservationUpdateWithWhereUniqueWithoutReservationInput | flight_seat_reservationUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: flight_seat_reservationUpdateManyWithWhereWithoutReservationInput | flight_seat_reservationUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
  }

  export type flightUpdateOneWithoutReservationNestedInput = {
    create?: XOR<flightCreateWithoutReservationInput, flightUncheckedCreateWithoutReservationInput>
    connectOrCreate?: flightCreateOrConnectWithoutReservationInput
    upsert?: flightUpsertWithoutReservationInput
    disconnect?: flightWhereInput | boolean
    delete?: flightWhereInput | boolean
    connect?: flightWhereUniqueInput
    update?: XOR<XOR<flightUpdateToOneWithWhereWithoutReservationInput, flightUpdateWithoutReservationInput>, flightUncheckedUpdateWithoutReservationInput>
  }

  export type couponUpdateOneWithoutReservationNestedInput = {
    create?: XOR<couponCreateWithoutReservationInput, couponUncheckedCreateWithoutReservationInput>
    connectOrCreate?: couponCreateOrConnectWithoutReservationInput
    upsert?: couponUpsertWithoutReservationInput
    disconnect?: couponWhereInput | boolean
    delete?: couponWhereInput | boolean
    connect?: couponWhereUniqueInput
    update?: XOR<XOR<couponUpdateToOneWithWhereWithoutReservationInput, couponUpdateWithoutReservationInput>, couponUncheckedUpdateWithoutReservationInput>
  }

  export type userUpdateOneWithoutReservationNestedInput = {
    create?: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
    connectOrCreate?: userCreateOrConnectWithoutReservationInput
    upsert?: userUpsertWithoutReservationInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReservationInput, userUpdateWithoutReservationInput>, userUncheckedUpdateWithoutReservationInput>
  }

  export type seat_reservationUpdateManyWithoutReservationNestedInput = {
    create?: XOR<seat_reservationCreateWithoutReservationInput, seat_reservationUncheckedCreateWithoutReservationInput> | seat_reservationCreateWithoutReservationInput[] | seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutReservationInput | seat_reservationCreateOrConnectWithoutReservationInput[]
    upsert?: seat_reservationUpsertWithWhereUniqueWithoutReservationInput | seat_reservationUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: seat_reservationCreateManyReservationInputEnvelope
    set?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    disconnect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    delete?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    update?: seat_reservationUpdateWithWhereUniqueWithoutReservationInput | seat_reservationUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: seat_reservationUpdateManyWithWhereWithoutReservationInput | seat_reservationUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
  }

  export type flight_seat_reservationUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<flight_seat_reservationCreateWithoutReservationInput, flight_seat_reservationUncheckedCreateWithoutReservationInput> | flight_seat_reservationCreateWithoutReservationInput[] | flight_seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutReservationInput | flight_seat_reservationCreateOrConnectWithoutReservationInput[]
    upsert?: flight_seat_reservationUpsertWithWhereUniqueWithoutReservationInput | flight_seat_reservationUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: flight_seat_reservationCreateManyReservationInputEnvelope
    set?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    disconnect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    delete?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    update?: flight_seat_reservationUpdateWithWhereUniqueWithoutReservationInput | flight_seat_reservationUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: flight_seat_reservationUpdateManyWithWhereWithoutReservationInput | flight_seat_reservationUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
  }

  export type seat_reservationUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<seat_reservationCreateWithoutReservationInput, seat_reservationUncheckedCreateWithoutReservationInput> | seat_reservationCreateWithoutReservationInput[] | seat_reservationUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutReservationInput | seat_reservationCreateOrConnectWithoutReservationInput[]
    upsert?: seat_reservationUpsertWithWhereUniqueWithoutReservationInput | seat_reservationUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: seat_reservationCreateManyReservationInputEnvelope
    set?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    disconnect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    delete?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    update?: seat_reservationUpdateWithWhereUniqueWithoutReservationInput | seat_reservationUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: seat_reservationUpdateManyWithWhereWithoutReservationInput | seat_reservationUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
  }

  export type flight_seat_reservationCreateNestedManyWithoutSeatInput = {
    create?: XOR<flight_seat_reservationCreateWithoutSeatInput, flight_seat_reservationUncheckedCreateWithoutSeatInput> | flight_seat_reservationCreateWithoutSeatInput[] | flight_seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutSeatInput | flight_seat_reservationCreateOrConnectWithoutSeatInput[]
    createMany?: flight_seat_reservationCreateManySeatInputEnvelope
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
  }

  export type planeCreateNestedOneWithoutSeatInput = {
    create?: XOR<planeCreateWithoutSeatInput, planeUncheckedCreateWithoutSeatInput>
    connectOrCreate?: planeCreateOrConnectWithoutSeatInput
    connect?: planeWhereUniqueInput
  }

  export type seat_reservationCreateNestedManyWithoutSeatInput = {
    create?: XOR<seat_reservationCreateWithoutSeatInput, seat_reservationUncheckedCreateWithoutSeatInput> | seat_reservationCreateWithoutSeatInput[] | seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutSeatInput | seat_reservationCreateOrConnectWithoutSeatInput[]
    createMany?: seat_reservationCreateManySeatInputEnvelope
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
  }

  export type flight_seat_reservationUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<flight_seat_reservationCreateWithoutSeatInput, flight_seat_reservationUncheckedCreateWithoutSeatInput> | flight_seat_reservationCreateWithoutSeatInput[] | flight_seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutSeatInput | flight_seat_reservationCreateOrConnectWithoutSeatInput[]
    createMany?: flight_seat_reservationCreateManySeatInputEnvelope
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
  }

  export type seat_reservationUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<seat_reservationCreateWithoutSeatInput, seat_reservationUncheckedCreateWithoutSeatInput> | seat_reservationCreateWithoutSeatInput[] | seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutSeatInput | seat_reservationCreateOrConnectWithoutSeatInput[]
    createMany?: seat_reservationCreateManySeatInputEnvelope
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
  }

  export type Enumseat_classTypeFieldUpdateOperationsInput = {
    set?: $Enums.seat_classType
  }

  export type flight_seat_reservationUpdateManyWithoutSeatNestedInput = {
    create?: XOR<flight_seat_reservationCreateWithoutSeatInput, flight_seat_reservationUncheckedCreateWithoutSeatInput> | flight_seat_reservationCreateWithoutSeatInput[] | flight_seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutSeatInput | flight_seat_reservationCreateOrConnectWithoutSeatInput[]
    upsert?: flight_seat_reservationUpsertWithWhereUniqueWithoutSeatInput | flight_seat_reservationUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: flight_seat_reservationCreateManySeatInputEnvelope
    set?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    disconnect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    delete?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    update?: flight_seat_reservationUpdateWithWhereUniqueWithoutSeatInput | flight_seat_reservationUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: flight_seat_reservationUpdateManyWithWhereWithoutSeatInput | flight_seat_reservationUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
  }

  export type planeUpdateOneWithoutSeatNestedInput = {
    create?: XOR<planeCreateWithoutSeatInput, planeUncheckedCreateWithoutSeatInput>
    connectOrCreate?: planeCreateOrConnectWithoutSeatInput
    upsert?: planeUpsertWithoutSeatInput
    disconnect?: planeWhereInput | boolean
    delete?: planeWhereInput | boolean
    connect?: planeWhereUniqueInput
    update?: XOR<XOR<planeUpdateToOneWithWhereWithoutSeatInput, planeUpdateWithoutSeatInput>, planeUncheckedUpdateWithoutSeatInput>
  }

  export type seat_reservationUpdateManyWithoutSeatNestedInput = {
    create?: XOR<seat_reservationCreateWithoutSeatInput, seat_reservationUncheckedCreateWithoutSeatInput> | seat_reservationCreateWithoutSeatInput[] | seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutSeatInput | seat_reservationCreateOrConnectWithoutSeatInput[]
    upsert?: seat_reservationUpsertWithWhereUniqueWithoutSeatInput | seat_reservationUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: seat_reservationCreateManySeatInputEnvelope
    set?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    disconnect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    delete?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    update?: seat_reservationUpdateWithWhereUniqueWithoutSeatInput | seat_reservationUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: seat_reservationUpdateManyWithWhereWithoutSeatInput | seat_reservationUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
  }

  export type flight_seat_reservationUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<flight_seat_reservationCreateWithoutSeatInput, flight_seat_reservationUncheckedCreateWithoutSeatInput> | flight_seat_reservationCreateWithoutSeatInput[] | flight_seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: flight_seat_reservationCreateOrConnectWithoutSeatInput | flight_seat_reservationCreateOrConnectWithoutSeatInput[]
    upsert?: flight_seat_reservationUpsertWithWhereUniqueWithoutSeatInput | flight_seat_reservationUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: flight_seat_reservationCreateManySeatInputEnvelope
    set?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    disconnect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    delete?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    connect?: flight_seat_reservationWhereUniqueInput | flight_seat_reservationWhereUniqueInput[]
    update?: flight_seat_reservationUpdateWithWhereUniqueWithoutSeatInput | flight_seat_reservationUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: flight_seat_reservationUpdateManyWithWhereWithoutSeatInput | flight_seat_reservationUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
  }

  export type seat_reservationUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<seat_reservationCreateWithoutSeatInput, seat_reservationUncheckedCreateWithoutSeatInput> | seat_reservationCreateWithoutSeatInput[] | seat_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: seat_reservationCreateOrConnectWithoutSeatInput | seat_reservationCreateOrConnectWithoutSeatInput[]
    upsert?: seat_reservationUpsertWithWhereUniqueWithoutSeatInput | seat_reservationUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: seat_reservationCreateManySeatInputEnvelope
    set?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    disconnect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    delete?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    connect?: seat_reservationWhereUniqueInput | seat_reservationWhereUniqueInput[]
    update?: seat_reservationUpdateWithWhereUniqueWithoutSeatInput | seat_reservationUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: seat_reservationUpdateManyWithWhereWithoutSeatInput | seat_reservationUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
  }

  export type flightCreateNestedOneWithoutSeat_reservationInput = {
    create?: XOR<flightCreateWithoutSeat_reservationInput, flightUncheckedCreateWithoutSeat_reservationInput>
    connectOrCreate?: flightCreateOrConnectWithoutSeat_reservationInput
    connect?: flightWhereUniqueInput
  }

  export type reservationCreateNestedOneWithoutSeat_reservationInput = {
    create?: XOR<reservationCreateWithoutSeat_reservationInput, reservationUncheckedCreateWithoutSeat_reservationInput>
    connectOrCreate?: reservationCreateOrConnectWithoutSeat_reservationInput
    connect?: reservationWhereUniqueInput
  }

  export type seatCreateNestedOneWithoutSeat_reservationInput = {
    create?: XOR<seatCreateWithoutSeat_reservationInput, seatUncheckedCreateWithoutSeat_reservationInput>
    connectOrCreate?: seatCreateOrConnectWithoutSeat_reservationInput
    connect?: seatWhereUniqueInput
  }

  export type flightUpdateOneWithoutSeat_reservationNestedInput = {
    create?: XOR<flightCreateWithoutSeat_reservationInput, flightUncheckedCreateWithoutSeat_reservationInput>
    connectOrCreate?: flightCreateOrConnectWithoutSeat_reservationInput
    upsert?: flightUpsertWithoutSeat_reservationInput
    disconnect?: flightWhereInput | boolean
    delete?: flightWhereInput | boolean
    connect?: flightWhereUniqueInput
    update?: XOR<XOR<flightUpdateToOneWithWhereWithoutSeat_reservationInput, flightUpdateWithoutSeat_reservationInput>, flightUncheckedUpdateWithoutSeat_reservationInput>
  }

  export type reservationUpdateOneWithoutSeat_reservationNestedInput = {
    create?: XOR<reservationCreateWithoutSeat_reservationInput, reservationUncheckedCreateWithoutSeat_reservationInput>
    connectOrCreate?: reservationCreateOrConnectWithoutSeat_reservationInput
    upsert?: reservationUpsertWithoutSeat_reservationInput
    disconnect?: reservationWhereInput | boolean
    delete?: reservationWhereInput | boolean
    connect?: reservationWhereUniqueInput
    update?: XOR<XOR<reservationUpdateToOneWithWhereWithoutSeat_reservationInput, reservationUpdateWithoutSeat_reservationInput>, reservationUncheckedUpdateWithoutSeat_reservationInput>
  }

  export type seatUpdateOneWithoutSeat_reservationNestedInput = {
    create?: XOR<seatCreateWithoutSeat_reservationInput, seatUncheckedCreateWithoutSeat_reservationInput>
    connectOrCreate?: seatCreateOrConnectWithoutSeat_reservationInput
    upsert?: seatUpsertWithoutSeat_reservationInput
    disconnect?: seatWhereInput | boolean
    delete?: seatWhereInput | boolean
    connect?: seatWhereUniqueInput
    update?: XOR<XOR<seatUpdateToOneWithWhereWithoutSeat_reservationInput, seatUpdateWithoutSeat_reservationInput>, seatUncheckedUpdateWithoutSeat_reservationInput>
  }

  export type compteCreateNestedOneWithoutUserInput = {
    create?: XOR<compteCreateWithoutUserInput, compteUncheckedCreateWithoutUserInput>
    connectOrCreate?: compteCreateOrConnectWithoutUserInput
    connect?: compteWhereUniqueInput
  }

  export type contractCreateNestedManyWithoutUserInput = {
    create?: XOR<contractCreateWithoutUserInput, contractUncheckedCreateWithoutUserInput> | contractCreateWithoutUserInput[] | contractUncheckedCreateWithoutUserInput[]
    connectOrCreate?: contractCreateOrConnectWithoutUserInput | contractCreateOrConnectWithoutUserInput[]
    createMany?: contractCreateManyUserInputEnvelope
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
  }

  export type reclamationCreateNestedManyWithoutUserInput = {
    create?: XOR<reclamationCreateWithoutUserInput, reclamationUncheckedCreateWithoutUserInput> | reclamationCreateWithoutUserInput[] | reclamationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reclamationCreateOrConnectWithoutUserInput | reclamationCreateOrConnectWithoutUserInput[]
    createMany?: reclamationCreateManyUserInputEnvelope
    connect?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
  }

  export type request_soldeCreateNestedManyWithoutUserInput = {
    create?: XOR<request_soldeCreateWithoutUserInput, request_soldeUncheckedCreateWithoutUserInput> | request_soldeCreateWithoutUserInput[] | request_soldeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: request_soldeCreateOrConnectWithoutUserInput | request_soldeCreateOrConnectWithoutUserInput[]
    createMany?: request_soldeCreateManyUserInputEnvelope
    connect?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
  }

  export type reservationCreateNestedManyWithoutUserInput = {
    create?: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput> | reservationCreateWithoutUserInput[] | reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutUserInput | reservationCreateOrConnectWithoutUserInput[]
    createMany?: reservationCreateManyUserInputEnvelope
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
  }

  export type compteUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<compteCreateWithoutUserInput, compteUncheckedCreateWithoutUserInput>
    connectOrCreate?: compteCreateOrConnectWithoutUserInput
    connect?: compteWhereUniqueInput
  }

  export type contractUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<contractCreateWithoutUserInput, contractUncheckedCreateWithoutUserInput> | contractCreateWithoutUserInput[] | contractUncheckedCreateWithoutUserInput[]
    connectOrCreate?: contractCreateOrConnectWithoutUserInput | contractCreateOrConnectWithoutUserInput[]
    createMany?: contractCreateManyUserInputEnvelope
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
  }

  export type reclamationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<reclamationCreateWithoutUserInput, reclamationUncheckedCreateWithoutUserInput> | reclamationCreateWithoutUserInput[] | reclamationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reclamationCreateOrConnectWithoutUserInput | reclamationCreateOrConnectWithoutUserInput[]
    createMany?: reclamationCreateManyUserInputEnvelope
    connect?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
  }

  export type request_soldeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<request_soldeCreateWithoutUserInput, request_soldeUncheckedCreateWithoutUserInput> | request_soldeCreateWithoutUserInput[] | request_soldeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: request_soldeCreateOrConnectWithoutUserInput | request_soldeCreateOrConnectWithoutUserInput[]
    createMany?: request_soldeCreateManyUserInputEnvelope
    connect?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
  }

  export type reservationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput> | reservationCreateWithoutUserInput[] | reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutUserInput | reservationCreateOrConnectWithoutUserInput[]
    createMany?: reservationCreateManyUserInputEnvelope
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
  }

  export type compteUpdateOneWithoutUserNestedInput = {
    create?: XOR<compteCreateWithoutUserInput, compteUncheckedCreateWithoutUserInput>
    connectOrCreate?: compteCreateOrConnectWithoutUserInput
    upsert?: compteUpsertWithoutUserInput
    disconnect?: compteWhereInput | boolean
    delete?: compteWhereInput | boolean
    connect?: compteWhereUniqueInput
    update?: XOR<XOR<compteUpdateToOneWithWhereWithoutUserInput, compteUpdateWithoutUserInput>, compteUncheckedUpdateWithoutUserInput>
  }

  export type contractUpdateManyWithoutUserNestedInput = {
    create?: XOR<contractCreateWithoutUserInput, contractUncheckedCreateWithoutUserInput> | contractCreateWithoutUserInput[] | contractUncheckedCreateWithoutUserInput[]
    connectOrCreate?: contractCreateOrConnectWithoutUserInput | contractCreateOrConnectWithoutUserInput[]
    upsert?: contractUpsertWithWhereUniqueWithoutUserInput | contractUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: contractCreateManyUserInputEnvelope
    set?: contractWhereUniqueInput | contractWhereUniqueInput[]
    disconnect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    delete?: contractWhereUniqueInput | contractWhereUniqueInput[]
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    update?: contractUpdateWithWhereUniqueWithoutUserInput | contractUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: contractUpdateManyWithWhereWithoutUserInput | contractUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: contractScalarWhereInput | contractScalarWhereInput[]
  }

  export type reclamationUpdateManyWithoutUserNestedInput = {
    create?: XOR<reclamationCreateWithoutUserInput, reclamationUncheckedCreateWithoutUserInput> | reclamationCreateWithoutUserInput[] | reclamationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reclamationCreateOrConnectWithoutUserInput | reclamationCreateOrConnectWithoutUserInput[]
    upsert?: reclamationUpsertWithWhereUniqueWithoutUserInput | reclamationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: reclamationCreateManyUserInputEnvelope
    set?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    disconnect?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    delete?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    connect?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    update?: reclamationUpdateWithWhereUniqueWithoutUserInput | reclamationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: reclamationUpdateManyWithWhereWithoutUserInput | reclamationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: reclamationScalarWhereInput | reclamationScalarWhereInput[]
  }

  export type request_soldeUpdateManyWithoutUserNestedInput = {
    create?: XOR<request_soldeCreateWithoutUserInput, request_soldeUncheckedCreateWithoutUserInput> | request_soldeCreateWithoutUserInput[] | request_soldeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: request_soldeCreateOrConnectWithoutUserInput | request_soldeCreateOrConnectWithoutUserInput[]
    upsert?: request_soldeUpsertWithWhereUniqueWithoutUserInput | request_soldeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: request_soldeCreateManyUserInputEnvelope
    set?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    disconnect?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    delete?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    connect?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    update?: request_soldeUpdateWithWhereUniqueWithoutUserInput | request_soldeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: request_soldeUpdateManyWithWhereWithoutUserInput | request_soldeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: request_soldeScalarWhereInput | request_soldeScalarWhereInput[]
  }

  export type reservationUpdateManyWithoutUserNestedInput = {
    create?: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput> | reservationCreateWithoutUserInput[] | reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutUserInput | reservationCreateOrConnectWithoutUserInput[]
    upsert?: reservationUpsertWithWhereUniqueWithoutUserInput | reservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: reservationCreateManyUserInputEnvelope
    set?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    disconnect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    delete?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    update?: reservationUpdateWithWhereUniqueWithoutUserInput | reservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: reservationUpdateManyWithWhereWithoutUserInput | reservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: reservationScalarWhereInput | reservationScalarWhereInput[]
  }

  export type compteUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<compteCreateWithoutUserInput, compteUncheckedCreateWithoutUserInput>
    connectOrCreate?: compteCreateOrConnectWithoutUserInput
    upsert?: compteUpsertWithoutUserInput
    disconnect?: compteWhereInput | boolean
    delete?: compteWhereInput | boolean
    connect?: compteWhereUniqueInput
    update?: XOR<XOR<compteUpdateToOneWithWhereWithoutUserInput, compteUpdateWithoutUserInput>, compteUncheckedUpdateWithoutUserInput>
  }

  export type contractUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<contractCreateWithoutUserInput, contractUncheckedCreateWithoutUserInput> | contractCreateWithoutUserInput[] | contractUncheckedCreateWithoutUserInput[]
    connectOrCreate?: contractCreateOrConnectWithoutUserInput | contractCreateOrConnectWithoutUserInput[]
    upsert?: contractUpsertWithWhereUniqueWithoutUserInput | contractUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: contractCreateManyUserInputEnvelope
    set?: contractWhereUniqueInput | contractWhereUniqueInput[]
    disconnect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    delete?: contractWhereUniqueInput | contractWhereUniqueInput[]
    connect?: contractWhereUniqueInput | contractWhereUniqueInput[]
    update?: contractUpdateWithWhereUniqueWithoutUserInput | contractUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: contractUpdateManyWithWhereWithoutUserInput | contractUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: contractScalarWhereInput | contractScalarWhereInput[]
  }

  export type reclamationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<reclamationCreateWithoutUserInput, reclamationUncheckedCreateWithoutUserInput> | reclamationCreateWithoutUserInput[] | reclamationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reclamationCreateOrConnectWithoutUserInput | reclamationCreateOrConnectWithoutUserInput[]
    upsert?: reclamationUpsertWithWhereUniqueWithoutUserInput | reclamationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: reclamationCreateManyUserInputEnvelope
    set?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    disconnect?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    delete?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    connect?: reclamationWhereUniqueInput | reclamationWhereUniqueInput[]
    update?: reclamationUpdateWithWhereUniqueWithoutUserInput | reclamationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: reclamationUpdateManyWithWhereWithoutUserInput | reclamationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: reclamationScalarWhereInput | reclamationScalarWhereInput[]
  }

  export type request_soldeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<request_soldeCreateWithoutUserInput, request_soldeUncheckedCreateWithoutUserInput> | request_soldeCreateWithoutUserInput[] | request_soldeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: request_soldeCreateOrConnectWithoutUserInput | request_soldeCreateOrConnectWithoutUserInput[]
    upsert?: request_soldeUpsertWithWhereUniqueWithoutUserInput | request_soldeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: request_soldeCreateManyUserInputEnvelope
    set?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    disconnect?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    delete?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    connect?: request_soldeWhereUniqueInput | request_soldeWhereUniqueInput[]
    update?: request_soldeUpdateWithWhereUniqueWithoutUserInput | request_soldeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: request_soldeUpdateManyWithWhereWithoutUserInput | request_soldeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: request_soldeScalarWhereInput | request_soldeScalarWhereInput[]
  }

  export type reservationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput> | reservationCreateWithoutUserInput[] | reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: reservationCreateOrConnectWithoutUserInput | reservationCreateOrConnectWithoutUserInput[]
    upsert?: reservationUpsertWithWhereUniqueWithoutUserInput | reservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: reservationCreateManyUserInputEnvelope
    set?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    disconnect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    delete?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    connect?: reservationWhereUniqueInput | reservationWhereUniqueInput[]
    update?: reservationUpdateWithWhereUniqueWithoutUserInput | reservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: reservationUpdateManyWithWhereWithoutUserInput | reservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: reservationScalarWhereInput | reservationScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumcoupon_reduction_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.coupon_reduction_type | Enumcoupon_reduction_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coupon_reduction_type[]
    notIn?: $Enums.coupon_reduction_type[]
    not?: NestedEnumcoupon_reduction_typeFilter<$PrismaModel> | $Enums.coupon_reduction_type
  }

  export type NestedEnumcoupon_reduction_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.coupon_reduction_type | Enumcoupon_reduction_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coupon_reduction_type[]
    notIn?: $Enums.coupon_reduction_type[]
    not?: NestedEnumcoupon_reduction_typeWithAggregatesFilter<$PrismaModel> | $Enums.coupon_reduction_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcoupon_reduction_typeFilter<$PrismaModel>
    _max?: NestedEnumcoupon_reduction_typeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumrequest_solde_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.request_solde_status | Enumrequest_solde_statusFieldRefInput<$PrismaModel>
    in?: $Enums.request_solde_status[]
    notIn?: $Enums.request_solde_status[]
    not?: NestedEnumrequest_solde_statusFilter<$PrismaModel> | $Enums.request_solde_status
  }

  export type NestedEnumrequest_solde_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.request_solde_status | Enumrequest_solde_statusFieldRefInput<$PrismaModel>
    in?: $Enums.request_solde_status[]
    notIn?: $Enums.request_solde_status[]
    not?: NestedEnumrequest_solde_statusWithAggregatesFilter<$PrismaModel> | $Enums.request_solde_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrequest_solde_statusFilter<$PrismaModel>
    _max?: NestedEnumrequest_solde_statusFilter<$PrismaModel>
  }

  export type NestedEnumseat_classTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.seat_classType | Enumseat_classTypeFieldRefInput<$PrismaModel>
    in?: $Enums.seat_classType[]
    notIn?: $Enums.seat_classType[]
    not?: NestedEnumseat_classTypeFilter<$PrismaModel> | $Enums.seat_classType
  }

  export type NestedEnumseat_classTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.seat_classType | Enumseat_classTypeFieldRefInput<$PrismaModel>
    in?: $Enums.seat_classType[]
    notIn?: $Enums.seat_classType[]
    not?: NestedEnumseat_classTypeWithAggregatesFilter<$PrismaModel> | $Enums.seat_classType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumseat_classTypeFilter<$PrismaModel>
    _max?: NestedEnumseat_classTypeFilter<$PrismaModel>
  }

  export type locationCreateWithoutAirportInput = {
    id: string
    nom: string
    pays: string
    ville: string
    description?: string | null
    url_image?: string | null
  }

  export type locationUncheckedCreateWithoutAirportInput = {
    id: string
    nom: string
    pays: string
    ville: string
    description?: string | null
    url_image?: string | null
  }

  export type locationCreateOrConnectWithoutAirportInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutAirportInput, locationUncheckedCreateWithoutAirportInput>
  }

  export type flightCreateWithoutAirport_flight_airport_depart_idToairportInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    plane?: planeCreateNestedOneWithoutFlightInput
    airport_flight_airport_arrivee_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutFlightInput
    reservation?: reservationCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_arrivee_id?: string | null
    plane_id?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput
    reservation?: reservationUncheckedCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightCreateOrConnectWithoutAirport_flight_airport_depart_idToairportInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput>
  }

  export type flightCreateManyAirport_flight_airport_depart_idToairportInputEnvelope = {
    data: flightCreateManyAirport_flight_airport_depart_idToairportInput | flightCreateManyAirport_flight_airport_depart_idToairportInput[]
    skipDuplicates?: boolean
  }

  export type flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    plane?: planeCreateNestedOneWithoutFlightInput
    airport_flight_airport_depart_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutFlightInput
    reservation?: reservationCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    plane_id?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput
    reservation?: reservationUncheckedCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightCreateOrConnectWithoutAirport_flight_airport_arrivee_idToairportInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput>
  }

  export type flightCreateManyAirport_flight_airport_arrivee_idToairportInputEnvelope = {
    data: flightCreateManyAirport_flight_airport_arrivee_idToairportInput | flightCreateManyAirport_flight_airport_arrivee_idToairportInput[]
    skipDuplicates?: boolean
  }

  export type locationUpsertWithoutAirportInput = {
    update: XOR<locationUpdateWithoutAirportInput, locationUncheckedUpdateWithoutAirportInput>
    create: XOR<locationCreateWithoutAirportInput, locationUncheckedCreateWithoutAirportInput>
    where?: locationWhereInput
  }

  export type locationUpdateToOneWithWhereWithoutAirportInput = {
    where?: locationWhereInput
    data: XOR<locationUpdateWithoutAirportInput, locationUncheckedUpdateWithoutAirportInput>
  }

  export type locationUpdateWithoutAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationUncheckedUpdateWithoutAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type flightUpsertWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput = {
    where: flightWhereUniqueInput
    update: XOR<flightUpdateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedUpdateWithoutAirport_flight_airport_depart_idToairportInput>
    create: XOR<flightCreateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_depart_idToairportInput>
  }

  export type flightUpdateWithWhereUniqueWithoutAirport_flight_airport_depart_idToairportInput = {
    where: flightWhereUniqueInput
    data: XOR<flightUpdateWithoutAirport_flight_airport_depart_idToairportInput, flightUncheckedUpdateWithoutAirport_flight_airport_depart_idToairportInput>
  }

  export type flightUpdateManyWithWhereWithoutAirport_flight_airport_depart_idToairportInput = {
    where: flightScalarWhereInput
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyWithoutAirport_flight_airport_depart_idToairportInput>
  }

  export type flightScalarWhereInput = {
    AND?: flightScalarWhereInput | flightScalarWhereInput[]
    OR?: flightScalarWhereInput[]
    NOT?: flightScalarWhereInput | flightScalarWhereInput[]
    id?: StringFilter<"flight"> | string
    titre?: StringFilter<"flight"> | string
    prix?: DecimalFilter<"flight"> | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFilter<"flight"> | Date | string
    date_retour?: DateTimeFilter<"flight"> | Date | string
    duree?: StringNullableFilter<"flight"> | string | null
    status?: StringFilter<"flight"> | string
    airport_depart_id?: StringNullableFilter<"flight"> | string | null
    airport_arrivee_id?: StringNullableFilter<"flight"> | string | null
    plane_id?: IntNullableFilter<"flight"> | number | null
  }

  export type flightUpsertWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput = {
    where: flightWhereUniqueInput
    update: XOR<flightUpdateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedUpdateWithoutAirport_flight_airport_arrivee_idToairportInput>
    create: XOR<flightCreateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedCreateWithoutAirport_flight_airport_arrivee_idToairportInput>
  }

  export type flightUpdateWithWhereUniqueWithoutAirport_flight_airport_arrivee_idToairportInput = {
    where: flightWhereUniqueInput
    data: XOR<flightUpdateWithoutAirport_flight_airport_arrivee_idToairportInput, flightUncheckedUpdateWithoutAirport_flight_airport_arrivee_idToairportInput>
  }

  export type flightUpdateManyWithWhereWithoutAirport_flight_airport_arrivee_idToairportInput = {
    where: flightScalarWhereInput
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyWithoutAirport_flight_airport_arrivee_idToairportInput>
  }

  export type userCreateWithoutCompteInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    contract?: contractCreateNestedManyWithoutUserInput
    reclamation?: reclamationCreateNestedManyWithoutUserInput
    request_solde?: request_soldeCreateNestedManyWithoutUserInput
    reservation?: reservationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCompteInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    contract?: contractUncheckedCreateNestedManyWithoutUserInput
    reclamation?: reclamationUncheckedCreateNestedManyWithoutUserInput
    request_solde?: request_soldeUncheckedCreateNestedManyWithoutUserInput
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCompteInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCompteInput, userUncheckedCreateWithoutCompteInput>
  }

  export type userUpsertWithoutCompteInput = {
    update: XOR<userUpdateWithoutCompteInput, userUncheckedUpdateWithoutCompteInput>
    create: XOR<userCreateWithoutCompteInput, userUncheckedCreateWithoutCompteInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCompteInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCompteInput, userUncheckedUpdateWithoutCompteInput>
  }

  export type userUpdateWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    contract?: contractUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUpdateManyWithoutUserNestedInput
    reservation?: reservationUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    contract?: contractUncheckedUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUncheckedUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUncheckedUpdateManyWithoutUserNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutContractInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteCreateNestedOneWithoutUserInput
    reclamation?: reclamationCreateNestedManyWithoutUserInput
    request_solde?: request_soldeCreateNestedManyWithoutUserInput
    reservation?: reservationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutContractInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteUncheckedCreateNestedOneWithoutUserInput
    reclamation?: reclamationUncheckedCreateNestedManyWithoutUserInput
    request_solde?: request_soldeUncheckedCreateNestedManyWithoutUserInput
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutContractInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutContractInput, userUncheckedCreateWithoutContractInput>
  }

  export type couponCreateWithoutContractInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract_coupons?: contract_couponsCreateNestedManyWithoutCouponInput
    reservation?: reservationCreateNestedManyWithoutCouponInput
  }

  export type couponUncheckedCreateWithoutContractInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract_coupons?: contract_couponsUncheckedCreateNestedManyWithoutCouponInput
    reservation?: reservationUncheckedCreateNestedManyWithoutCouponInput
  }

  export type couponCreateOrConnectWithoutContractInput = {
    where: couponWhereUniqueInput
    create: XOR<couponCreateWithoutContractInput, couponUncheckedCreateWithoutContractInput>
  }

  export type contract_couponsCreateWithoutContractInput = {
    coupon: couponCreateNestedOneWithoutContract_couponsInput
  }

  export type contract_couponsUncheckedCreateWithoutContractInput = {
    coupon_id: string
  }

  export type contract_couponsCreateOrConnectWithoutContractInput = {
    where: contract_couponsWhereUniqueInput
    create: XOR<contract_couponsCreateWithoutContractInput, contract_couponsUncheckedCreateWithoutContractInput>
  }

  export type contract_couponsCreateManyContractInputEnvelope = {
    data: contract_couponsCreateManyContractInput | contract_couponsCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutContractInput = {
    update: XOR<userUpdateWithoutContractInput, userUncheckedUpdateWithoutContractInput>
    create: XOR<userCreateWithoutContractInput, userUncheckedCreateWithoutContractInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutContractInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutContractInput, userUncheckedUpdateWithoutContractInput>
  }

  export type userUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUpdateOneWithoutUserNestedInput
    reclamation?: reclamationUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUpdateManyWithoutUserNestedInput
    reservation?: reservationUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUncheckedUpdateOneWithoutUserNestedInput
    reclamation?: reclamationUncheckedUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUncheckedUpdateManyWithoutUserNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type couponUpsertWithoutContractInput = {
    update: XOR<couponUpdateWithoutContractInput, couponUncheckedUpdateWithoutContractInput>
    create: XOR<couponCreateWithoutContractInput, couponUncheckedCreateWithoutContractInput>
    where?: couponWhereInput
  }

  export type couponUpdateToOneWithWhereWithoutContractInput = {
    where?: couponWhereInput
    data: XOR<couponUpdateWithoutContractInput, couponUncheckedUpdateWithoutContractInput>
  }

  export type couponUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract_coupons?: contract_couponsUpdateManyWithoutCouponNestedInput
    reservation?: reservationUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract_coupons?: contract_couponsUncheckedUpdateManyWithoutCouponNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type contract_couponsUpsertWithWhereUniqueWithoutContractInput = {
    where: contract_couponsWhereUniqueInput
    update: XOR<contract_couponsUpdateWithoutContractInput, contract_couponsUncheckedUpdateWithoutContractInput>
    create: XOR<contract_couponsCreateWithoutContractInput, contract_couponsUncheckedCreateWithoutContractInput>
  }

  export type contract_couponsUpdateWithWhereUniqueWithoutContractInput = {
    where: contract_couponsWhereUniqueInput
    data: XOR<contract_couponsUpdateWithoutContractInput, contract_couponsUncheckedUpdateWithoutContractInput>
  }

  export type contract_couponsUpdateManyWithWhereWithoutContractInput = {
    where: contract_couponsScalarWhereInput
    data: XOR<contract_couponsUpdateManyMutationInput, contract_couponsUncheckedUpdateManyWithoutContractInput>
  }

  export type contract_couponsScalarWhereInput = {
    AND?: contract_couponsScalarWhereInput | contract_couponsScalarWhereInput[]
    OR?: contract_couponsScalarWhereInput[]
    NOT?: contract_couponsScalarWhereInput | contract_couponsScalarWhereInput[]
    contract_id?: StringFilter<"contract_coupons"> | string
    coupon_id?: StringFilter<"contract_coupons"> | string
  }

  export type contractCreateWithoutContract_couponsInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    user?: userCreateNestedOneWithoutContractInput
    coupon?: couponCreateNestedOneWithoutContractInput
  }

  export type contractUncheckedCreateWithoutContract_couponsInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    coupon_id?: string | null
  }

  export type contractCreateOrConnectWithoutContract_couponsInput = {
    where: contractWhereUniqueInput
    create: XOR<contractCreateWithoutContract_couponsInput, contractUncheckedCreateWithoutContract_couponsInput>
  }

  export type couponCreateWithoutContract_couponsInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract?: contractCreateNestedManyWithoutCouponInput
    reservation?: reservationCreateNestedManyWithoutCouponInput
  }

  export type couponUncheckedCreateWithoutContract_couponsInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract?: contractUncheckedCreateNestedManyWithoutCouponInput
    reservation?: reservationUncheckedCreateNestedManyWithoutCouponInput
  }

  export type couponCreateOrConnectWithoutContract_couponsInput = {
    where: couponWhereUniqueInput
    create: XOR<couponCreateWithoutContract_couponsInput, couponUncheckedCreateWithoutContract_couponsInput>
  }

  export type contractUpsertWithoutContract_couponsInput = {
    update: XOR<contractUpdateWithoutContract_couponsInput, contractUncheckedUpdateWithoutContract_couponsInput>
    create: XOR<contractCreateWithoutContract_couponsInput, contractUncheckedCreateWithoutContract_couponsInput>
    where?: contractWhereInput
  }

  export type contractUpdateToOneWithWhereWithoutContract_couponsInput = {
    where?: contractWhereInput
    data: XOR<contractUpdateWithoutContract_couponsInput, contractUncheckedUpdateWithoutContract_couponsInput>
  }

  export type contractUpdateWithoutContract_couponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: userUpdateOneWithoutContractNestedInput
    coupon?: couponUpdateOneWithoutContractNestedInput
  }

  export type contractUncheckedUpdateWithoutContract_couponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponUpsertWithoutContract_couponsInput = {
    update: XOR<couponUpdateWithoutContract_couponsInput, couponUncheckedUpdateWithoutContract_couponsInput>
    create: XOR<couponCreateWithoutContract_couponsInput, couponUncheckedCreateWithoutContract_couponsInput>
    where?: couponWhereInput
  }

  export type couponUpdateToOneWithWhereWithoutContract_couponsInput = {
    where?: couponWhereInput
    data: XOR<couponUpdateWithoutContract_couponsInput, couponUncheckedUpdateWithoutContract_couponsInput>
  }

  export type couponUpdateWithoutContract_couponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: contractUpdateManyWithoutCouponNestedInput
    reservation?: reservationUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateWithoutContract_couponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: contractUncheckedUpdateManyWithoutCouponNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type contractCreateWithoutCouponInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    user?: userCreateNestedOneWithoutContractInput
    contract_coupons?: contract_couponsCreateNestedManyWithoutContractInput
  }

  export type contractUncheckedCreateWithoutCouponInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    contract_coupons?: contract_couponsUncheckedCreateNestedManyWithoutContractInput
  }

  export type contractCreateOrConnectWithoutCouponInput = {
    where: contractWhereUniqueInput
    create: XOR<contractCreateWithoutCouponInput, contractUncheckedCreateWithoutCouponInput>
  }

  export type contractCreateManyCouponInputEnvelope = {
    data: contractCreateManyCouponInput | contractCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type contract_couponsCreateWithoutCouponInput = {
    contract: contractCreateNestedOneWithoutContract_couponsInput
  }

  export type contract_couponsUncheckedCreateWithoutCouponInput = {
    contract_id: string
  }

  export type contract_couponsCreateOrConnectWithoutCouponInput = {
    where: contract_couponsWhereUniqueInput
    create: XOR<contract_couponsCreateWithoutCouponInput, contract_couponsUncheckedCreateWithoutCouponInput>
  }

  export type contract_couponsCreateManyCouponInputEnvelope = {
    data: contract_couponsCreateManyCouponInput | contract_couponsCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type reservationCreateWithoutCouponInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutReservationInput
    flight?: flightCreateNestedOneWithoutReservationInput
    user?: userCreateNestedOneWithoutReservationInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutCouponInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    flight_id?: string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutReservationInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutCouponInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutCouponInput, reservationUncheckedCreateWithoutCouponInput>
  }

  export type reservationCreateManyCouponInputEnvelope = {
    data: reservationCreateManyCouponInput | reservationCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type contractUpsertWithWhereUniqueWithoutCouponInput = {
    where: contractWhereUniqueInput
    update: XOR<contractUpdateWithoutCouponInput, contractUncheckedUpdateWithoutCouponInput>
    create: XOR<contractCreateWithoutCouponInput, contractUncheckedCreateWithoutCouponInput>
  }

  export type contractUpdateWithWhereUniqueWithoutCouponInput = {
    where: contractWhereUniqueInput
    data: XOR<contractUpdateWithoutCouponInput, contractUncheckedUpdateWithoutCouponInput>
  }

  export type contractUpdateManyWithWhereWithoutCouponInput = {
    where: contractScalarWhereInput
    data: XOR<contractUpdateManyMutationInput, contractUncheckedUpdateManyWithoutCouponInput>
  }

  export type contractScalarWhereInput = {
    AND?: contractScalarWhereInput | contractScalarWhereInput[]
    OR?: contractScalarWhereInput[]
    NOT?: contractScalarWhereInput | contractScalarWhereInput[]
    id?: StringFilter<"contract"> | string
    clientType?: StringFilter<"contract"> | string
    label?: StringFilter<"contract"> | string
    contractStartDate?: DateTimeFilter<"contract"> | Date | string
    contractEndDate?: DateTimeFilter<"contract"> | Date | string
    guaranteedMinimum?: DecimalFilter<"contract"> | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFilter<"contract"> | Date | string
    travelEndDate?: DateTimeFilter<"contract"> | Date | string
    isActive?: IntFilter<"contract"> | number
    modifiedFeeAmount?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFilter<"contract"> | number
    payLaterTimeLimit?: IntNullableFilter<"contract"> | number | null
    minTimeBeforeBalanceFlight?: IntNullableFilter<"contract"> | number | null
    invoiceStamp?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"contract"> | Date | string
    updatedAt?: DateTimeFilter<"contract"> | Date | string
    client_id?: StringNullableFilter<"contract"> | string | null
    fixedTicketPrice?: DecimalNullableFilter<"contract"> | Decimal | DecimalJsLike | number | string | null
    coupon_id?: StringNullableFilter<"contract"> | string | null
  }

  export type contract_couponsUpsertWithWhereUniqueWithoutCouponInput = {
    where: contract_couponsWhereUniqueInput
    update: XOR<contract_couponsUpdateWithoutCouponInput, contract_couponsUncheckedUpdateWithoutCouponInput>
    create: XOR<contract_couponsCreateWithoutCouponInput, contract_couponsUncheckedCreateWithoutCouponInput>
  }

  export type contract_couponsUpdateWithWhereUniqueWithoutCouponInput = {
    where: contract_couponsWhereUniqueInput
    data: XOR<contract_couponsUpdateWithoutCouponInput, contract_couponsUncheckedUpdateWithoutCouponInput>
  }

  export type contract_couponsUpdateManyWithWhereWithoutCouponInput = {
    where: contract_couponsScalarWhereInput
    data: XOR<contract_couponsUpdateManyMutationInput, contract_couponsUncheckedUpdateManyWithoutCouponInput>
  }

  export type reservationUpsertWithWhereUniqueWithoutCouponInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutCouponInput, reservationUncheckedUpdateWithoutCouponInput>
    create: XOR<reservationCreateWithoutCouponInput, reservationUncheckedCreateWithoutCouponInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutCouponInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutCouponInput, reservationUncheckedUpdateWithoutCouponInput>
  }

  export type reservationUpdateManyWithWhereWithoutCouponInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutCouponInput>
  }

  export type reservationScalarWhereInput = {
    AND?: reservationScalarWhereInput | reservationScalarWhereInput[]
    OR?: reservationScalarWhereInput[]
    NOT?: reservationScalarWhereInput | reservationScalarWhereInput[]
    id?: StringFilter<"reservation"> | string
    date_reservation?: DateTimeFilter<"reservation"> | Date | string
    statut?: StringFilter<"reservation"> | string
    prix_total?: DecimalFilter<"reservation"> | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFilter<"reservation"> | number
    coupon_code?: StringNullableFilter<"reservation"> | string | null
    discount_amount?: DecimalNullableFilter<"reservation"> | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFilter<"reservation"> | string
    fare_type?: StringFilter<"reservation"> | string
    user_id?: StringNullableFilter<"reservation"> | string | null
    flight_id?: StringNullableFilter<"reservation"> | string | null
    coupon_id?: StringNullableFilter<"reservation"> | string | null
  }

  export type planeCreateWithoutFlightInput = {
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    seat?: seatCreateNestedManyWithoutPlaneInput
  }

  export type planeUncheckedCreateWithoutFlightInput = {
    idPlane?: number
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    seat?: seatUncheckedCreateNestedManyWithoutPlaneInput
  }

  export type planeCreateOrConnectWithoutFlightInput = {
    where: planeWhereUniqueInput
    create: XOR<planeCreateWithoutFlightInput, planeUncheckedCreateWithoutFlightInput>
  }

  export type airportCreateWithoutFlight_flight_airport_depart_idToairportInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location?: locationCreateNestedOneWithoutAirportInput
    flight_flight_airport_arrivee_idToairport?: flightCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput
  }

  export type airportUncheckedCreateWithoutFlight_flight_airport_depart_idToairportInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location_id?: string | null
    flight_flight_airport_arrivee_idToairport?: flightUncheckedCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput
  }

  export type airportCreateOrConnectWithoutFlight_flight_airport_depart_idToairportInput = {
    where: airportWhereUniqueInput
    create: XOR<airportCreateWithoutFlight_flight_airport_depart_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_depart_idToairportInput>
  }

  export type airportCreateWithoutFlight_flight_airport_arrivee_idToairportInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location?: locationCreateNestedOneWithoutAirportInput
    flight_flight_airport_depart_idToairport?: flightCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput
  }

  export type airportUncheckedCreateWithoutFlight_flight_airport_arrivee_idToairportInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    location_id?: string | null
    flight_flight_airport_depart_idToairport?: flightUncheckedCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput
  }

  export type airportCreateOrConnectWithoutFlight_flight_airport_arrivee_idToairportInput = {
    where: airportWhereUniqueInput
    create: XOR<airportCreateWithoutFlight_flight_airport_arrivee_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_arrivee_idToairportInput>
  }

  export type flight_seat_reservationCreateWithoutFlightInput = {
    id: string
    isReserved?: number
    seat?: seatCreateNestedOneWithoutFlight_seat_reservationInput
    reservation?: reservationCreateNestedOneWithoutFlight_seat_reservationInput
  }

  export type flight_seat_reservationUncheckedCreateWithoutFlightInput = {
    id: string
    isReserved?: number
    seat_id?: number | null
    reservation_id?: string | null
  }

  export type flight_seat_reservationCreateOrConnectWithoutFlightInput = {
    where: flight_seat_reservationWhereUniqueInput
    create: XOR<flight_seat_reservationCreateWithoutFlightInput, flight_seat_reservationUncheckedCreateWithoutFlightInput>
  }

  export type flight_seat_reservationCreateManyFlightInputEnvelope = {
    data: flight_seat_reservationCreateManyFlightInput | flight_seat_reservationCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type reservationCreateWithoutFlightInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutReservationInput
    coupon?: couponCreateNestedOneWithoutReservationInput
    user?: userCreateNestedOneWithoutReservationInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutFlightInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    coupon_id?: string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutReservationInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutFlightInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutFlightInput, reservationUncheckedCreateWithoutFlightInput>
  }

  export type reservationCreateManyFlightInputEnvelope = {
    data: reservationCreateManyFlightInput | reservationCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type seat_reservationCreateWithoutFlightInput = {
    reservation?: reservationCreateNestedOneWithoutSeat_reservationInput
    seat?: seatCreateNestedOneWithoutSeat_reservationInput
  }

  export type seat_reservationUncheckedCreateWithoutFlightInput = {
    id?: number
    seat_id?: number | null
    reservation_id?: string | null
  }

  export type seat_reservationCreateOrConnectWithoutFlightInput = {
    where: seat_reservationWhereUniqueInput
    create: XOR<seat_reservationCreateWithoutFlightInput, seat_reservationUncheckedCreateWithoutFlightInput>
  }

  export type seat_reservationCreateManyFlightInputEnvelope = {
    data: seat_reservationCreateManyFlightInput | seat_reservationCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type planeUpsertWithoutFlightInput = {
    update: XOR<planeUpdateWithoutFlightInput, planeUncheckedUpdateWithoutFlightInput>
    create: XOR<planeCreateWithoutFlightInput, planeUncheckedCreateWithoutFlightInput>
    where?: planeWhereInput
  }

  export type planeUpdateToOneWithWhereWithoutFlightInput = {
    where?: planeWhereInput
    data: XOR<planeUpdateWithoutFlightInput, planeUncheckedUpdateWithoutFlightInput>
  }

  export type planeUpdateWithoutFlightInput = {
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
    seat?: seatUpdateManyWithoutPlaneNestedInput
  }

  export type planeUncheckedUpdateWithoutFlightInput = {
    idPlane?: IntFieldUpdateOperationsInput | number
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
    seat?: seatUncheckedUpdateManyWithoutPlaneNestedInput
  }

  export type airportUpsertWithoutFlight_flight_airport_depart_idToairportInput = {
    update: XOR<airportUpdateWithoutFlight_flight_airport_depart_idToairportInput, airportUncheckedUpdateWithoutFlight_flight_airport_depart_idToairportInput>
    create: XOR<airportCreateWithoutFlight_flight_airport_depart_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_depart_idToairportInput>
    where?: airportWhereInput
  }

  export type airportUpdateToOneWithWhereWithoutFlight_flight_airport_depart_idToairportInput = {
    where?: airportWhereInput
    data: XOR<airportUpdateWithoutFlight_flight_airport_depart_idToairportInput, airportUncheckedUpdateWithoutFlight_flight_airport_depart_idToairportInput>
  }

  export type airportUpdateWithoutFlight_flight_airport_depart_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location?: locationUpdateOneWithoutAirportNestedInput
    flight_flight_airport_arrivee_idToairport?: flightUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput
  }

  export type airportUncheckedUpdateWithoutFlight_flight_airport_depart_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_flight_airport_arrivee_idToairport?: flightUncheckedUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput
  }

  export type airportUpsertWithoutFlight_flight_airport_arrivee_idToairportInput = {
    update: XOR<airportUpdateWithoutFlight_flight_airport_arrivee_idToairportInput, airportUncheckedUpdateWithoutFlight_flight_airport_arrivee_idToairportInput>
    create: XOR<airportCreateWithoutFlight_flight_airport_arrivee_idToairportInput, airportUncheckedCreateWithoutFlight_flight_airport_arrivee_idToairportInput>
    where?: airportWhereInput
  }

  export type airportUpdateToOneWithWhereWithoutFlight_flight_airport_arrivee_idToairportInput = {
    where?: airportWhereInput
    data: XOR<airportUpdateWithoutFlight_flight_airport_arrivee_idToairportInput, airportUncheckedUpdateWithoutFlight_flight_airport_arrivee_idToairportInput>
  }

  export type airportUpdateWithoutFlight_flight_airport_arrivee_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location?: locationUpdateOneWithoutAirportNestedInput
    flight_flight_airport_depart_idToairport?: flightUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput
  }

  export type airportUncheckedUpdateWithoutFlight_flight_airport_arrivee_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    location_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_flight_airport_depart_idToairport?: flightUncheckedUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput
  }

  export type flight_seat_reservationUpsertWithWhereUniqueWithoutFlightInput = {
    where: flight_seat_reservationWhereUniqueInput
    update: XOR<flight_seat_reservationUpdateWithoutFlightInput, flight_seat_reservationUncheckedUpdateWithoutFlightInput>
    create: XOR<flight_seat_reservationCreateWithoutFlightInput, flight_seat_reservationUncheckedCreateWithoutFlightInput>
  }

  export type flight_seat_reservationUpdateWithWhereUniqueWithoutFlightInput = {
    where: flight_seat_reservationWhereUniqueInput
    data: XOR<flight_seat_reservationUpdateWithoutFlightInput, flight_seat_reservationUncheckedUpdateWithoutFlightInput>
  }

  export type flight_seat_reservationUpdateManyWithWhereWithoutFlightInput = {
    where: flight_seat_reservationScalarWhereInput
    data: XOR<flight_seat_reservationUpdateManyMutationInput, flight_seat_reservationUncheckedUpdateManyWithoutFlightInput>
  }

  export type flight_seat_reservationScalarWhereInput = {
    AND?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
    OR?: flight_seat_reservationScalarWhereInput[]
    NOT?: flight_seat_reservationScalarWhereInput | flight_seat_reservationScalarWhereInput[]
    id?: StringFilter<"flight_seat_reservation"> | string
    isReserved?: IntFilter<"flight_seat_reservation"> | number
    flight_id?: StringNullableFilter<"flight_seat_reservation"> | string | null
    seat_id?: IntNullableFilter<"flight_seat_reservation"> | number | null
    reservation_id?: StringNullableFilter<"flight_seat_reservation"> | string | null
  }

  export type reservationUpsertWithWhereUniqueWithoutFlightInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutFlightInput, reservationUncheckedUpdateWithoutFlightInput>
    create: XOR<reservationCreateWithoutFlightInput, reservationUncheckedCreateWithoutFlightInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutFlightInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutFlightInput, reservationUncheckedUpdateWithoutFlightInput>
  }

  export type reservationUpdateManyWithWhereWithoutFlightInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutFlightInput>
  }

  export type seat_reservationUpsertWithWhereUniqueWithoutFlightInput = {
    where: seat_reservationWhereUniqueInput
    update: XOR<seat_reservationUpdateWithoutFlightInput, seat_reservationUncheckedUpdateWithoutFlightInput>
    create: XOR<seat_reservationCreateWithoutFlightInput, seat_reservationUncheckedCreateWithoutFlightInput>
  }

  export type seat_reservationUpdateWithWhereUniqueWithoutFlightInput = {
    where: seat_reservationWhereUniqueInput
    data: XOR<seat_reservationUpdateWithoutFlightInput, seat_reservationUncheckedUpdateWithoutFlightInput>
  }

  export type seat_reservationUpdateManyWithWhereWithoutFlightInput = {
    where: seat_reservationScalarWhereInput
    data: XOR<seat_reservationUpdateManyMutationInput, seat_reservationUncheckedUpdateManyWithoutFlightInput>
  }

  export type seat_reservationScalarWhereInput = {
    AND?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
    OR?: seat_reservationScalarWhereInput[]
    NOT?: seat_reservationScalarWhereInput | seat_reservationScalarWhereInput[]
    id?: IntFilter<"seat_reservation"> | number
    seat_id?: IntNullableFilter<"seat_reservation"> | number | null
    reservation_id?: StringNullableFilter<"seat_reservation"> | string | null
    flight_id?: StringNullableFilter<"seat_reservation"> | string | null
  }

  export type seatCreateWithoutFlight_seat_reservationInput = {
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    plane?: planeCreateNestedOneWithoutSeatInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutSeatInput
  }

  export type seatUncheckedCreateWithoutFlight_seat_reservationInput = {
    idSeat?: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    idPlane?: number | null
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutSeatInput
  }

  export type seatCreateOrConnectWithoutFlight_seat_reservationInput = {
    where: seatWhereUniqueInput
    create: XOR<seatCreateWithoutFlight_seat_reservationInput, seatUncheckedCreateWithoutFlight_seat_reservationInput>
  }

  export type flightCreateWithoutFlight_seat_reservationInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    plane?: planeCreateNestedOneWithoutFlightInput
    airport_flight_airport_depart_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput
    airport_flight_airport_arrivee_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput
    reservation?: reservationCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateWithoutFlight_seat_reservationInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
    plane_id?: number | null
    reservation?: reservationUncheckedCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightCreateOrConnectWithoutFlight_seat_reservationInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutFlight_seat_reservationInput, flightUncheckedCreateWithoutFlight_seat_reservationInput>
  }

  export type reservationCreateWithoutFlight_seat_reservationInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight?: flightCreateNestedOneWithoutReservationInput
    coupon?: couponCreateNestedOneWithoutReservationInput
    user?: userCreateNestedOneWithoutReservationInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutFlight_seat_reservationInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    flight_id?: string | null
    coupon_id?: string | null
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutFlight_seat_reservationInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutFlight_seat_reservationInput, reservationUncheckedCreateWithoutFlight_seat_reservationInput>
  }

  export type seatUpsertWithoutFlight_seat_reservationInput = {
    update: XOR<seatUpdateWithoutFlight_seat_reservationInput, seatUncheckedUpdateWithoutFlight_seat_reservationInput>
    create: XOR<seatCreateWithoutFlight_seat_reservationInput, seatUncheckedCreateWithoutFlight_seat_reservationInput>
    where?: seatWhereInput
  }

  export type seatUpdateToOneWithWhereWithoutFlight_seat_reservationInput = {
    where?: seatWhereInput
    data: XOR<seatUpdateWithoutFlight_seat_reservationInput, seatUncheckedUpdateWithoutFlight_seat_reservationInput>
  }

  export type seatUpdateWithoutFlight_seat_reservationInput = {
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    plane?: planeUpdateOneWithoutSeatNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateWithoutFlight_seat_reservationInput = {
    idSeat?: IntFieldUpdateOperationsInput | number
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    idPlane?: NullableIntFieldUpdateOperationsInput | number | null
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type flightUpsertWithoutFlight_seat_reservationInput = {
    update: XOR<flightUpdateWithoutFlight_seat_reservationInput, flightUncheckedUpdateWithoutFlight_seat_reservationInput>
    create: XOR<flightCreateWithoutFlight_seat_reservationInput, flightUncheckedCreateWithoutFlight_seat_reservationInput>
    where?: flightWhereInput
  }

  export type flightUpdateToOneWithWhereWithoutFlight_seat_reservationInput = {
    where?: flightWhereInput
    data: XOR<flightUpdateWithoutFlight_seat_reservationInput, flightUncheckedUpdateWithoutFlight_seat_reservationInput>
  }

  export type flightUpdateWithoutFlight_seat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plane?: planeUpdateOneWithoutFlightNestedInput
    airport_flight_airport_depart_idToairport?: airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput
    airport_flight_airport_arrivee_idToairport?: airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput
    reservation?: reservationUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateWithoutFlight_seat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation?: reservationUncheckedUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type reservationUpsertWithoutFlight_seat_reservationInput = {
    update: XOR<reservationUpdateWithoutFlight_seat_reservationInput, reservationUncheckedUpdateWithoutFlight_seat_reservationInput>
    create: XOR<reservationCreateWithoutFlight_seat_reservationInput, reservationUncheckedCreateWithoutFlight_seat_reservationInput>
    where?: reservationWhereInput
  }

  export type reservationUpdateToOneWithWhereWithoutFlight_seat_reservationInput = {
    where?: reservationWhereInput
    data: XOR<reservationUpdateWithoutFlight_seat_reservationInput, reservationUncheckedUpdateWithoutFlight_seat_reservationInput>
  }

  export type reservationUpdateWithoutFlight_seat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight?: flightUpdateOneWithoutReservationNestedInput
    coupon?: couponUpdateOneWithoutReservationNestedInput
    user?: userUpdateOneWithoutReservationNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutFlight_seat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type airportCreateWithoutLocationInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    flight_flight_airport_depart_idToairport?: flightCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput
    flight_flight_airport_arrivee_idToairport?: flightCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput
  }

  export type airportUncheckedCreateWithoutLocationInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
    flight_flight_airport_depart_idToairport?: flightUncheckedCreateNestedManyWithoutAirport_flight_airport_depart_idToairportInput
    flight_flight_airport_arrivee_idToairport?: flightUncheckedCreateNestedManyWithoutAirport_flight_airport_arrivee_idToairportInput
  }

  export type airportCreateOrConnectWithoutLocationInput = {
    where: airportWhereUniqueInput
    create: XOR<airportCreateWithoutLocationInput, airportUncheckedCreateWithoutLocationInput>
  }

  export type airportCreateManyLocationInputEnvelope = {
    data: airportCreateManyLocationInput | airportCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type airportUpsertWithWhereUniqueWithoutLocationInput = {
    where: airportWhereUniqueInput
    update: XOR<airportUpdateWithoutLocationInput, airportUncheckedUpdateWithoutLocationInput>
    create: XOR<airportCreateWithoutLocationInput, airportUncheckedCreateWithoutLocationInput>
  }

  export type airportUpdateWithWhereUniqueWithoutLocationInput = {
    where: airportWhereUniqueInput
    data: XOR<airportUpdateWithoutLocationInput, airportUncheckedUpdateWithoutLocationInput>
  }

  export type airportUpdateManyWithWhereWithoutLocationInput = {
    where: airportScalarWhereInput
    data: XOR<airportUpdateManyMutationInput, airportUncheckedUpdateManyWithoutLocationInput>
  }

  export type airportScalarWhereInput = {
    AND?: airportScalarWhereInput | airportScalarWhereInput[]
    OR?: airportScalarWhereInput[]
    NOT?: airportScalarWhereInput | airportScalarWhereInput[]
    id?: StringFilter<"airport"> | string
    nom?: StringFilter<"airport"> | string
    code?: StringFilter<"airport"> | string
    pays?: StringFilter<"airport"> | string
    description?: StringNullableFilter<"airport"> | string | null
    est_actif?: IntFilter<"airport"> | number
    location_id?: StringNullableFilter<"airport"> | string | null
  }

  export type flightCreateWithoutPlaneInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_flight_airport_depart_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput
    airport_flight_airport_arrivee_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutFlightInput
    reservation?: reservationCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateWithoutPlaneInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput
    reservation?: reservationUncheckedCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightCreateOrConnectWithoutPlaneInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutPlaneInput, flightUncheckedCreateWithoutPlaneInput>
  }

  export type flightCreateManyPlaneInputEnvelope = {
    data: flightCreateManyPlaneInput | flightCreateManyPlaneInput[]
    skipDuplicates?: boolean
  }

  export type seatCreateWithoutPlaneInput = {
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutSeatInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutSeatInput
  }

  export type seatUncheckedCreateWithoutPlaneInput = {
    idSeat?: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutSeatInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutSeatInput
  }

  export type seatCreateOrConnectWithoutPlaneInput = {
    where: seatWhereUniqueInput
    create: XOR<seatCreateWithoutPlaneInput, seatUncheckedCreateWithoutPlaneInput>
  }

  export type seatCreateManyPlaneInputEnvelope = {
    data: seatCreateManyPlaneInput | seatCreateManyPlaneInput[]
    skipDuplicates?: boolean
  }

  export type flightUpsertWithWhereUniqueWithoutPlaneInput = {
    where: flightWhereUniqueInput
    update: XOR<flightUpdateWithoutPlaneInput, flightUncheckedUpdateWithoutPlaneInput>
    create: XOR<flightCreateWithoutPlaneInput, flightUncheckedCreateWithoutPlaneInput>
  }

  export type flightUpdateWithWhereUniqueWithoutPlaneInput = {
    where: flightWhereUniqueInput
    data: XOR<flightUpdateWithoutPlaneInput, flightUncheckedUpdateWithoutPlaneInput>
  }

  export type flightUpdateManyWithWhereWithoutPlaneInput = {
    where: flightScalarWhereInput
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyWithoutPlaneInput>
  }

  export type seatUpsertWithWhereUniqueWithoutPlaneInput = {
    where: seatWhereUniqueInput
    update: XOR<seatUpdateWithoutPlaneInput, seatUncheckedUpdateWithoutPlaneInput>
    create: XOR<seatCreateWithoutPlaneInput, seatUncheckedCreateWithoutPlaneInput>
  }

  export type seatUpdateWithWhereUniqueWithoutPlaneInput = {
    where: seatWhereUniqueInput
    data: XOR<seatUpdateWithoutPlaneInput, seatUncheckedUpdateWithoutPlaneInput>
  }

  export type seatUpdateManyWithWhereWithoutPlaneInput = {
    where: seatScalarWhereInput
    data: XOR<seatUpdateManyMutationInput, seatUncheckedUpdateManyWithoutPlaneInput>
  }

  export type seatScalarWhereInput = {
    AND?: seatScalarWhereInput | seatScalarWhereInput[]
    OR?: seatScalarWhereInput[]
    NOT?: seatScalarWhereInput | seatScalarWhereInput[]
    idSeat?: IntFilter<"seat"> | number
    seatNumber?: StringFilter<"seat"> | string
    classType?: Enumseat_classTypeFilter<"seat"> | $Enums.seat_classType
    availability?: IntFilter<"seat"> | number
    idPlane?: IntNullableFilter<"seat"> | number | null
  }

  export type userCreateWithoutReclamationInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteCreateNestedOneWithoutUserInput
    contract?: contractCreateNestedManyWithoutUserInput
    request_solde?: request_soldeCreateNestedManyWithoutUserInput
    reservation?: reservationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReclamationInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteUncheckedCreateNestedOneWithoutUserInput
    contract?: contractUncheckedCreateNestedManyWithoutUserInput
    request_solde?: request_soldeUncheckedCreateNestedManyWithoutUserInput
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReclamationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReclamationInput, userUncheckedCreateWithoutReclamationInput>
  }

  export type userUpsertWithoutReclamationInput = {
    update: XOR<userUpdateWithoutReclamationInput, userUncheckedUpdateWithoutReclamationInput>
    create: XOR<userCreateWithoutReclamationInput, userUncheckedCreateWithoutReclamationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReclamationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReclamationInput, userUncheckedUpdateWithoutReclamationInput>
  }

  export type userUpdateWithoutReclamationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUpdateOneWithoutUserNestedInput
    contract?: contractUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUpdateManyWithoutUserNestedInput
    reservation?: reservationUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReclamationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUncheckedUpdateOneWithoutUserNestedInput
    contract?: contractUncheckedUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUncheckedUpdateManyWithoutUserNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutRequest_soldeInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteCreateNestedOneWithoutUserInput
    contract?: contractCreateNestedManyWithoutUserInput
    reclamation?: reclamationCreateNestedManyWithoutUserInput
    reservation?: reservationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRequest_soldeInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteUncheckedCreateNestedOneWithoutUserInput
    contract?: contractUncheckedCreateNestedManyWithoutUserInput
    reclamation?: reclamationUncheckedCreateNestedManyWithoutUserInput
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRequest_soldeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRequest_soldeInput, userUncheckedCreateWithoutRequest_soldeInput>
  }

  export type userUpsertWithoutRequest_soldeInput = {
    update: XOR<userUpdateWithoutRequest_soldeInput, userUncheckedUpdateWithoutRequest_soldeInput>
    create: XOR<userCreateWithoutRequest_soldeInput, userUncheckedCreateWithoutRequest_soldeInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRequest_soldeInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRequest_soldeInput, userUncheckedUpdateWithoutRequest_soldeInput>
  }

  export type userUpdateWithoutRequest_soldeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUpdateOneWithoutUserNestedInput
    contract?: contractUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUpdateManyWithoutUserNestedInput
    reservation?: reservationUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRequest_soldeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUncheckedUpdateOneWithoutUserNestedInput
    contract?: contractUncheckedUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUncheckedUpdateManyWithoutUserNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type flight_seat_reservationCreateWithoutReservationInput = {
    id: string
    isReserved?: number
    seat?: seatCreateNestedOneWithoutFlight_seat_reservationInput
    flight?: flightCreateNestedOneWithoutFlight_seat_reservationInput
  }

  export type flight_seat_reservationUncheckedCreateWithoutReservationInput = {
    id: string
    isReserved?: number
    flight_id?: string | null
    seat_id?: number | null
  }

  export type flight_seat_reservationCreateOrConnectWithoutReservationInput = {
    where: flight_seat_reservationWhereUniqueInput
    create: XOR<flight_seat_reservationCreateWithoutReservationInput, flight_seat_reservationUncheckedCreateWithoutReservationInput>
  }

  export type flight_seat_reservationCreateManyReservationInputEnvelope = {
    data: flight_seat_reservationCreateManyReservationInput | flight_seat_reservationCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type flightCreateWithoutReservationInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    plane?: planeCreateNestedOneWithoutFlightInput
    airport_flight_airport_depart_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput
    airport_flight_airport_arrivee_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateWithoutReservationInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
    plane_id?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightCreateOrConnectWithoutReservationInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutReservationInput, flightUncheckedCreateWithoutReservationInput>
  }

  export type couponCreateWithoutReservationInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract?: contractCreateNestedManyWithoutCouponInput
    contract_coupons?: contract_couponsCreateNestedManyWithoutCouponInput
  }

  export type couponUncheckedCreateWithoutReservationInput = {
    id: string
    code: string
    reduction: Decimal | DecimalJsLike | number | string
    reduction_type: $Enums.coupon_reduction_type
    date_fin: Date | string
    date_creation?: Date | string
    contract?: contractUncheckedCreateNestedManyWithoutCouponInput
    contract_coupons?: contract_couponsUncheckedCreateNestedManyWithoutCouponInput
  }

  export type couponCreateOrConnectWithoutReservationInput = {
    where: couponWhereUniqueInput
    create: XOR<couponCreateWithoutReservationInput, couponUncheckedCreateWithoutReservationInput>
  }

  export type userCreateWithoutReservationInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteCreateNestedOneWithoutUserInput
    contract?: contractCreateNestedManyWithoutUserInput
    reclamation?: reclamationCreateNestedManyWithoutUserInput
    request_solde?: request_soldeCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReservationInput = {
    id: string
    nom: string
    email: string
    numero_telephone?: string | null
    pays?: string | null
    adresse?: string | null
    est_admin?: number
    mot_de_passe: string
    compte?: compteUncheckedCreateNestedOneWithoutUserInput
    contract?: contractUncheckedCreateNestedManyWithoutUserInput
    reclamation?: reclamationUncheckedCreateNestedManyWithoutUserInput
    request_solde?: request_soldeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReservationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
  }

  export type seat_reservationCreateWithoutReservationInput = {
    flight?: flightCreateNestedOneWithoutSeat_reservationInput
    seat?: seatCreateNestedOneWithoutSeat_reservationInput
  }

  export type seat_reservationUncheckedCreateWithoutReservationInput = {
    id?: number
    seat_id?: number | null
    flight_id?: string | null
  }

  export type seat_reservationCreateOrConnectWithoutReservationInput = {
    where: seat_reservationWhereUniqueInput
    create: XOR<seat_reservationCreateWithoutReservationInput, seat_reservationUncheckedCreateWithoutReservationInput>
  }

  export type seat_reservationCreateManyReservationInputEnvelope = {
    data: seat_reservationCreateManyReservationInput | seat_reservationCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type flight_seat_reservationUpsertWithWhereUniqueWithoutReservationInput = {
    where: flight_seat_reservationWhereUniqueInput
    update: XOR<flight_seat_reservationUpdateWithoutReservationInput, flight_seat_reservationUncheckedUpdateWithoutReservationInput>
    create: XOR<flight_seat_reservationCreateWithoutReservationInput, flight_seat_reservationUncheckedCreateWithoutReservationInput>
  }

  export type flight_seat_reservationUpdateWithWhereUniqueWithoutReservationInput = {
    where: flight_seat_reservationWhereUniqueInput
    data: XOR<flight_seat_reservationUpdateWithoutReservationInput, flight_seat_reservationUncheckedUpdateWithoutReservationInput>
  }

  export type flight_seat_reservationUpdateManyWithWhereWithoutReservationInput = {
    where: flight_seat_reservationScalarWhereInput
    data: XOR<flight_seat_reservationUpdateManyMutationInput, flight_seat_reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type flightUpsertWithoutReservationInput = {
    update: XOR<flightUpdateWithoutReservationInput, flightUncheckedUpdateWithoutReservationInput>
    create: XOR<flightCreateWithoutReservationInput, flightUncheckedCreateWithoutReservationInput>
    where?: flightWhereInput
  }

  export type flightUpdateToOneWithWhereWithoutReservationInput = {
    where?: flightWhereInput
    data: XOR<flightUpdateWithoutReservationInput, flightUncheckedUpdateWithoutReservationInput>
  }

  export type flightUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plane?: planeUpdateOneWithoutFlightNestedInput
    airport_flight_airport_depart_idToairport?: airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput
    airport_flight_airport_arrivee_idToairport?: airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type couponUpsertWithoutReservationInput = {
    update: XOR<couponUpdateWithoutReservationInput, couponUncheckedUpdateWithoutReservationInput>
    create: XOR<couponCreateWithoutReservationInput, couponUncheckedCreateWithoutReservationInput>
    where?: couponWhereInput
  }

  export type couponUpdateToOneWithWhereWithoutReservationInput = {
    where?: couponWhereInput
    data: XOR<couponUpdateWithoutReservationInput, couponUncheckedUpdateWithoutReservationInput>
  }

  export type couponUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: contractUpdateManyWithoutCouponNestedInput
    contract_coupons?: contract_couponsUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reduction?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reduction_type?: Enumcoupon_reduction_typeFieldUpdateOperationsInput | $Enums.coupon_reduction_type
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: contractUncheckedUpdateManyWithoutCouponNestedInput
    contract_coupons?: contract_couponsUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type userUpsertWithoutReservationInput = {
    update: XOR<userUpdateWithoutReservationInput, userUncheckedUpdateWithoutReservationInput>
    create: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReservationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReservationInput, userUncheckedUpdateWithoutReservationInput>
  }

  export type userUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUpdateOneWithoutUserNestedInput
    contract?: contractUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    numero_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    pays?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    est_admin?: IntFieldUpdateOperationsInput | number
    mot_de_passe?: StringFieldUpdateOperationsInput | string
    compte?: compteUncheckedUpdateOneWithoutUserNestedInput
    contract?: contractUncheckedUpdateManyWithoutUserNestedInput
    reclamation?: reclamationUncheckedUpdateManyWithoutUserNestedInput
    request_solde?: request_soldeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type seat_reservationUpsertWithWhereUniqueWithoutReservationInput = {
    where: seat_reservationWhereUniqueInput
    update: XOR<seat_reservationUpdateWithoutReservationInput, seat_reservationUncheckedUpdateWithoutReservationInput>
    create: XOR<seat_reservationCreateWithoutReservationInput, seat_reservationUncheckedCreateWithoutReservationInput>
  }

  export type seat_reservationUpdateWithWhereUniqueWithoutReservationInput = {
    where: seat_reservationWhereUniqueInput
    data: XOR<seat_reservationUpdateWithoutReservationInput, seat_reservationUncheckedUpdateWithoutReservationInput>
  }

  export type seat_reservationUpdateManyWithWhereWithoutReservationInput = {
    where: seat_reservationScalarWhereInput
    data: XOR<seat_reservationUpdateManyMutationInput, seat_reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type flight_seat_reservationCreateWithoutSeatInput = {
    id: string
    isReserved?: number
    flight?: flightCreateNestedOneWithoutFlight_seat_reservationInput
    reservation?: reservationCreateNestedOneWithoutFlight_seat_reservationInput
  }

  export type flight_seat_reservationUncheckedCreateWithoutSeatInput = {
    id: string
    isReserved?: number
    flight_id?: string | null
    reservation_id?: string | null
  }

  export type flight_seat_reservationCreateOrConnectWithoutSeatInput = {
    where: flight_seat_reservationWhereUniqueInput
    create: XOR<flight_seat_reservationCreateWithoutSeatInput, flight_seat_reservationUncheckedCreateWithoutSeatInput>
  }

  export type flight_seat_reservationCreateManySeatInputEnvelope = {
    data: flight_seat_reservationCreateManySeatInput | flight_seat_reservationCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type planeCreateWithoutSeatInput = {
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    flight?: flightCreateNestedManyWithoutPlaneInput
  }

  export type planeUncheckedCreateWithoutSeatInput = {
    idPlane?: number
    planeModel: string
    totalSeats: number
    seatConfiguration: string
    flight?: flightUncheckedCreateNestedManyWithoutPlaneInput
  }

  export type planeCreateOrConnectWithoutSeatInput = {
    where: planeWhereUniqueInput
    create: XOR<planeCreateWithoutSeatInput, planeUncheckedCreateWithoutSeatInput>
  }

  export type seat_reservationCreateWithoutSeatInput = {
    flight?: flightCreateNestedOneWithoutSeat_reservationInput
    reservation?: reservationCreateNestedOneWithoutSeat_reservationInput
  }

  export type seat_reservationUncheckedCreateWithoutSeatInput = {
    id?: number
    reservation_id?: string | null
    flight_id?: string | null
  }

  export type seat_reservationCreateOrConnectWithoutSeatInput = {
    where: seat_reservationWhereUniqueInput
    create: XOR<seat_reservationCreateWithoutSeatInput, seat_reservationUncheckedCreateWithoutSeatInput>
  }

  export type seat_reservationCreateManySeatInputEnvelope = {
    data: seat_reservationCreateManySeatInput | seat_reservationCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type flight_seat_reservationUpsertWithWhereUniqueWithoutSeatInput = {
    where: flight_seat_reservationWhereUniqueInput
    update: XOR<flight_seat_reservationUpdateWithoutSeatInput, flight_seat_reservationUncheckedUpdateWithoutSeatInput>
    create: XOR<flight_seat_reservationCreateWithoutSeatInput, flight_seat_reservationUncheckedCreateWithoutSeatInput>
  }

  export type flight_seat_reservationUpdateWithWhereUniqueWithoutSeatInput = {
    where: flight_seat_reservationWhereUniqueInput
    data: XOR<flight_seat_reservationUpdateWithoutSeatInput, flight_seat_reservationUncheckedUpdateWithoutSeatInput>
  }

  export type flight_seat_reservationUpdateManyWithWhereWithoutSeatInput = {
    where: flight_seat_reservationScalarWhereInput
    data: XOR<flight_seat_reservationUpdateManyMutationInput, flight_seat_reservationUncheckedUpdateManyWithoutSeatInput>
  }

  export type planeUpsertWithoutSeatInput = {
    update: XOR<planeUpdateWithoutSeatInput, planeUncheckedUpdateWithoutSeatInput>
    create: XOR<planeCreateWithoutSeatInput, planeUncheckedCreateWithoutSeatInput>
    where?: planeWhereInput
  }

  export type planeUpdateToOneWithWhereWithoutSeatInput = {
    where?: planeWhereInput
    data: XOR<planeUpdateWithoutSeatInput, planeUncheckedUpdateWithoutSeatInput>
  }

  export type planeUpdateWithoutSeatInput = {
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
    flight?: flightUpdateManyWithoutPlaneNestedInput
  }

  export type planeUncheckedUpdateWithoutSeatInput = {
    idPlane?: IntFieldUpdateOperationsInput | number
    planeModel?: StringFieldUpdateOperationsInput | string
    totalSeats?: IntFieldUpdateOperationsInput | number
    seatConfiguration?: StringFieldUpdateOperationsInput | string
    flight?: flightUncheckedUpdateManyWithoutPlaneNestedInput
  }

  export type seat_reservationUpsertWithWhereUniqueWithoutSeatInput = {
    where: seat_reservationWhereUniqueInput
    update: XOR<seat_reservationUpdateWithoutSeatInput, seat_reservationUncheckedUpdateWithoutSeatInput>
    create: XOR<seat_reservationCreateWithoutSeatInput, seat_reservationUncheckedCreateWithoutSeatInput>
  }

  export type seat_reservationUpdateWithWhereUniqueWithoutSeatInput = {
    where: seat_reservationWhereUniqueInput
    data: XOR<seat_reservationUpdateWithoutSeatInput, seat_reservationUncheckedUpdateWithoutSeatInput>
  }

  export type seat_reservationUpdateManyWithWhereWithoutSeatInput = {
    where: seat_reservationScalarWhereInput
    data: XOR<seat_reservationUpdateManyMutationInput, seat_reservationUncheckedUpdateManyWithoutSeatInput>
  }

  export type flightCreateWithoutSeat_reservationInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    plane?: planeCreateNestedOneWithoutFlightInput
    airport_flight_airport_depart_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_depart_idToairportInput
    airport_flight_airport_arrivee_idToairport?: airportCreateNestedOneWithoutFlight_flight_airport_arrivee_idToairportInput
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutFlightInput
    reservation?: reservationCreateNestedManyWithoutFlightInput
  }

  export type flightUncheckedCreateWithoutSeat_reservationInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
    plane_id?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutFlightInput
    reservation?: reservationUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightCreateOrConnectWithoutSeat_reservationInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutSeat_reservationInput, flightUncheckedCreateWithoutSeat_reservationInput>
  }

  export type reservationCreateWithoutSeat_reservationInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutReservationInput
    flight?: flightCreateNestedOneWithoutReservationInput
    coupon?: couponCreateNestedOneWithoutReservationInput
    user?: userCreateNestedOneWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutSeat_reservationInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    flight_id?: string | null
    coupon_id?: string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutSeat_reservationInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutSeat_reservationInput, reservationUncheckedCreateWithoutSeat_reservationInput>
  }

  export type seatCreateWithoutSeat_reservationInput = {
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutSeatInput
    plane?: planeCreateNestedOneWithoutSeatInput
  }

  export type seatUncheckedCreateWithoutSeat_reservationInput = {
    idSeat?: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
    idPlane?: number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutSeatInput
  }

  export type seatCreateOrConnectWithoutSeat_reservationInput = {
    where: seatWhereUniqueInput
    create: XOR<seatCreateWithoutSeat_reservationInput, seatUncheckedCreateWithoutSeat_reservationInput>
  }

  export type flightUpsertWithoutSeat_reservationInput = {
    update: XOR<flightUpdateWithoutSeat_reservationInput, flightUncheckedUpdateWithoutSeat_reservationInput>
    create: XOR<flightCreateWithoutSeat_reservationInput, flightUncheckedCreateWithoutSeat_reservationInput>
    where?: flightWhereInput
  }

  export type flightUpdateToOneWithWhereWithoutSeat_reservationInput = {
    where?: flightWhereInput
    data: XOR<flightUpdateWithoutSeat_reservationInput, flightUncheckedUpdateWithoutSeat_reservationInput>
  }

  export type flightUpdateWithoutSeat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plane?: planeUpdateOneWithoutFlightNestedInput
    airport_flight_airport_depart_idToairport?: airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput
    airport_flight_airport_arrivee_idToairport?: airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutFlightNestedInput
    reservation?: reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateWithoutSeat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type reservationUpsertWithoutSeat_reservationInput = {
    update: XOR<reservationUpdateWithoutSeat_reservationInput, reservationUncheckedUpdateWithoutSeat_reservationInput>
    create: XOR<reservationCreateWithoutSeat_reservationInput, reservationUncheckedCreateWithoutSeat_reservationInput>
    where?: reservationWhereInput
  }

  export type reservationUpdateToOneWithWhereWithoutSeat_reservationInput = {
    where?: reservationWhereInput
    data: XOR<reservationUpdateWithoutSeat_reservationInput, reservationUncheckedUpdateWithoutSeat_reservationInput>
  }

  export type reservationUpdateWithoutSeat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutReservationNestedInput
    flight?: flightUpdateOneWithoutReservationNestedInput
    coupon?: couponUpdateOneWithoutReservationNestedInput
    user?: userUpdateOneWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutSeat_reservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type seatUpsertWithoutSeat_reservationInput = {
    update: XOR<seatUpdateWithoutSeat_reservationInput, seatUncheckedUpdateWithoutSeat_reservationInput>
    create: XOR<seatCreateWithoutSeat_reservationInput, seatUncheckedCreateWithoutSeat_reservationInput>
    where?: seatWhereInput
  }

  export type seatUpdateToOneWithWhereWithoutSeat_reservationInput = {
    where?: seatWhereInput
    data: XOR<seatUpdateWithoutSeat_reservationInput, seatUncheckedUpdateWithoutSeat_reservationInput>
  }

  export type seatUpdateWithoutSeat_reservationInput = {
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutSeatNestedInput
    plane?: planeUpdateOneWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateWithoutSeat_reservationInput = {
    idSeat?: IntFieldUpdateOperationsInput | number
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    idPlane?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type compteCreateWithoutUserInput = {
    id: string
    solde?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type compteUncheckedCreateWithoutUserInput = {
    id: string
    solde?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type compteCreateOrConnectWithoutUserInput = {
    where: compteWhereUniqueInput
    create: XOR<compteCreateWithoutUserInput, compteUncheckedCreateWithoutUserInput>
  }

  export type contractCreateWithoutUserInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    coupon?: couponCreateNestedOneWithoutContractInput
    contract_coupons?: contract_couponsCreateNestedManyWithoutContractInput
  }

  export type contractUncheckedCreateWithoutUserInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    coupon_id?: string | null
    contract_coupons?: contract_couponsUncheckedCreateNestedManyWithoutContractInput
  }

  export type contractCreateOrConnectWithoutUserInput = {
    where: contractWhereUniqueInput
    create: XOR<contractCreateWithoutUserInput, contractUncheckedCreateWithoutUserInput>
  }

  export type contractCreateManyUserInputEnvelope = {
    data: contractCreateManyUserInput | contractCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type reclamationCreateWithoutUserInput = {
    id: string
    sujet: string
    description: string
    statut?: string
    date_creation?: Date | string
    reponse?: string | null
    date_reponse?: Date | string | null
  }

  export type reclamationUncheckedCreateWithoutUserInput = {
    id: string
    sujet: string
    description: string
    statut?: string
    date_creation?: Date | string
    reponse?: string | null
    date_reponse?: Date | string | null
  }

  export type reclamationCreateOrConnectWithoutUserInput = {
    where: reclamationWhereUniqueInput
    create: XOR<reclamationCreateWithoutUserInput, reclamationUncheckedCreateWithoutUserInput>
  }

  export type reclamationCreateManyUserInputEnvelope = {
    data: reclamationCreateManyUserInput | reclamationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type request_soldeCreateWithoutUserInput = {
    id: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    date?: Date | string
    status?: $Enums.request_solde_status
    imageUrl?: string | null
  }

  export type request_soldeUncheckedCreateWithoutUserInput = {
    id: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    date?: Date | string
    status?: $Enums.request_solde_status
    imageUrl?: string | null
  }

  export type request_soldeCreateOrConnectWithoutUserInput = {
    where: request_soldeWhereUniqueInput
    create: XOR<request_soldeCreateWithoutUserInput, request_soldeUncheckedCreateWithoutUserInput>
  }

  export type request_soldeCreateManyUserInputEnvelope = {
    data: request_soldeCreateManyUserInput | request_soldeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type reservationCreateWithoutUserInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_seat_reservation?: flight_seat_reservationCreateNestedManyWithoutReservationInput
    flight?: flightCreateNestedOneWithoutReservationInput
    coupon?: couponCreateNestedOneWithoutReservationInput
    seat_reservation?: seat_reservationCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutUserInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_id?: string | null
    coupon_id?: string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedCreateNestedManyWithoutReservationInput
    seat_reservation?: seat_reservationUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutUserInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput>
  }

  export type reservationCreateManyUserInputEnvelope = {
    data: reservationCreateManyUserInput | reservationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type compteUpsertWithoutUserInput = {
    update: XOR<compteUpdateWithoutUserInput, compteUncheckedUpdateWithoutUserInput>
    create: XOR<compteCreateWithoutUserInput, compteUncheckedCreateWithoutUserInput>
    where?: compteWhereInput
  }

  export type compteUpdateToOneWithWhereWithoutUserInput = {
    where?: compteWhereInput
    data: XOR<compteUpdateWithoutUserInput, compteUncheckedUpdateWithoutUserInput>
  }

  export type compteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    solde?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type compteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    solde?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contractUpsertWithWhereUniqueWithoutUserInput = {
    where: contractWhereUniqueInput
    update: XOR<contractUpdateWithoutUserInput, contractUncheckedUpdateWithoutUserInput>
    create: XOR<contractCreateWithoutUserInput, contractUncheckedCreateWithoutUserInput>
  }

  export type contractUpdateWithWhereUniqueWithoutUserInput = {
    where: contractWhereUniqueInput
    data: XOR<contractUpdateWithoutUserInput, contractUncheckedUpdateWithoutUserInput>
  }

  export type contractUpdateManyWithWhereWithoutUserInput = {
    where: contractScalarWhereInput
    data: XOR<contractUpdateManyMutationInput, contractUncheckedUpdateManyWithoutUserInput>
  }

  export type reclamationUpsertWithWhereUniqueWithoutUserInput = {
    where: reclamationWhereUniqueInput
    update: XOR<reclamationUpdateWithoutUserInput, reclamationUncheckedUpdateWithoutUserInput>
    create: XOR<reclamationCreateWithoutUserInput, reclamationUncheckedCreateWithoutUserInput>
  }

  export type reclamationUpdateWithWhereUniqueWithoutUserInput = {
    where: reclamationWhereUniqueInput
    data: XOR<reclamationUpdateWithoutUserInput, reclamationUncheckedUpdateWithoutUserInput>
  }

  export type reclamationUpdateManyWithWhereWithoutUserInput = {
    where: reclamationScalarWhereInput
    data: XOR<reclamationUpdateManyMutationInput, reclamationUncheckedUpdateManyWithoutUserInput>
  }

  export type reclamationScalarWhereInput = {
    AND?: reclamationScalarWhereInput | reclamationScalarWhereInput[]
    OR?: reclamationScalarWhereInput[]
    NOT?: reclamationScalarWhereInput | reclamationScalarWhereInput[]
    id?: StringFilter<"reclamation"> | string
    sujet?: StringFilter<"reclamation"> | string
    description?: StringFilter<"reclamation"> | string
    statut?: StringFilter<"reclamation"> | string
    date_creation?: DateTimeFilter<"reclamation"> | Date | string
    reponse?: StringNullableFilter<"reclamation"> | string | null
    date_reponse?: DateTimeNullableFilter<"reclamation"> | Date | string | null
    user_id?: StringNullableFilter<"reclamation"> | string | null
  }

  export type request_soldeUpsertWithWhereUniqueWithoutUserInput = {
    where: request_soldeWhereUniqueInput
    update: XOR<request_soldeUpdateWithoutUserInput, request_soldeUncheckedUpdateWithoutUserInput>
    create: XOR<request_soldeCreateWithoutUserInput, request_soldeUncheckedCreateWithoutUserInput>
  }

  export type request_soldeUpdateWithWhereUniqueWithoutUserInput = {
    where: request_soldeWhereUniqueInput
    data: XOR<request_soldeUpdateWithoutUserInput, request_soldeUncheckedUpdateWithoutUserInput>
  }

  export type request_soldeUpdateManyWithWhereWithoutUserInput = {
    where: request_soldeScalarWhereInput
    data: XOR<request_soldeUpdateManyMutationInput, request_soldeUncheckedUpdateManyWithoutUserInput>
  }

  export type request_soldeScalarWhereInput = {
    AND?: request_soldeScalarWhereInput | request_soldeScalarWhereInput[]
    OR?: request_soldeScalarWhereInput[]
    NOT?: request_soldeScalarWhereInput | request_soldeScalarWhereInput[]
    id?: StringFilter<"request_solde"> | string
    montant?: DecimalFilter<"request_solde"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"request_solde"> | string | null
    date?: DateTimeFilter<"request_solde"> | Date | string
    status?: Enumrequest_solde_statusFilter<"request_solde"> | $Enums.request_solde_status
    imageUrl?: StringNullableFilter<"request_solde"> | string | null
    client_id?: StringNullableFilter<"request_solde"> | string | null
  }

  export type reservationUpsertWithWhereUniqueWithoutUserInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutUserInput, reservationUncheckedUpdateWithoutUserInput>
    create: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutUserInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutUserInput, reservationUncheckedUpdateWithoutUserInput>
  }

  export type reservationUpdateManyWithWhereWithoutUserInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutUserInput>
  }

  export type flightCreateManyAirport_flight_airport_depart_idToairportInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_arrivee_id?: string | null
    plane_id?: number | null
  }

  export type flightCreateManyAirport_flight_airport_arrivee_idToairportInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    plane_id?: number | null
  }

  export type flightUpdateWithoutAirport_flight_airport_depart_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plane?: planeUpdateOneWithoutFlightNestedInput
    airport_flight_airport_arrivee_idToairport?: airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutFlightNestedInput
    reservation?: reservationUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateWithoutAirport_flight_airport_depart_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateManyWithoutAirport_flight_airport_depart_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type flightUpdateWithoutAirport_flight_airport_arrivee_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plane?: planeUpdateOneWithoutFlightNestedInput
    airport_flight_airport_depart_idToairport?: airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutFlightNestedInput
    reservation?: reservationUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateWithoutAirport_flight_airport_arrivee_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateManyWithoutAirport_flight_airport_arrivee_idToairportInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    plane_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type contract_couponsCreateManyContractInput = {
    coupon_id: string
  }

  export type contract_couponsUpdateWithoutContractInput = {
    coupon?: couponUpdateOneRequiredWithoutContract_couponsNestedInput
  }

  export type contract_couponsUncheckedUpdateWithoutContractInput = {
    coupon_id?: StringFieldUpdateOperationsInput | string
  }

  export type contract_couponsUncheckedUpdateManyWithoutContractInput = {
    coupon_id?: StringFieldUpdateOperationsInput | string
  }

  export type contractCreateManyCouponInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type contract_couponsCreateManyCouponInput = {
    contract_id: string
  }

  export type reservationCreateManyCouponInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    flight_id?: string | null
  }

  export type contractUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: userUpdateOneWithoutContractNestedInput
    contract_coupons?: contract_couponsUpdateManyWithoutContractNestedInput
  }

  export type contractUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contract_coupons?: contract_couponsUncheckedUpdateManyWithoutContractNestedInput
  }

  export type contractUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type contract_couponsUpdateWithoutCouponInput = {
    contract?: contractUpdateOneRequiredWithoutContract_couponsNestedInput
  }

  export type contract_couponsUncheckedUpdateWithoutCouponInput = {
    contract_id?: StringFieldUpdateOperationsInput | string
  }

  export type contract_couponsUncheckedUpdateManyWithoutCouponInput = {
    contract_id?: StringFieldUpdateOperationsInput | string
  }

  export type reservationUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutReservationNestedInput
    flight?: flightUpdateOneWithoutReservationNestedInput
    user?: userUpdateOneWithoutReservationNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type flight_seat_reservationCreateManyFlightInput = {
    id: string
    isReserved?: number
    seat_id?: number | null
    reservation_id?: string | null
  }

  export type reservationCreateManyFlightInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    user_id?: string | null
    coupon_id?: string | null
  }

  export type seat_reservationCreateManyFlightInput = {
    id?: number
    seat_id?: number | null
    reservation_id?: string | null
  }

  export type flight_seat_reservationUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    seat?: seatUpdateOneWithoutFlight_seat_reservationNestedInput
    reservation?: reservationUpdateOneWithoutFlight_seat_reservationNestedInput
  }

  export type flight_seat_reservationUncheckedUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type flight_seat_reservationUncheckedUpdateManyWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutReservationNestedInput
    coupon?: couponUpdateOneWithoutReservationNestedInput
    user?: userUpdateOneWithoutReservationNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateManyWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seat_reservationUpdateWithoutFlightInput = {
    reservation?: reservationUpdateOneWithoutSeat_reservationNestedInput
    seat?: seatUpdateOneWithoutSeat_reservationNestedInput
  }

  export type seat_reservationUncheckedUpdateWithoutFlightInput = {
    id?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seat_reservationUncheckedUpdateManyWithoutFlightInput = {
    id?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type airportCreateManyLocationInput = {
    id: string
    nom: string
    code: string
    pays: string
    description?: string | null
    est_actif?: number
  }

  export type airportUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    flight_flight_airport_depart_idToairport?: flightUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput
    flight_flight_airport_arrivee_idToairport?: flightUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput
  }

  export type airportUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
    flight_flight_airport_depart_idToairport?: flightUncheckedUpdateManyWithoutAirport_flight_airport_depart_idToairportNestedInput
    flight_flight_airport_arrivee_idToairport?: flightUncheckedUpdateManyWithoutAirport_flight_airport_arrivee_idToairportNestedInput
  }

  export type airportUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    pays?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    est_actif?: IntFieldUpdateOperationsInput | number
  }

  export type flightCreateManyPlaneInput = {
    id: string
    titre: string
    prix: Decimal | DecimalJsLike | number | string
    date_depart: Date | string
    date_retour: Date | string
    duree?: string | null
    status?: string
    airport_depart_id?: string | null
    airport_arrivee_id?: string | null
  }

  export type seatCreateManyPlaneInput = {
    idSeat?: number
    seatNumber: string
    classType: $Enums.seat_classType
    availability?: number
  }

  export type flightUpdateWithoutPlaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_flight_airport_depart_idToairport?: airportUpdateOneWithoutFlight_flight_airport_depart_idToairportNestedInput
    airport_flight_airport_arrivee_idToairport?: airportUpdateOneWithoutFlight_flight_airport_arrivee_idToairportNestedInput
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutFlightNestedInput
    reservation?: reservationUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateWithoutPlaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutFlightNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightUncheckedUpdateManyWithoutPlaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_depart?: DateTimeFieldUpdateOperationsInput | Date | string
    date_retour?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    airport_depart_id?: NullableStringFieldUpdateOperationsInput | string | null
    airport_arrivee_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seatUpdateWithoutPlaneInput = {
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutSeatNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateWithoutPlaneInput = {
    idSeat?: IntFieldUpdateOperationsInput | number
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutSeatNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateManyWithoutPlaneInput = {
    idSeat?: IntFieldUpdateOperationsInput | number
    seatNumber?: StringFieldUpdateOperationsInput | string
    classType?: Enumseat_classTypeFieldUpdateOperationsInput | $Enums.seat_classType
    availability?: IntFieldUpdateOperationsInput | number
  }

  export type flight_seat_reservationCreateManyReservationInput = {
    id: string
    isReserved?: number
    flight_id?: string | null
    seat_id?: number | null
  }

  export type seat_reservationCreateManyReservationInput = {
    id?: number
    seat_id?: number | null
    flight_id?: string | null
  }

  export type flight_seat_reservationUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    seat?: seatUpdateOneWithoutFlight_seat_reservationNestedInput
    flight?: flightUpdateOneWithoutFlight_seat_reservationNestedInput
  }

  export type flight_seat_reservationUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type flight_seat_reservationUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type seat_reservationUpdateWithoutReservationInput = {
    flight?: flightUpdateOneWithoutSeat_reservationNestedInput
    seat?: seatUpdateOneWithoutSeat_reservationNestedInput
  }

  export type seat_reservationUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seat_reservationUncheckedUpdateManyWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    seat_id?: NullableIntFieldUpdateOperationsInput | number | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type flight_seat_reservationCreateManySeatInput = {
    id: string
    isReserved?: number
    flight_id?: string | null
    reservation_id?: string | null
  }

  export type seat_reservationCreateManySeatInput = {
    id?: number
    reservation_id?: string | null
    flight_id?: string | null
  }

  export type flight_seat_reservationUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight?: flightUpdateOneWithoutFlight_seat_reservationNestedInput
    reservation?: reservationUpdateOneWithoutFlight_seat_reservationNestedInput
  }

  export type flight_seat_reservationUncheckedUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type flight_seat_reservationUncheckedUpdateManyWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    isReserved?: IntFieldUpdateOperationsInput | number
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seat_reservationUpdateWithoutSeatInput = {
    flight?: flightUpdateOneWithoutSeat_reservationNestedInput
    reservation?: reservationUpdateOneWithoutSeat_reservationNestedInput
  }

  export type seat_reservationUncheckedUpdateWithoutSeatInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seat_reservationUncheckedUpdateManyWithoutSeatInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contractCreateManyUserInput = {
    id: string
    clientType: string
    label: string
    contractStartDate: Date | string
    contractEndDate: Date | string
    guaranteedMinimum: Decimal | DecimalJsLike | number | string
    travelStartDate: Date | string
    travelEndDate: Date | string
    isActive?: number
    modifiedFeeAmount?: Decimal | DecimalJsLike | number | string | null
    payLater?: number
    payLaterTimeLimit?: number | null
    minTimeBeforeBalanceFlight?: number | null
    invoiceStamp?: Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fixedTicketPrice?: Decimal | DecimalJsLike | number | string | null
    coupon_id?: string | null
  }

  export type reclamationCreateManyUserInput = {
    id: string
    sujet: string
    description: string
    statut?: string
    date_creation?: Date | string
    reponse?: string | null
    date_reponse?: Date | string | null
  }

  export type request_soldeCreateManyUserInput = {
    id: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    date?: Date | string
    status?: $Enums.request_solde_status
    imageUrl?: string | null
  }

  export type reservationCreateManyUserInput = {
    id: string
    date_reservation: Date | string
    statut: string
    prix_total: Decimal | DecimalJsLike | number | string
    nombre_passagers: number
    coupon_code?: string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    class_type?: string
    fare_type?: string
    flight_id?: string | null
    coupon_id?: string | null
  }

  export type contractUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon?: couponUpdateOneWithoutContractNestedInput
    contract_coupons?: contract_couponsUpdateManyWithoutContractNestedInput
  }

  export type contractUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_coupons?: contract_couponsUncheckedUpdateManyWithoutContractNestedInput
  }

  export type contractUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guaranteedMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    travelStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: IntFieldUpdateOperationsInput | number
    modifiedFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payLater?: IntFieldUpdateOperationsInput | number
    payLaterTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    minTimeBeforeBalanceFlight?: NullableIntFieldUpdateOperationsInput | number | null
    invoiceStamp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalClientAdditionalFees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixedTicketPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reclamationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reclamationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reclamationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sujet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    date_creation?: DateTimeFieldUpdateOperationsInput | Date | string
    reponse?: NullableStringFieldUpdateOperationsInput | string | null
    date_reponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type request_soldeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type request_soldeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type request_soldeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrequest_solde_statusFieldUpdateOperationsInput | $Enums.request_solde_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_seat_reservation?: flight_seat_reservationUpdateManyWithoutReservationNestedInput
    flight?: flightUpdateOneWithoutReservationNestedInput
    coupon?: couponUpdateOneWithoutReservationNestedInput
    seat_reservation?: seat_reservationUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    flight_seat_reservation?: flight_seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
    seat_reservation?: seat_reservationUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date_reservation?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    prix_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombre_passagers?: IntFieldUpdateOperationsInput | number
    coupon_code?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    class_type?: StringFieldUpdateOperationsInput | string
    fare_type?: StringFieldUpdateOperationsInput | string
    flight_id?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}